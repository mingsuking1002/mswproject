{
  "Id": "",
  "GameId": "",
  "EntryKey": "codeblock://d296ead8-51d2-4332-93dc-c1baf8a194db",
  "ContentType": "x-mod/codeblock",
  "Content": "",
  "Usage": 0,
  "UsePublish": 1,
  "UseService": 0,
  "CoreVersion": "26.1.0.0",
  "StudioVersion": "",
  "DynamicLoading": 0,
  "ContentProto": {
    "Use": "Json",
    "Json": {
      "CoreVersion": {
        "Major": 0,
        "Minor": 2
      },
      "ScriptVersion": {
        "Major": 1,
        "Minor": 1
      },
      "Description": "",
      "Id": "d296ead8-51d2-4332-93dc-c1baf8a194db",
      "Language": 1,
      "Name": "ShopUIComponent",
      "Type": 1,
      "Source": 1,
      "Target": "@Component\nscript ShopUIComponent extends Component\n\n    property Entity ShopPanelRoot = nil\n    property string ShopPanelRootPath = \"/ui/DefaultGroup/ShopPanel\"\n\n    property Entity DimOverlayEntity = nil\n    property string DimOverlayPath = \"/ui/DefaultGroup/ShopDimOverlay\"\n\n    property Entity CloseButtonEntity = nil\n    property string CloseButtonPath = \"/ui/DefaultGroup/ShopPanel/CloseButton\"\n\n    property Entity Slot1Root = nil\n    property Entity Slot2Root = nil\n    property Entity Slot3Root = nil\n    property string Slot1Path = \"/ui/DefaultGroup/ShopPanel/Slot1\"\n    property string Slot2Path = \"/ui/DefaultGroup/ShopPanel/Slot2\"\n    property string Slot3Path = \"/ui/DefaultGroup/ShopPanel/Slot3\"\n\n    property Entity GoldDisplayEntity = nil\n    property string GoldDisplayPath = \"/ui/DefaultGroup/ShopPanel/GoldText\"\n\n    property number RefreshInterval = 0.1\n    property number CloseDebounceSeconds = 0.2\n\n    -- Client initializes UI cache/bindings and starts low-frequency sync watch loop.\n    @ExecSpace(\"ClientOnly\")\n    method void OnBeginPlay()\n        self:EnsureGRUtil()\n        self:InitializeRuntimeCacheClient()\n        self:ResolveAndBindUIClient()\n        self:SetShopVisibleClient(false)\n        self:StartRefreshLoopClient()\n        self:RefreshShopUIStateClient(true)\n    end\n\n    -- Map enter re-resolves UI references because map/UI reload can invalidate entity handles.\n    @ExecSpace(\"ClientOnly\")\n    method void OnMapEnter(Entity enteredMap)\n        self:InitializeRuntimeCacheClient()\n        self:ResolveAndBindUIClient()\n        self:RefreshShopUIStateClient(true)\n    end\n\n    -- EndPlay clears timers and event handlers so callbacks do not execute on destroyed UI entities.\n    method void OnEndPlay()\n        if self._T.RefreshTimerId ~= nil and self._T.RefreshTimerId > 0 then\n            _TimerService:ClearTimer(self._T.RefreshTimerId)\n            self._T.RefreshTimerId = 0\n        end\n        if self._T.CloseDebounceTimerId ~= nil and self._T.CloseDebounceTimerId > 0 then\n            _TimerService:ClearTimer(self._T.CloseDebounceTimerId)\n            self._T.CloseDebounceTimerId = 0\n        end\n\n        self:DisconnectCloseButtonClient()\n        self:DisconnectSlotButtonsClient()\n        self._T.IsClosing = false\n    end\n\n    -- Runtime cache bootstrap centralizes state used by polling/render/binding paths.\n    @ExecSpace(\"ClientOnly\")\n    method void InitializeRuntimeCacheClient()\n        if self._T.SlotUI == nil then\n            self._T.SlotUI = {}\n        end\n        if self._T.SlotClickable == nil then\n            self._T.SlotClickable = {}\n        end\n\n        if self._T.RefreshTimerId == nil then\n            self._T.RefreshTimerId = 0\n        end\n        if self._T.CloseDebounceTimerId == nil then\n            self._T.CloseDebounceTimerId = 0\n        end\n        if self._T.IsClosing == nil then\n            self._T.IsClosing = false\n        end\n        if self._T.LastIsShopOpen == nil then\n            self._T.LastIsShopOpen = false\n        end\n        if self._T.LastSlotSignature == nil then\n            self._T.LastSlotSignature = \"\"\n        end\n        if self._T.LastGold == nil then\n            self._T.LastGold = -1\n        end\n    end\n\n    -- Resolve+binder entry keeps setup order deterministic: roots -> slots -> events.\n    @ExecSpace(\"ClientOnly\")\n    method void ResolveAndBindUIClient()\n        self:ResolveRootEntitiesClient()\n        self:CacheSlotUIClient()\n        self:BindCloseButtonClient()\n        self:BindSlotButtonsClient()\n    end\n\n    -- Root resolver supports both explicit path properties and panel-child fallback names.\n    @ExecSpace(\"ClientOnly\")\n    method void ResolveRootEntitiesClient()\n        if self.ShopPanelRoot == nil or isvalid(self.ShopPanelRoot) == false then\n            self.ShopPanelRoot = self:ResolveEntityByPath(self.ShopPanelRootPath)\n        end\n        if self.DimOverlayEntity == nil or isvalid(self.DimOverlayEntity) == false then\n            self.DimOverlayEntity = self:ResolveEntityByPath(self.DimOverlayPath)\n        end\n        if self.CloseButtonEntity == nil or isvalid(self.CloseButtonEntity) == false then\n            self.CloseButtonEntity = self:ResolveEntityByPath(self.CloseButtonPath)\n        end\n        if self.GoldDisplayEntity == nil or isvalid(self.GoldDisplayEntity) == false then\n            self.GoldDisplayEntity = self:ResolveEntityByPath(self.GoldDisplayPath)\n        end\n\n        if self.Slot1Root == nil or isvalid(self.Slot1Root) == false then\n            self.Slot1Root = self:ResolveSlotRootClient(1, self.Slot1Path, \"Slot1\", \"ShopSlot1\", \"Card1\")\n        end\n        if self.Slot2Root == nil or isvalid(self.Slot2Root) == false then\n            self.Slot2Root = self:ResolveSlotRootClient(2, self.Slot2Path, \"Slot2\", \"ShopSlot2\", \"Card2\")\n        end\n        if self.Slot3Root == nil or isvalid(self.Slot3Root) == false then\n            self.Slot3Root = self:ResolveSlotRootClient(3, self.Slot3Path, \"Slot3\", \"ShopSlot3\", \"Card3\")\n        end\n\n        if (self.CloseButtonEntity == nil or isvalid(self.CloseButtonEntity) == false) and self.ShopPanelRoot ~= nil and isvalid(self.ShopPanelRoot) == true then\n            self.CloseButtonEntity = self:ResolveChildByNameCandidates(self.ShopPanelRoot, \"CloseButton\", \"Close\", \"BtnClose\", \"XButton\")\n        end\n        if (self.GoldDisplayEntity == nil or isvalid(self.GoldDisplayEntity) == false) and self.ShopPanelRoot ~= nil and isvalid(self.ShopPanelRoot) == true then\n            self.GoldDisplayEntity = self:ResolveChildByNameCandidates(self.ShopPanelRoot, \"GoldText\", \"GoldDisplay\", \"GoldLabel\", \"CurrentGoldText\")\n        end\n    end\n\n    -- Slot root resolution starts from explicit path, then falls back to ShopPanel child search.\n    @ExecSpace(\"ClientOnly\")\n    method Entity ResolveSlotRootClient(integer slotIndex, string explicitPath, string nameA, string nameB, string nameC)\n        local entity = self:ResolveEntityByPath(explicitPath)\n        if entity ~= nil and isvalid(entity) == true then\n            return entity\n        end\n\n        if self.ShopPanelRoot == nil or isvalid(self.ShopPanelRoot) == false then\n            return nil\n        end\n\n        return self:ResolveChildByNameCandidates(self.ShopPanelRoot, nameA, nameB, nameC, \"Slot\" .. tostring(slotIndex))\n    end\n\n    -- Slot UI cache stores text/button/icon refs so render path avoids repeated hierarchy traversal.\n    @ExecSpace(\"ClientOnly\")\n    method void CacheSlotUIClient()\n        self._T.SlotUI[1] = self:BuildSlotUIEntryClient(self.Slot1Root)\n        self._T.SlotUI[2] = self:BuildSlotUIEntryClient(self.Slot2Root)\n        self._T.SlotUI[3] = self:BuildSlotUIEntryClient(self.Slot3Root)\n    end\n\n    -- Per-slot entry aggregates child widgets and preferred button/text handles.\n    @ExecSpace(\"ClientOnly\")\n    method table BuildSlotUIEntryClient(Entity slotRoot)\n        local entry = {\n            Root = slotRoot,\n            ItemNameText = nil,\n            DescriptionText = nil,\n            PriceText = nil,\n            IconRenderer = nil,\n            PriceButtonEntity = nil,\n            ButtonHandler = nil\n        }\n\n        if slotRoot == nil or isvalid(slotRoot) == false then\n            return entry\n        end\n\n        entry.ItemNameText = self:ResolveTextByNameCandidates(slotRoot, \"ItemName\", \"NameText\", \"TitleText\", \"ItemTitle\")\n        entry.DescriptionText = self:ResolveTextByNameCandidates(slotRoot, \"Description\", \"DescText\", \"DescriptionText\", \"ItemDescription\")\n\n        entry.PriceButtonEntity = self:ResolveChildByNameCandidates(slotRoot, \"PriceButton\", \"BuyButton\", \"PurchaseButton\", \"Button\")\n        if entry.PriceButtonEntity == nil or isvalid(entry.PriceButtonEntity) == false then\n            if slotRoot.ButtonComponent ~= nil then\n                entry.PriceButtonEntity = slotRoot\n            end\n        end\n        if entry.PriceButtonEntity ~= nil and isvalid(entry.PriceButtonEntity) == true then\n            self:EnsureButtonComponentClient(entry.PriceButtonEntity)\n            entry.PriceText = self:ResolvePriceTextComponentClient(entry.PriceButtonEntity)\n        end\n\n        local iconEntity = self:ResolveChildByNameCandidates(slotRoot, \"Icon\", \"ItemIcon\", \"SlotIcon\", \"CardIcon\")\n        if iconEntity ~= nil and isvalid(iconEntity) == true then\n            entry.IconRenderer = iconEntity.SpriteGUIRendererComponent\n        end\n\n        return entry\n    end\n\n    -- Price text resolver prefers button-local text then falls back to common child text names.\n    @ExecSpace(\"ClientOnly\")\n    method TextComponent ResolvePriceTextComponentClient(Entity buttonEntity)\n        if buttonEntity == nil or isvalid(buttonEntity) == false then\n            return nil\n        end\n\n        if buttonEntity.TextComponent ~= nil then\n            return buttonEntity.TextComponent\n        end\n\n        local child = self:ResolveChildByNameCandidates(buttonEntity, \"PriceText\", \"ButtonText\", \"Text\", \"Label\")\n        if child ~= nil and isvalid(child) == true then\n            return child.TextComponent\n        end\n\n        return nil\n    end\n\n    -- Text resolver converts child entity match into text component reference with nil-safe fallback.\n    @ExecSpace(\"ClientOnly\")\n    method TextComponent ResolveTextByNameCandidates(Entity rootEntity, string nameA, string nameB, string nameC, string nameD)\n        local child = self:ResolveChildByNameCandidates(rootEntity, nameA, nameB, nameC, nameD)\n        if child == nil or isvalid(child) == false then\n            return nil\n        end\n        return child.TextComponent\n    end\n\n    -- Close button is connected once; previous handler is disconnected on rebind/map re-enter.\n    @ExecSpace(\"ClientOnly\")\n    method void BindCloseButtonClient()\n        self:DisconnectCloseButtonClient()\n\n        if self.CloseButtonEntity == nil or isvalid(self.CloseButtonEntity) == false then\n            return\n        end\n\n        local buttonComponent = self:EnsureButtonComponentClient(self.CloseButtonEntity)\n        if buttonComponent == nil then\n            return\n        end\n\n        local callback = function(event)\n            self:OnCloseButtonClickedClient(event)\n        end\n\n        local bindOk, bindHandler = pcall(function()\n            return self.CloseButtonEntity:ConnectEvent(ButtonClickEvent, callback)\n        end)\n        if bindOk == true then\n            self._T.CloseButtonHandler = bindHandler\n        end\n    end\n\n    -- Slot buttons are rebound each setup pass to avoid duplicate click callbacks.\n    @ExecSpace(\"ClientOnly\")\n    method void BindSlotButtonsClient()\n        self:DisconnectSlotButtonsClient()\n\n        for slotIndex = 1, 3 do\n            local slotEntry = self._T.SlotUI[slotIndex]\n            if slotEntry ~= nil then\n                local buttonEntity = slotEntry.PriceButtonEntity\n                local buttonComponent = self:EnsureButtonComponentClient(buttonEntity)\n                if buttonComponent ~= nil then\n                    local callback = function(event)\n                        self:OnSlotButtonClickedClient(slotIndex, event)\n                    end\n\n                    local bindOk, bindHandler = pcall(function()\n                        return buttonEntity:ConnectEvent(ButtonClickEvent, callback)\n                    end)\n                    if bindOk == true then\n                        slotEntry.ButtonHandler = bindHandler\n                    end\n                end\n            end\n        end\n    end\n\n    -- Disconnector protects against stale handler reuse when UI refs change after map transitions.\n    @ExecSpace(\"ClientOnly\")\n    method void DisconnectCloseButtonClient()\n        if self._T.CloseButtonHandler == nil then\n            return\n        end\n\n        local buttonEntity = self.CloseButtonEntity\n        if buttonEntity ~= nil and isvalid(buttonEntity) == true then\n            pcall(function()\n                buttonEntity:DisconnectEvent(ButtonClickEvent, self._T.CloseButtonHandler)\n            end)\n        end\n        self._T.CloseButtonHandler = nil\n    end\n\n    -- Slot disconnect loop removes old handlers before reconnect to keep one callback per click.\n    @ExecSpace(\"ClientOnly\")\n    method void DisconnectSlotButtonsClient()\n        if self._T.SlotUI == nil then\n            return\n        end\n\n        for slotIndex = 1, 3 do\n            local slotEntry = self._T.SlotUI[slotIndex]\n            if slotEntry ~= nil and slotEntry.ButtonHandler ~= nil then\n                local buttonEntity = slotEntry.PriceButtonEntity\n                if buttonEntity ~= nil and isvalid(buttonEntity) == true then\n                    pcall(function()\n                        buttonEntity:DisconnectEvent(ButtonClickEvent, slotEntry.ButtonHandler)\n                    end)\n                end\n                slotEntry.ButtonHandler = nil\n            end\n        end\n    end\n\n    -- Close button debounce avoids rapid duplicate close requests while sync propagation is pending.\n    @ExecSpace(\"ClientOnly\")\n    method void OnCloseButtonClickedClient(ButtonClickEvent event)\n        if self._T.IsClosing == true then\n            return\n        end\n        if self:IsShopOpenClient() == false then\n            return\n        end\n\n        self._T.IsClosing = true\n        self:RequestCloseShopServerSafe()\n\n        if self._T.CloseDebounceTimerId ~= nil and self._T.CloseDebounceTimerId > 0 then\n            _TimerService:ClearTimer(self._T.CloseDebounceTimerId)\n            self._T.CloseDebounceTimerId = 0\n        end\n\n        local clearClosing = function()\n            self._T.IsClosing = false\n            self._T.CloseDebounceTimerId = 0\n        end\n        local delay = math.max(0.05, self.CloseDebounceSeconds)\n        self._T.CloseDebounceTimerId = _TimerService:SetTimerOnce(clearClosing, delay)\n    end\n\n    -- Slot click is client-gated by affordability/soldout state before server purchase request.\n    @ExecSpace(\"ClientOnly\")\n    method void OnSlotButtonClickedClient(integer slotIndex, ButtonClickEvent event)\n        if self:IsShopOpenClient() == false then\n            return\n        end\n        if self:IsSlotClickableClient(slotIndex) == false then\n            return\n        end\n\n        self:SetSlotClickableClient(slotIndex, false)\n        self:ApplyOptimisticPurchaseFeedbackClient(slotIndex)\n        self:RequestPurchaseServerSafe(slotIndex)\n    end\n\n    -- Low-frequency timer keeps UI in sync with server properties without per-frame polling overhead.\n    @ExecSpace(\"ClientOnly\")\n    method void StartRefreshLoopClient()\n        if self._T.RefreshTimerId ~= nil and self._T.RefreshTimerId > 0 then\n            return\n        end\n\n        local interval = self.RefreshInterval\n        if interval <= 0 then\n            interval = 0.1\n        end\n        if interval < 0.05 then\n            interval = 0.05\n        end\n\n        local tick = function()\n            self:RefreshShopUIStateClient(false)\n        end\n\n        self._T.RefreshTimerId = _TimerService:SetTimerRepeat(tick, interval, 0)\n    end\n\n    -- Refresh pipeline detects shop-open/slot/gold sync changes and updates UI only when needed.\n    @ExecSpace(\"ClientOnly\")\n    method void RefreshShopUIStateClient(boolean forceRefresh)\n        local shopManager = self:ResolveComponentSafe(self.Entity, \"ShopManagerComponent\", \"IsShopOpen\")\n        if shopManager == nil then\n            self:SetShopVisibleClient(false)\n            return\n        end\n\n        local isShopOpen = self:ReadShopOpenStateClient(shopManager)\n        if forceRefresh == true or self._T.LastIsShopOpen ~= isShopOpen then\n            self._T.LastIsShopOpen = isShopOpen\n            self:SetShopVisibleClient(isShopOpen)\n\n            if isShopOpen == false then\n                self:ClearSlotVisualStateClient()\n                self._T.LastSlotSignature = \"\"\n                self._T.LastGold = -1\n                return\n            end\n        end\n\n        if isShopOpen == false then\n            return\n        end\n\n        local currentGold = self:GetCurrentGoldClient()\n        local slotSignature = self:BuildSlotSignatureClient(shopManager)\n\n        local needsRender = forceRefresh\n        if needsRender ~= true and self._T.LastSlotSignature ~= slotSignature then\n            needsRender = true\n        end\n        if needsRender ~= true and self._T.LastGold ~= currentGold then\n            needsRender = true\n        end\n\n        if needsRender ~= true then\n            return\n        end\n\n        self._T.LastSlotSignature = slotSignature\n        self._T.LastGold = currentGold\n\n        self:RefreshGoldDisplayClient(currentGold)\n        self:RenderSlotsClient(shopManager, currentGold)\n    end\n\n    -- Visibility wrapper controls panel and dim overlay together from one authoritative UI state.\n    @ExecSpace(\"ClientOnly\")\n    method void SetShopVisibleClient(boolean visible)\n        self:SetEntityVisibleClient(self.DimOverlayEntity, visible)\n        self:SetEntityVisibleClient(self.ShopPanelRoot, visible)\n\n        if visible == false then\n            for slotIndex = 1, 3 do\n                self:SetSlotClickableClient(slotIndex, false)\n            end\n            self._T.IsClosing = false\n        end\n    end\n\n    -- Entity visibility helper supports both Enable property and SetEnable API for compatibility.\n    @ExecSpace(\"ClientOnly\")\n    method void SetEntityVisibleClient(Entity targetEntity, boolean visible)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return\n        end\n\n        if targetEntity.SetEnable ~= nil then\n            pcall(function()\n                targetEntity:SetEnable(visible, false, true)\n            end)\n        else\n            pcall(function()\n                targetEntity.Enable = visible\n            end)\n        end\n\n        pcall(function()\n            targetEntity.Visible = visible\n        end)\n    end\n\n    -- Renderer clears stale slot labels when panel closes before next sync payload arrives.\n    @ExecSpace(\"ClientOnly\")\n    method void ClearSlotVisualStateClient()\n        if self._T.SlotUI == nil then\n            return\n        end\n\n        for slotIndex = 1, 3 do\n            local slotEntry = self._T.SlotUI[slotIndex]\n            if slotEntry ~= nil and slotEntry.PriceText ~= nil then\n                pcall(function()\n                    slotEntry.PriceText.Text = \"\"\n                end)\n            end\n            self:SetSlotClickableClient(slotIndex, false)\n        end\n    end\n\n    -- Gold text refresh keeps top-panel currency display consistent with GoldComponent sync value.\n    @ExecSpace(\"ClientOnly\")\n    method void RefreshGoldDisplayClient(integer currentGold)\n        local goldText = self:ResolveGoldTextComponentClient()\n        if goldText == nil then\n            return\n        end\n\n        local safeGold = math.max(0, math.floor(currentGold))\n        pcall(function()\n            goldText.Text = tostring(safeGold) .. \"G\"\n        end)\n    end\n\n    -- Gold text resolver allows late UI instantiation while preserving property-assigned references.\n    @ExecSpace(\"ClientOnly\")\n    method TextComponent ResolveGoldTextComponentClient()\n        if self.GoldDisplayEntity == nil or isvalid(self.GoldDisplayEntity) == false then\n            self.GoldDisplayEntity = self:ResolveEntityByPath(self.GoldDisplayPath)\n            if (self.GoldDisplayEntity == nil or isvalid(self.GoldDisplayEntity) == false) and self.ShopPanelRoot ~= nil and isvalid(self.ShopPanelRoot) == true then\n                self.GoldDisplayEntity = self:ResolveChildByNameCandidates(self.ShopPanelRoot, \"GoldText\", \"GoldDisplay\", \"GoldLabel\", \"CurrentGoldText\")\n            end\n        end\n        if self.GoldDisplayEntity == nil or isvalid(self.GoldDisplayEntity) == false then\n            return nil\n        end\n\n        return self.GoldDisplayEntity.TextComponent\n    end\n\n    -- Slot render applies sync payload, sold-out/affordability rules, and visual button state hints.\n    @ExecSpace(\"ClientOnly\")\n    method void RenderSlotsClient(Component shopManager, integer currentGold)\n        for slotIndex = 1, 3 do\n            local slotData = self:GetSlotSyncDataClient(shopManager, slotIndex)\n            self:RenderOneSlotClient(slotIndex, slotData, currentGold)\n        end\n    end\n\n    -- One-slot render keeps business rules local so all slots share deterministic behavior.\n    @ExecSpace(\"ClientOnly\")\n    method void RenderOneSlotClient(integer slotIndex, table slotData, integer currentGold)\n        local slotEntry = self._T.SlotUI[slotIndex]\n        if slotEntry == nil then\n            return\n        end\n\n        local slotType = \"soldout\"\n        local itemName = \"품절\"\n        local description = \"\"\n        local price = 0\n        local soldOut = true\n\n        if slotData ~= nil then\n            if slotData.Type ~= nil and slotData.Type ~= \"\" then\n                slotType = tostring(slotData.Type)\n            end\n            if slotData.Name ~= nil and slotData.Name ~= \"\" then\n                itemName = tostring(slotData.Name)\n            end\n            if slotData.Description ~= nil then\n                description = tostring(slotData.Description)\n            end\n            if slotData.Price ~= nil then\n                price = math.max(0, math.floor(slotData.Price))\n            end\n            if slotData.SoldOut ~= nil then\n                soldOut = slotData.SoldOut\n            else\n                soldOut = (slotType == \"soldout\")\n            end\n        end\n\n        local canAfford = (currentGold >= price)\n        local clickable = (self:IsShopOpenClient() == true and soldOut == false and canAfford == true)\n\n        local priceLabel = tostring(price) .. \"G\"\n        if soldOut == true then\n            priceLabel = \"품절\"\n        end\n\n        if slotEntry.ItemNameText ~= nil then\n            pcall(function()\n                slotEntry.ItemNameText.Text = itemName\n            end)\n        end\n        if slotEntry.DescriptionText ~= nil then\n            pcall(function()\n                slotEntry.DescriptionText.Text = description\n            end)\n        end\n        if slotEntry.PriceText ~= nil then\n            pcall(function()\n                slotEntry.PriceText.Text = priceLabel\n            end)\n        end\n\n        if soldOut == true then\n            self:SetPriceTextColorClient(slotEntry.PriceText, Color(0.65, 0.65, 0.65, 1))\n        elseif canAfford == true then\n            self:SetPriceTextColorClient(slotEntry.PriceText, Color(1, 1, 1, 1))\n        else\n            self:SetPriceTextColorClient(slotEntry.PriceText, Color(1, 0.3, 0.3, 1))\n        end\n\n        if slotEntry.IconRenderer ~= nil then\n            local iconAlpha = 1.0\n            if soldOut == true then\n                iconAlpha = 0.5\n            end\n            pcall(function()\n                slotEntry.IconRenderer.Color = Color(1, 1, 1, iconAlpha)\n            end)\n        end\n\n        self:SetSlotClickableClient(slotIndex, clickable)\n    end\n\n    -- Slot click state is tracked locally to enforce disabled-button behavior on client.\n    @ExecSpace(\"ClientOnly\")\n    method void SetSlotClickableClient(integer slotIndex, boolean clickable)\n        if self._T.SlotClickable == nil then\n            self._T.SlotClickable = {}\n        end\n        self._T.SlotClickable[slotIndex] = clickable\n\n        local slotEntry = self._T.SlotUI[slotIndex]\n        if slotEntry == nil then\n            return\n        end\n\n        local buttonEntity = slotEntry.PriceButtonEntity\n        if buttonEntity == nil or isvalid(buttonEntity) == false then\n            return\n        end\n\n        local sprite = buttonEntity.SpriteGUIRendererComponent\n        if sprite ~= nil then\n            local alpha = 1.0\n            if clickable == false then\n                alpha = 0.55\n            end\n            pcall(function()\n                sprite.Color = Color(1, 1, 1, alpha)\n            end)\n        end\n    end\n\n    method boolean IsSlotClickableClient(integer slotIndex)\n        if self._T.SlotClickable == nil then\n            return false\n        end\n        return self._T.SlotClickable[slotIndex] == true\n    end\n\n    -- Optimistic feedback gives immediate click response while waiting for authoritative sync update.\n    @ExecSpace(\"ClientOnly\")\n    method void ApplyOptimisticPurchaseFeedbackClient(integer slotIndex)\n        local slotEntry = self._T.SlotUI[slotIndex]\n        if slotEntry == nil or slotEntry.PriceText == nil then\n            return\n        end\n\n        pcall(function()\n            slotEntry.PriceText.Text = \"구매 완료\"\n        end)\n        self:SetPriceTextColorClient(slotEntry.PriceText, Color(0.7, 0.7, 0.7, 1))\n    end\n\n    -- Price-color wrapper keeps text color writes nil-safe and localized to one utility path.\n    @ExecSpace(\"ClientOnly\")\n    method void SetPriceTextColorClient(TextComponent textComponent, Color colorValue)\n        if textComponent == nil then\n            return\n        end\n\n        pcall(function()\n            textComponent.FontColor = colorValue\n        end)\n    end\n\n    -- Signature combines all sync slot fields so renderer can skip updates when payload is unchanged.\n    @ExecSpace(\"ClientOnly\")\n    method string BuildSlotSignatureClient(Component shopManager)\n        local parts = {}\n\n        for slotIndex = 1, 3 do\n            local slotData = self:GetSlotSyncDataClient(shopManager, slotIndex)\n            local token = tostring(slotData.Type) .. \"|\" .. tostring(slotData.Name) .. \"|\" .. tostring(slotData.Description) .. \"|\" .. tostring(slotData.Price) .. \"|\" .. tostring(slotData.SoldOut)\n            table.insert(parts, token)\n        end\n\n        return table.concat(parts, \"||\")\n    end\n\n    -- Slot payload reader maps ShopManager sync fields to a common table schema per index.\n    @ExecSpace(\"ClientOnly\")\n    method table GetSlotSyncDataClient(Component shopManager, integer slotIndex)\n        local data = {\n            Type = \"soldout\",\n            Name = \"품절\",\n            Description = \"\",\n            Price = 0,\n            SoldOut = true\n        }\n\n        if shopManager == nil then\n            return data\n        end\n\n        local readOk, _ = pcall(function()\n            if slotIndex == 1 then\n                data.Type = tostring(shopManager.Slot1Type)\n                data.Name = tostring(shopManager.Slot1Name)\n                data.Description = tostring(shopManager.Slot1Description)\n                data.Price = math.max(0, math.floor(shopManager.Slot1Price))\n                data.SoldOut = (shopManager.Slot1SoldOut == true)\n            elseif slotIndex == 2 then\n                data.Type = tostring(shopManager.Slot2Type)\n                data.Name = tostring(shopManager.Slot2Name)\n                data.Description = tostring(shopManager.Slot2Description)\n                data.Price = math.max(0, math.floor(shopManager.Slot2Price))\n                data.SoldOut = (shopManager.Slot2SoldOut == true)\n            else\n                data.Type = tostring(shopManager.Slot3Type)\n                data.Name = tostring(shopManager.Slot3Name)\n                data.Description = tostring(shopManager.Slot3Description)\n                data.Price = math.max(0, math.floor(shopManager.Slot3Price))\n                data.SoldOut = (shopManager.Slot3SoldOut == true)\n            end\n        end)\n        if readOk == false then\n            return data\n        end\n\n        if data.Type == nil or data.Type == \"\" then\n            data.Type = \"soldout\"\n        end\n        if data.Name == nil or data.Name == \"\" then\n            data.Name = \"품절\"\n        end\n        if data.Description == nil then\n            data.Description = \"\"\n        end\n        if data.SoldOut ~= true and data.Type == \"soldout\" then\n            data.SoldOut = true\n        end\n\n        return data\n    end\n\n    -- Gold reader is isolated for nil-safe fallbacks when GoldComponent sync is not ready yet.\n    @ExecSpace(\"ClientOnly\")\n    method integer GetCurrentGoldClient()\n        local goldComponent = self:ResolveComponentSafe(self.Entity, \"GoldComponent\", \"CurrentGold\")\n        if goldComponent == nil then\n            return 0\n        end\n\n        local currentGold = 0\n        local readOk, _ = pcall(function()\n            currentGold = goldComponent.CurrentGold\n        end)\n        if readOk == false then\n            return 0\n        end\n\n        return math.max(0, math.floor(currentGold))\n    end\n\n    -- Shop-open reader is separated so future rule changes stay localized.\n    @ExecSpace(\"ClientOnly\")\n    method boolean ReadShopOpenStateClient(Component shopManager)\n        if shopManager == nil then\n            return false\n        end\n\n        local isOpen = false\n        local readOk, _ = pcall(function()\n            isOpen = (shopManager.IsShopOpen == true)\n        end)\n        if readOk == false then\n            return false\n        end\n\n        return isOpen\n    end\n\n    method boolean IsShopOpenClient()\n        return self._T.LastIsShopOpen == true\n    end\n\n    -- Purchase RPC wrapper keeps direct server-call dependency isolated to one path.\n    @ExecSpace(\"ClientOnly\")\n    method void RequestPurchaseServerSafe(integer slotIndex)\n        local shopManager = self:ResolveComponentSafe(self.Entity, \"ShopManagerComponent\", \"IsShopOpen\")\n        if shopManager == nil then\n            return\n        end\n        if shopManager.RequestPurchaseServer == nil then\n            return\n        end\n\n        pcall(function()\n            shopManager:RequestPurchaseServer(slotIndex)\n        end)\n    end\n\n    -- Close RPC wrapper is used by close button debounce path.\n    @ExecSpace(\"ClientOnly\")\n    method void RequestCloseShopServerSafe()\n        local shopManager = self:ResolveComponentSafe(self.Entity, \"ShopManagerComponent\", \"IsShopOpen\")\n        if shopManager == nil then\n            return\n        end\n        if shopManager.RequestCloseShopServer == nil then\n            return\n        end\n\n        pcall(function()\n            shopManager:RequestCloseShopServer()\n        end)\n    end\n\n    -- Path resolver isolates _EntityService lookup and validity checks for all UI references.\n    @ExecSpace(\"ClientOnly\")\n    method Entity ResolveEntityByPath(string path)\n        if path == nil or path == \"\" then\n            return nil\n        end\n\n        local entity = _EntityService:GetEntityByPath(path)\n        if entity == nil or isvalid(entity) == false then\n            return nil\n        end\n\n        return entity\n    end\n\n    -- Child-name resolver supports naming variance across Maker prefab iterations.\n    @ExecSpace(\"ClientOnly\")\n    method Entity ResolveChildByNameCandidates(Entity rootEntity, string nameA, string nameB, string nameC, string nameD)\n        if rootEntity == nil or isvalid(rootEntity) == false then\n            return nil\n        end\n\n        local candidates = {nameA, nameB, nameC, nameD}\n        for _, name in pairs(candidates) do\n            if name ~= nil and name ~= \"\" then\n                local findOk, child = pcall(function()\n                    return rootEntity:GetChildByName(name, true)\n                end)\n                if findOk == true and child ~= nil and isvalid(child) == true then\n                    return child\n                end\n            end\n        end\n\n        return nil\n    end\n\n    -- Button helper attaches ButtonComponent on demand so designer-only Sprite nodes still work.\n    @ExecSpace(\"ClientOnly\")\n    method ButtonComponent EnsureButtonComponentClient(Entity targetEntity)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if targetEntity.ButtonComponent ~= nil then\n            return targetEntity.ButtonComponent\n        end\n\n        pcall(function()\n            targetEntity:AddComponent(\"MOD.Core.ButtonComponent\")\n        end)\n\n        return targetEntity.ButtonComponent\n    end\n\n    -- Utility bootstrap first; fallback path remains when global util registration is unavailable.\n    method void EnsureGRUtil()\n        if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, utilApi = pcall(function()\n                return utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and utilApi ~= nil then\n                self._T.GRUtil = utilApi\n            end\n            if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    -- Safe resolver supports both prefixed/plain component names and optional marker validation.\n    method any ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then\n            return self._T.GRUtil.ResolveComponent(targetEntity, scriptName, markerField)\n        end\n\n        local prefixedName = scriptName\n        local plainName = scriptName\n        if string.sub(scriptName, 1, 7) == \"script.\" then\n            plainName = string.sub(scriptName, 8)\n        else\n            prefixedName = \"script.\" .. scriptName\n        end\n\n        local component = targetEntity:GetComponent(prefixedName)\n        if component == nil then\n            component = targetEntity:GetComponent(plainName)\n        end\n        if component == nil then\n            return nil\n        end\n\n        if markerField ~= nil and markerField ~= \"\" then\n            local checkOk, _ = pcall(function()\n                return component[markerField]\n            end)\n            if checkOk == false then\n                return nil\n            end\n        end\n\n        return component\n    end\nend\n"
    }
  }
}