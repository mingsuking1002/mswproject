@Component
script LobbyFlowComponent extends Component

    @Sync
    property boolean IsLobbyActive = true
    property boolean EnableLobbyFlow = true
    property boolean UseMapSplit = false
    property string LobbyMapName = "map01"
    property string InGameMapName = "map01"
    property Vector2 LobbySpawnPosition = Vector2(0, 0)
    property Vector2 InGameSpawnPosition = Vector2(0, 0)

    property boolean AutoOpenRankingOnLobby = true
    property integer LobbyRankingTab = 1
    property boolean AutoStartTimerWhenGameStart = true
    property boolean ResetTimerWhenLobbyActive = true
    property boolean ReturnToLobbyOnRunComplete = true

    property boolean HideRankingDuringGameplay = true
    property boolean HideTimerDuringLobby = true
    property boolean HideCombatHUDInLobby = true
    property boolean LockPlayerControllerInLobby = true
    property boolean LockTagInLobby = true
    property boolean HidePlayerVisualInLobby = true
    property boolean HideMapLayerInLobby = true
    property string MapLayerEntityName = "MapleMapLayer"

    property string StartButtonPath = "/ui/DefaultGroup/GRStartButton"
    property string RankingTextPath = "/ui/DefaultGroup/GRRankingText"
    property string MyRankTextPath = "/ui/DefaultGroup/GRMyRankText"
    property string RankingTextFallbackPath = "/maps/map01/GRRankingText"
    property string MyRankTextFallbackPath = "/maps/map01/GRMyRankText"
    property string TimerTextPath = "/ui/DefaultGroup/GRTimerText"
    property string AttackButtonPath = "/ui/DefaultGroup/Button_Attack"
    property string JumpButtonPath = "/ui/DefaultGroup/Button_Jump"
    property string JoystickPath = "/ui/DefaultGroup/UIJoystick"
    property number ClientUiPollInterval = 0.2
    property number StartButtonBindRetryInterval = 0.25
    property integer StartButtonBindRetryMaxAttempts = 40
    property boolean UseButtonPressedFallback = true
    property boolean EnableKeyboardStartFallback = true

    -- Initializes with a predictable lobby state so first frame behavior is deterministic.
    @ExecSpace("ServerOnly")
    method void OnInitialize()
        self.IsLobbyActive = (self.EnableLobbyFlow == true)
    end

    -- Applies state authority on spawn to avoid race conditions with late client UI load.
    @ExecSpace("ServerOnly")
    method void OnBeginPlay()
        self:ApplyInitialServerState()
    end

    -- Keeps map-split flow stable when the player re-enters maps.
    @ExecSpace("ServerOnly")
    method void OnMapEnter()
        if self.EnableLobbyFlow == false then
            return
        end
        if self.UseMapSplit == false then
            return
        end

        local currentMapName = self.Entity.CurrentMapName
        if self:IsMapNameMatched(currentMapName, self.LobbyMapName) == true then
            self:SetLobbyStateServer(true)
            return
        end

        if self:IsMapNameMatched(currentMapName, self.InGameMapName) == true then
            self:SetLobbyStateServer(false)
        end
    end

    -- Polls client UI state with low frequency so late-loaded UI can still bind safely.
    @ExecSpace("ClientOnly")
    method void OnUpdate(number delta)
        if self.EnableLobbyFlow == false then
            return
        end

        if self._T.ClientUiPollAccumulator == nil then
            self._T.ClientUiPollAccumulator = 0
        end

        self._T.ClientUiPollAccumulator += delta
        if self._T.ClientUiPollAccumulator < math.max(self.ClientUiPollInterval, 0.05) then
            return
        end
        self._T.ClientUiPollAccumulator = 0

        local isButtonBound = self:BindStartButtonClient()
        if isButtonBound == false then
            self:ScheduleStartButtonBindRetryClient()
        end

        local effectiveLobbyState = self:ResolveEffectiveLobbyStateClient()
        self:ApplyLobbyUIClient(effectiveLobbyState)
    end

    -- Validates owner input before changing authoritative gameplay state.
    @ExecSpace("Server")
    method void RequestStartGameServer()
        if self.EnableLobbyFlow == false then
            return
        end
        if self:IsRequestFromOwner() == false then
            return
        end
        if self.IsLobbyActive == false then
            return
        end

        log("[LobbyFlowComponent] Start game accepted. user=", tostring(self.Entity.PlayerComponent.UserId))
        if self.UseMapSplit == true then
            if self.InGameMapName ~= nil and self.InGameMapName ~= "" then
                if self:IsMapNameMatched(self.Entity.CurrentMapName, self.InGameMapName) == true then
                    self:SetLobbyStateServer(false)
                    return
                end
            end

            local moveRequested = self:MoveOwnerToInGameMapIfNeeded()
            if moveRequested == true then
                -- 맵 전환 이벤트 지연 시에도 로비 UI/마스크가 남지 않도록 즉시 인게임 상태를 적용한다.
                self:SetLobbyStateServer(false)
            else
                log_warning("[LobbyFlowComponent] Failed to request move to ingame map: ", tostring(self.InGameMapName))
            end
            return
        end

        self:SetLobbyStateServer(false)
    end

    -- 결과 확정 시점(클리어/사망)을 단일 진입점으로 모아 타이머 종료와 로비 복귀 순서를 고정한다.
    @ExecSpace("ServerOnly")
    method void HandleRunCompletedServer(boolean isClear)
        local timerComponent = self.Entity:GetComponent("SpeedrunTimerComponent")
        if timerComponent ~= nil and isvalid(timerComponent) == true then
            timerComponent:CompleteRun()
        end

        local movedToLobbyMap = false
        if self.ReturnToLobbyOnRunComplete == true then
            if self.UseMapSplit == true then
                movedToLobbyMap = self:MoveOwnerToLobbyMapIfNeeded()
            end

            -- split 이동 요청이 실패했을 때만 즉시 로비 상태를 적용한다.
            if movedToLobbyMap == false then
                self:SetLobbyStateServer(true)
            end
        end

        if isClear == true then
            log("[LobbyFlowComponent] Run completed: CLEAR")
        else
            log("[LobbyFlowComponent] Run completed: FAIL")
        end

        if movedToLobbyMap == true then
            log("[LobbyFlowComponent] Lobby map move requested: ", tostring(self.LobbyMapName))
        end
    end

    -- 외부 시스템이 클리어 결과만 전달하면 공통 결과 처리로 합류한다.
    @ExecSpace("ServerOnly")
    method void HandleStageClearServer()
        self:HandleRunCompletedServer(true)
    end

    -- 외부 시스템이 실패 결과만 전달하면 공통 결과 처리로 합류한다.
    @ExecSpace("ServerOnly")
    method void HandleStageFailedServer()
        self:HandleRunCompletedServer(false)
    end

    -- Provides a temporary non-UI start path while button/input routing is being stabilized.
    @EventSender("Service", "InputService")
    handler HandleLobbyStartKeyDownEvent(KeyDownEvent event)
        if self.EnableKeyboardStartFallback == false then
            return
        end
        if self.EnableLobbyFlow == false then
            return
        end
        if self.IsLobbyActive == false then
            return
        end

        local key = event.key
        if key == KeyboardKey.Return or key == KeyboardKey.Space then
            log("[LobbyFlowComponent] Keyboard start fallback used.")
            if self.IsLobbyActive == true then
                self:ApplyLobbyUIClient(false)
            end
            self:RequestStartGameServer()
        end
    end

    -- Avoids stale event handlers when entity/session ends.
    @ExecSpace("ClientOnly")
    method void OnEndPlay()
        local buttonEntity = self._T.StartButtonEntity
        if buttonEntity ~= nil and isvalid(buttonEntity) == true then
            local clickHandler = self._T.StartButtonClickHandler
            if clickHandler ~= nil then
                buttonEntity:DisconnectEvent("ButtonClickEvent", clickHandler)
            end

            local pressedHandler = self._T.StartButtonPressedHandler
            if pressedHandler ~= nil then
                buttonEntity:DisconnectEvent("ButtonPressedEvent", pressedHandler)
            end
        end

        if self._T.BindRetryTimerId ~= nil and self._T.BindRetryTimerId > 0 then
            _TimerService:ClearTimer(self._T.BindRetryTimerId)
            self._T.BindRetryTimerId = 0
        end

        self._T.StartButtonEntity = nil
        self._T.StartButtonClickHandler = nil
        self._T.StartButtonPressedHandler = nil
        self._T.BindRetryAttempt = 0
        self._T.ClientUiPollAccumulator = 0
        self._T.LastAppliedLobbyState = nil

        self:SetPlayerVisualVisibleClient(true)
        self:SetCurrentMapLayerVisibleClient(true)
    end

    -- Called by UI click; server validates ownership and transitions state.
    @ExecSpace("ClientOnly")
    method void OnStartButtonClickedClient(any event)
        log("[LobbyFlowComponent] Start button input received.")
        if self.IsLobbyActive == true then
            -- 서버 응답 지연 중에도 로비 오버레이가 남지 않도록 즉시 클라이언트 상태를 인게임으로 전환한다.
            self:ApplyLobbyUIClient(false)
        end
        self:RequestStartGameServer()
    end

    @ExecSpace("ServerOnly")
    method void ApplyInitialServerState()
        if self.EnableLobbyFlow == false then
            self:SetLobbyStateServer(false)
            return
        end

        if self.UseMapSplit == true then
            if self:IsMapNameMatched(self.Entity.CurrentMapName, self.LobbyMapName) == true then
                self:SetLobbyStateServer(true)
            else
                self:SetLobbyStateServer(false)
            end
            return
        end

        self:SetLobbyStateServer(true)
    end

    -- Centralized authority switch for combat/timer flow.
    @ExecSpace("ServerOnly")
    method void SetLobbyStateServer(boolean isLobby)
        self.IsLobbyActive = isLobby
        self:ApplyLobbyControlLockServer(isLobby)
        self:TrySetMovementCanMove(isLobby == false)

        local fireComponent = self.Entity:GetComponent("FireSystemComponent")
        if fireComponent ~= nil and isvalid(fireComponent) == true then
            fireComponent.CanAttack = (isLobby == false)
        end

        local weaponSwapComponent = self.Entity:GetComponent("WeaponSwapComponent")
        if weaponSwapComponent ~= nil and isvalid(weaponSwapComponent) == true then
            weaponSwapComponent.AllowSwapMenu = (isLobby == false)
            if isLobby == true and weaponSwapComponent.IsSwapMenuOpen == true then
                weaponSwapComponent.IsSwapMenuOpen = false
                weaponSwapComponent.IsGameLogicPaused = false
            end
        end

        local tagComponent = self.Entity:GetComponent("TagManagerComponent")
        if tagComponent ~= nil and isvalid(tagComponent) == true then
            if self.LockTagInLobby == true then
                tagComponent.IsTagLocked = isLobby
            elseif isLobby == false then
                tagComponent.IsTagLocked = false
            end
        end

        local hpComponent = self.Entity:GetComponent("HPSystemComponent")
        if hpComponent ~= nil and isvalid(hpComponent) == true then
            if isLobby == true and hpComponent.ReviveToFullHP ~= nil then
                hpComponent:ReviveToFullHP()
            end
        end

        local timerComponent = self.Entity:GetComponent("SpeedrunTimerComponent")
        if timerComponent ~= nil and isvalid(timerComponent) == true then
            timerComponent:SetExternalPauseState("LOBBY_FLOW", isLobby)

            if isLobby == true and self.ResetTimerWhenLobbyActive == true then
                timerComponent:ResetRun()
            end
            if isLobby == false and self.AutoStartTimerWhenGameStart == true then
                if timerComponent.IsRunning == false and timerComponent.IsCountdownRunning == false then
                    if timerComponent.StartRunWithCountdown ~= nil then
                        timerComponent:StartRunWithCountdown()
                    else
                        timerComponent:StartRun()
                    end
                end
            end
        end

        self:ApplyLobbyUIClient(isLobby)
    end

    -- Resolves custom movement component first to avoid native MovementComponent name collisions.
    method Component ResolveProjectMovementComponent()
        local prefixed = self.Entity:GetComponent("script.MovementComponent")
        if self:CanWriteComponentField(prefixed, "CanMove") == true then
            return prefixed
        end

        local plain = self.Entity:GetComponent("MovementComponent")
        if self:CanWriteComponentField(plain, "CanMove") == true then
            return plain
        end

        return nil
    end

    -- Protects movement lock writes from runtime exceptions when wrong component type is returned.
    method boolean TrySetMovementCanMove(boolean canMove)
        local movementComponent = self:ResolveProjectMovementComponent()
        if movementComponent == nil then
            return false
        end

        local ok, _ = pcall(function()
            movementComponent.CanMove = canMove
        end)
        if ok == false then
            log_warning("[LobbyFlowComponent] Failed to set MovementComponent.CanMove")
            return false
        end

        return true
    end

    -- Uses read+write probe so nil-valued fields are still recognized while missing fields are rejected.
    method boolean CanWriteComponentField(any targetComponent, string fieldName)
        if targetComponent == nil or isvalid(targetComponent) == false then
            return false
        end
        if fieldName == nil or fieldName == "" then
            return false
        end

        local readOk, readValue = pcall(function()
            return targetComponent[fieldName]
        end)
        if readOk == false then
            return false
        end

        local writeOk, _ = pcall(function()
            targetComponent[fieldName] = readValue
        end)
        return writeOk
    end

    -- 로비 상태에서는 기본 조작 컴포넌트까지 잠가 키 입력 누락 경로를 차단한다.
    @ExecSpace("ServerOnly")
    method void ApplyLobbyControlLockServer(boolean isLobby)
        local playerController = self.Entity.PlayerControllerComponent
        if playerController ~= nil and isvalid(playerController) == true then
            if self.LockPlayerControllerInLobby == true then
                playerController.Enable = (isLobby == false)
            else
                playerController.Enable = true
            end
        end

        local nativeMovement = self.Entity:GetComponent("MOD.Core.MovementComponent")
        if nativeMovement ~= nil and isvalid(nativeMovement) == true then
            if self._T.NativeMoveInputSpeed == nil then
                self._T.NativeMoveInputSpeed = nativeMovement.InputSpeed
            end

            if isLobby == true then
                nativeMovement.InputSpeed = 0
                nativeMovement:Stop()
            elseif self._T.NativeMoveInputSpeed ~= nil then
                nativeMovement.InputSpeed = self._T.NativeMoveInputSpeed
            end
        end

        local rigidbody = self.Entity.RigidbodyComponent
        if rigidbody ~= nil and isvalid(rigidbody) == true and isLobby == true then
            rigidbody.MoveVelocity = Vector2.zero
        end
    end

    -- 로비에서는 전투 화면 노출을 줄이고 시작 화면 UI에만 집중하게 만든다.
    @ExecSpace("ClientOnly")
    method void ApplyLobbyVisualMaskClient(boolean isLobby)
        local shouldShowGameplayVisual = (isLobby == false)

        if self.HidePlayerVisualInLobby == true then
            self:SetPlayerVisualVisibleClient(shouldShowGameplayVisual)
        else
            self:SetPlayerVisualVisibleClient(true)
        end

        if self.HideMapLayerInLobby == true then
            self:SetCurrentMapLayerVisibleClient(shouldShowGameplayVisual)
        else
            self:SetCurrentMapLayerVisibleClient(true)
        end
    end

    -- 플레이어 렌더 알파를 제어해 로비에서 캐릭터 노출을 제거한다.
    @ExecSpace("ClientOnly")
    method void SetPlayerVisualVisibleClient(boolean visible)
        local alpha = 1
        if visible == false then
            alpha = 0
        end

        local avatarRenderer = self.Entity.AvatarRendererComponent
        if avatarRenderer ~= nil and isvalid(avatarRenderer) == true then
            avatarRenderer:SetAlpha(alpha)
        end

        local spriteRenderer = self.Entity.SpriteRendererComponent
        if spriteRenderer ~= nil and isvalid(spriteRenderer) == true then
            spriteRenderer:SetAlpha(alpha)
        end
    end

    -- 맵 레이어 가시성을 토글해 로비 상태에서 전투 월드 화면을 가린다.
    @ExecSpace("ClientOnly")
    method void SetCurrentMapLayerVisibleClient(boolean visible)
        local mapEntity = self.Entity.CurrentMap
        if mapEntity == nil or isvalid(mapEntity) == false then
            return
        end

        local layerName = self.MapLayerEntityName
        if layerName == nil or layerName == "" then
            return
        end

        local layerEntity = mapEntity:GetChildByName(layerName, true)
        if (layerEntity == nil or isvalid(layerEntity) == false) and layerName ~= "Layer1" then
            layerEntity = mapEntity:GetChildByName("Layer1", true)
        end
        if (layerEntity == nil or isvalid(layerEntity) == false) and layerName ~= "MapleMapLayer" then
            layerEntity = mapEntity:GetChildByName("MapleMapLayer", true)
        end
        if layerEntity == nil or isvalid(layerEntity) == false then
            return
        end

        layerEntity.Enable = visible
        local mapLayerComponent = layerEntity.MapLayerComponent
        if mapLayerComponent ~= nil and isvalid(mapLayerComponent) == true then
            pcall(function()
                mapLayerComponent.IsVisible = visible
            end)
        end
    end

    -- Keeps map split optional so same-scene flow remains default.
    @ExecSpace("ServerOnly")
    method boolean MoveOwnerToInGameMapIfNeeded()
        if self.UseMapSplit == false then
            return false
        end
        if self.InGameMapName == nil or self.InGameMapName == "" then
            return false
        end
        if self:IsMapNameMatched(self.Entity.CurrentMapName, self.InGameMapName) == true then
            return false
        end

        local playerComponent = self.Entity.PlayerComponent
        if playerComponent == nil then
            return false
        end

        playerComponent:MoveToMapPosition(self.InGameMapName, self.InGameSpawnPosition)
        return true
    end

    -- 결과 확정 후 split-scene 로비 맵으로 이동시켜 로비 UI와 월드를 일치시킨다.
    @ExecSpace("ServerOnly")
    method boolean MoveOwnerToLobbyMapIfNeeded()
        if self.UseMapSplit == false then
            return false
        end
        if self.LobbyMapName == nil or self.LobbyMapName == "" then
            return false
        end
        if self:IsMapNameMatched(self.Entity.CurrentMapName, self.LobbyMapName) == true then
            return false
        end

        local playerComponent = self.Entity.PlayerComponent
        if playerComponent == nil then
            return false
        end

        playerComponent:MoveToMapPosition(self.LobbyMapName, self.LobbySpawnPosition)
        return true
    end

    -- Applies UI-only state change on each client from authoritative server transitions.
    @ExecSpace("Client")
    method void ApplyLobbyUIClient(boolean isLobby)
        local previousLobbyState = self._T.LastAppliedLobbyState

        local isButtonBound = self:BindStartButtonClient()
        if isButtonBound == false then
            self:ScheduleStartButtonBindRetryClient()
        end

        self:SetEntityEnableByPath(self.StartButtonPath, isLobby)

        local rankingVisible = isLobby
        if self.HideRankingDuringGameplay == false then
            rankingVisible = true
        end
        self:SetEntityEnableByPath(self.RankingTextPath, rankingVisible)
        self:SetEntityEnableByPath(self.MyRankTextPath, rankingVisible)
        self:SetEntityEnableByPathIfExists(self.RankingTextFallbackPath, rankingVisible)
        self:SetEntityEnableByPathIfExists(self.MyRankTextFallbackPath, rankingVisible)

        local timerVisible = (isLobby == false)
        if self.HideTimerDuringLobby == false then
            timerVisible = true
        end
        self:SetEntityEnableByPath(self.TimerTextPath, timerVisible)

        local combatHudVisible = (isLobby == false)
        if self.HideCombatHUDInLobby == false then
            combatHudVisible = true
        end
        self:SetEntityEnableByPath(self.AttackButtonPath, combatHudVisible)
        self:SetEntityEnableByPath(self.JumpButtonPath, combatHudVisible)
        self:SetEntityEnableByPath(self.JoystickPath, combatHudVisible)

        local rankingUIComponent = self.Entity:GetComponent("RankingUIComponent")
        if rankingUIComponent ~= nil and isvalid(rankingUIComponent) == true then
            if rankingUIComponent.SetRankingVisibleClient ~= nil then
                rankingUIComponent:SetRankingVisibleClient(rankingVisible)
            end
        end

        if isLobby == true and self.AutoOpenRankingOnLobby == true and previousLobbyState ~= true then
            if rankingUIComponent ~= nil and isvalid(rankingUIComponent) == true then
                rankingUIComponent:OpenTab(self.LobbyRankingTab)
            end
        end

        self:ApplyLobbyVisualMaskClient(isLobby)
        self._T.LastAppliedLobbyState = isLobby
    end

    -- MapSplit 환경에서는 현재 맵 이름을 우선 기준으로 UI 상태를 결정해 Sync 지연/누락을 보정한다.
    @ExecSpace("ClientOnly")
    method boolean ResolveEffectiveLobbyStateClient()
        if self.EnableLobbyFlow == false then
            return false
        end

        if self.UseMapSplit == false then
            return self.IsLobbyActive
        end

        local currentMapName = self.Entity.CurrentMapName
        if self:IsMapNameMatched(currentMapName, self.InGameMapName) == true then
            return false
        end
        if self:IsMapNameMatched(currentMapName, self.LobbyMapName) == true then
            return true
        end

        -- 맵명이 애매한 경우 로비 UI 잔류를 방지하기 위해 인게임 상태를 기본값으로 사용한다.
        return false
    end

    @ExecSpace("ClientOnly")
    method boolean BindStartButtonClient()
        if self._T.StartButtonClickHandler ~= nil then
            local currentButton = self._T.StartButtonEntity
            if currentButton ~= nil and isvalid(currentButton) == true then
                return true
            end

            self._T.StartButtonEntity = nil
            self._T.StartButtonClickHandler = nil
            self._T.StartButtonPressedHandler = nil
        end

        local startButtonEntity = self:ResolveEntityByPath(self.StartButtonPath)
        if startButtonEntity == nil then
            return false
        end

        local clickHandler = function(event)
            self:OnStartButtonClickedClient(event)
        end
        local clickEventHandler = startButtonEntity:ConnectEvent("ButtonClickEvent", clickHandler)
        if clickEventHandler == nil then
            return false
        end

        local pressedEventHandler = nil
        if self.UseButtonPressedFallback == true then
            local pressedHandler = function(event)
                self:OnStartButtonClickedClient(event)
            end
            pressedEventHandler = startButtonEntity:ConnectEvent("ButtonPressedEvent", pressedHandler)
        end

        self._T.StartButtonEntity = startButtonEntity
        self._T.StartButtonClickHandler = clickEventHandler
        self._T.StartButtonPressedHandler = pressedEventHandler
        log("[LobbyFlowComponent] Start button bound: ", tostring(self.StartButtonPath))
        return true
    end

    -- Retries UI binding with bounded repeats so delayed UI init does not deadlock start flow.
    @ExecSpace("ClientOnly")
    method void ScheduleStartButtonBindRetryClient()
        if self._T.BindRetryTimerId ~= nil and self._T.BindRetryTimerId > 0 then
            return
        end

        self._T.BindRetryAttempt = 0
        local bindRetry = function()
            self._T.BindRetryAttempt = self._T.BindRetryAttempt + 1

            local isBound = self:BindStartButtonClient()
            if isBound == true then
                if self._T.BindRetryTimerId ~= nil and self._T.BindRetryTimerId > 0 then
                    _TimerService:ClearTimer(self._T.BindRetryTimerId)
                end
                self._T.BindRetryTimerId = 0
                self._T.BindRetryAttempt = 0
                self:ApplyLobbyUIClient(self:ResolveEffectiveLobbyStateClient())
                return
            end

            if self._T.BindRetryAttempt >= math.max(self.StartButtonBindRetryMaxAttempts, 1) then
                if self._T.BindRetryTimerId ~= nil and self._T.BindRetryTimerId > 0 then
                    _TimerService:ClearTimer(self._T.BindRetryTimerId)
                end
                self._T.BindRetryTimerId = 0
                log_warning("[LobbyFlowComponent] Start button bind timeout: ", tostring(self.StartButtonPath))
            end
        end
        self._T.BindRetryTimerId = _TimerService:SetTimerRepeat(bindRetry, math.max(self.StartButtonBindRetryInterval, 0.05), 0.0)
    end

    @ExecSpace("ClientOnly")
    method void SetEntityEnableByPath(string entityPath, boolean enabled)
        local targetEntity = self:ResolveEntityByPath(entityPath)
        if targetEntity == nil then
            if self._T.MissingUiPathWarn == nil then
                self._T.MissingUiPathWarn = {}
            end
            if self._T.MissingUiPathWarn[entityPath] ~= true then
                self._T.MissingUiPathWarn[entityPath] = true
                log_warning("[LobbyFlowComponent] UI path not found: ", tostring(entityPath))
            end
            return
        end

        self:ApplyEntityEnableStateClient(targetEntity, enabled)
    end

    -- 폴백 경로는 존재하지 않아도 정상 시나리오가 있으므로 경고 없이 시도만 수행한다.
    @ExecSpace("ClientOnly")
    method void SetEntityEnableByPathIfExists(string entityPath, boolean enabled)
        local targetEntity = self:ResolveEntityByPath(entityPath)
        if targetEntity == nil then
            return
        end

        self:ApplyEntityEnableStateClient(targetEntity, enabled)
    end

    -- UI 타입별 Enable/Visible 제어를 한곳에서 처리해 상태 잔류를 방지한다.
    @ExecSpace("ClientOnly")
    method void ApplyEntityEnableStateClient(Entity targetEntity, boolean enabled)
        if targetEntity == nil or isvalid(targetEntity) == false then
            return
        end

        targetEntity.Enable = enabled
        pcall(function()
            targetEntity.Visible = enabled
        end)

        self:TrySetComponentEnable(targetEntity.UITransformComponent, enabled)
        self:TrySetComponentEnable(targetEntity.SpriteGUIRendererComponent, enabled)
        self:TrySetComponentEnable(targetEntity.TextComponent, enabled)
        self:TrySetComponentEnable(targetEntity.ButtonComponent, enabled)
        self:TrySetEntityVisualAlpha(targetEntity, enabled)
    end

    -- UI 엔티티/컴포넌트별 Enable 프로퍼티 존재 여부가 다르므로 pcall 기반으로 안전 적용한다.
    @ExecSpace("ClientOnly")
    method void TrySetComponentEnable(any targetComponent, boolean enabled)
        if targetComponent == nil or isvalid(targetComponent) == false then
            return
        end

        pcall(function()
            targetComponent.Enable = enabled
        end)
    end

    -- 일부 UI 컴포넌트는 Enable만으로 잔상이 남을 수 있어 알파도 함께 강제한다.
    @ExecSpace("ClientOnly")
    method void TrySetEntityVisualAlpha(Entity targetEntity, boolean enabled)
        if targetEntity == nil or isvalid(targetEntity) == false then
            return
        end

        local targetAlpha = 1.0
        if enabled == false then
            targetAlpha = 0.0
        end

        local spriteGuiRenderer = targetEntity.SpriteGUIRendererComponent
        if spriteGuiRenderer ~= nil and isvalid(spriteGuiRenderer) == true then
            pcall(function()
                local color = spriteGuiRenderer.Color
                color.a = targetAlpha
                spriteGuiRenderer.Color = color
            end)
        end

        local textComponent = targetEntity.TextComponent
        if textComponent ~= nil and isvalid(textComponent) == true then
            pcall(function()
                local fontColor = textComponent.FontColor
                fontColor.a = targetAlpha
                textComponent.FontColor = fontColor
            end)
            pcall(function()
                local outlineColor = textComponent.OutlineColor
                outlineColor.a = targetAlpha
                textComponent.OutlineColor = outlineColor
            end)
        end

        local canvasGroup = targetEntity.CanvasGroupComponent
        if canvasGroup ~= nil and isvalid(canvasGroup) == true then
            pcall(function()
                canvasGroup.Alpha = targetAlpha
                canvasGroup.Interactable = enabled
            end)
        end
    end

    method Entity ResolveEntityByPath(string entityPath)
        if entityPath == nil or entityPath == "" then
            return nil
        end

        local targetEntity = _EntityService:GetEntityByPath(entityPath)
        if targetEntity == nil or isvalid(targetEntity) == false then
            return nil
        end

        return targetEntity
    end

    -- `/maps/map01` 형태와 `map01` 형태를 동일 맵명으로 취급해 비교 오류를 줄인다.
    method string NormalizeMapName(string mapName)
        if mapName == nil then
            return ""
        end

        local normalized = tostring(mapName)
        if normalized == "" then
            return ""
        end

        local lastSlash = 0
        local length = string.len(normalized)
        for i = 1, length do
            if string.sub(normalized, i, i) == "/" then
                lastSlash = i
            end
        end

        if lastSlash > 0 and lastSlash < length then
            normalized = string.sub(normalized, lastSlash + 1, length)
        end

        return string.lower(normalized)
    end

    -- 맵명 비교를 표준화해 split-scene 전환 시 UI 상태 오판정을 방지한다.
    method boolean IsMapNameMatched(string currentMapName, string targetMapName)
        local normalizedCurrent = self:NormalizeMapName(currentMapName)
        local normalizedTarget = self:NormalizeMapName(targetMapName)
        if normalizedCurrent == "" or normalizedTarget == "" then
            return false
        end

        return normalizedCurrent == normalizedTarget
    end

    @ExecSpace("ServerOnly")
    method boolean IsRequestFromOwner()
        local playerComponent = self.Entity.PlayerComponent
        if playerComponent == nil then
            return true
        end
        if senderUserId == nil then
            return true
        end

        return senderUserId == playerComponent.UserId
    end
end




