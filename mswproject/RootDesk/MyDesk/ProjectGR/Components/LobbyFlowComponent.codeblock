{
  "Id": "",
  "GameId": "",
  "EntryKey": "codeblock://041160bb-4254-403c-bb04-6b254fec390a",
  "ContentType": "x-mod/codeblock",
  "Content": "",
  "Usage": 0,
  "UsePublish": 1,
  "UseService": 0,
  "CoreVersion": "26.1.0.0",
  "StudioVersion": "",
  "DynamicLoading": 0,
  "ContentProto": {
    "Use": "Json",
    "Json": {
      "CoreVersion": {
        "Major": 0,
        "Minor": 2
      },
      "ScriptVersion": {
        "Major": 1,
        "Minor": 1
      },
      "Description": "",
      "Id": "041160bb-4254-403c-bb04-6b254fec390a",
      "Language": 1,
      "Name": "LobbyFlowComponent",
      "Type": 1,
      "Source": 1,
      "Target": "@Component\nscript LobbyFlowComponent extends Component\n\n    @Sync\n    property boolean IsLobbyActive = true\n\n    property boolean EnableLobbyFlow = true\n    property boolean UseMapSplit = true\n    property string LobbyMapName = \"lobby\"\n    property string InGameMapName = \"map01\"\n    property Vector2 InGameSpawnPosition = Vector2(0, 0)\n\n    property boolean HideRankingDuringGameplay = true\n    property boolean HideTimerDuringLobby = true\n    property boolean HideCombatHUDInLobby = true\n    property boolean ReturnToLobbyOnRunComplete = true\n    property boolean EnableKeyboardStartFallback = false\n\n    property string StartButtonPath = \"/ui/DefaultGroup/GRStartButton\"\n    property string StartButtonFallbackPath = \"\"\n    property string RankingTextPath = \"/ui/DefaultGroup/GRRankingText\"\n    property string RankingTextFallbackPath = \"\"\n    property string MyRankTextPath = \"/ui/DefaultGroup/GRMyRankText\"\n    property string MyRankTextFallbackPath = \"\"\n    property string TimerTextPath = \"/ui/DefaultGroup/GRTimerText\"\n\n    -- Server initializes lobby state and utility bootstrap before gameplay begins.\n    @ExecSpace(\"ServerOnly\")\n    method void OnInitialize()\n        self:EnsureGRUtil()\n        self._T.StartButtonHandler = nil\n    end\n\n    -- Server applies initial lock state once so lobby/in-game lock policy starts from authoritative state.\n    @ExecSpace(\"ServerOnly\")\n    method void OnBeginPlay()\n        if self.EnableLobbyFlow == false then\n            return\n        end\n        self:ApplyInitialServerState()\n    end\n\n    -- Client refresh on map enter avoids one-frame stale UI during room/map transitions.\n    @ExecSpace(\"ClientOnly\")\n    method void OnMapEnter(Entity enteredMap)\n        if self.EnableLobbyFlow == false then\n            return\n        end\n        self:BindStartButtonClient()\n        self:ApplyLobbyUIClient(self:ResolveEffectiveLobbyStateClient())\n    end\n\n    -- Button click is the primary start route; keyboard fallback is intentionally disabled by default.\n    @ExecSpace(\"ClientOnly\")\n    method void HandleStartButtonClickClient(ButtonClickEvent event)\n        if self.EnableLobbyFlow == false then\n            return\n        end\n        if self.IsLobbyActive == false then\n            return\n        end\n\n        self:RequestStartGameServer()\n    end\n\n    -- Optional keyboard route remains behind explicit flag for emergency input fallback only.\n    @EventSender(\"Service\", \"InputService\")\n    handler HandleKeyDownEvent(KeyDownEvent event)\n        if self.EnableKeyboardStartFallback == false then\n            return\n        end\n        if self.IsLobbyActive == false then\n            return\n        end\n\n        if event.key == KeyboardKey.Return or event.key == KeyboardKey.Space then\n            log(\"[LobbyFlowComponent] Keyboard start fallback used.\")\n            self:RequestStartGameServer()\n        end\n    end\n\n    -- Client asks server to start run; server keeps final authority on lobby state changes.\n    @ExecSpace(\"Server\")\n    method void RequestStartGameServer()\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n        if self.EnableLobbyFlow == false then\n            return\n        end\n        if self.IsLobbyActive == false then\n            return\n        end\n\n        self:SetLobbyStateServer(false)\n        self:MoveOwnerToInGameMapIfNeeded()\n        self:StartRunTimerServer()\n    end\n\n    -- Run completion path is shared by clear/fail flows and can return user to lobby map.\n    @ExecSpace(\"ServerOnly\")\n    method void HandleRunCompletedServer(boolean isClear)\n        self:CompleteRunTimerServer()\n        if self.ReturnToLobbyOnRunComplete == false then\n            return\n        end\n\n        self:SetLobbyStateServer(true)\n        self:MoveOwnerToLobbyMapIfNeeded()\n    end\n\n    -- Stage-fail alias is referenced by HPSystem fallback flow.\n    @ExecSpace(\"ServerOnly\")\n    method void HandleStageFailedServer()\n        self:HandleRunCompletedServer(false)\n    end\n\n    -- Initial server state aligns movement/attack/timer pause with current lobby flag.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyInitialServerState()\n        self:SetLobbyStateServer(self.IsLobbyActive)\n    end\n\n    -- Lobby state setter centralizes lock/unlock and linked component policy updates.\n    @ExecSpace(\"ServerOnly\")\n    method void SetLobbyStateServer(boolean isLobby)\n        self.IsLobbyActive = isLobby\n        self:ApplyGameplayLockByLobbyServer(isLobby)\n    end\n\n    -- Gameplay lock routes through shared components to keep server authority and state consistency.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyGameplayLockByLobbyServer(boolean isLobby)\n        self:SetCanMoveSafely(not isLobby)\n        self:SetCanAttackSafely(not isLobby)\n\n        local timerComponent = self:ResolveComponentSafe(self.Entity, \"SpeedrunTimerComponent\", \"IsRunning\")\n        if timerComponent ~= nil and timerComponent.SetPauseSource ~= nil then\n            pcall(function()\n                timerComponent:SetPauseSource(\"Lobby\", isLobby)\n            end)\n        end\n\n        local hudComponent = self:ResolveComponentSafe(self.Entity, \"HUDComponent\", nil)\n        if hudComponent ~= nil and hudComponent.ApplyLobbyStateClient ~= nil and self.HideCombatHUDInLobby == true then\n            pcall(function()\n                hudComponent:ApplyLobbyStateClient(isLobby)\n            end)\n        end\n    end\n\n    -- Client UI apply keeps visibility changes in one location to avoid split ownership bugs.\n    @ExecSpace(\"ClientOnly\")\n    method void ApplyLobbyUIClient(boolean isLobby)\n        local startButton = self:ResolveEntityByPathPair(self.StartButtonPath, self.StartButtonFallbackPath)\n        if startButton ~= nil and isvalid(startButton) == true then\n            pcall(function()\n                startButton.Enable = isLobby\n                startButton.Visible = isLobby\n            end)\n        end\n\n        local rankingVisible = true\n        if self.HideRankingDuringGameplay == true and isLobby == false then\n            rankingVisible = false\n        end\n\n        local rankingText = self:ResolveEntityByPathPair(self.RankingTextPath, self.RankingTextFallbackPath)\n        if rankingText ~= nil and isvalid(rankingText) == true then\n            pcall(function()\n                rankingText.Enable = rankingVisible\n                rankingText.Visible = rankingVisible\n            end)\n        end\n\n        local myRankText = self:ResolveEntityByPathPair(self.MyRankTextPath, self.MyRankTextFallbackPath)\n        if myRankText ~= nil and isvalid(myRankText) == true then\n            pcall(function()\n                myRankText.Enable = rankingVisible\n                myRankText.Visible = rankingVisible\n            end)\n        end\n\n        local timerVisible = not isLobby\n        if self.HideTimerDuringLobby == true and isLobby == true then\n            timerVisible = false\n        end\n\n        local timerText = self:ResolveEntityByPathPair(self.TimerTextPath, \"\")\n        if timerText ~= nil and isvalid(timerText) == true then\n            pcall(function()\n                timerText.Enable = timerVisible\n                timerText.Visible = timerVisible\n            end)\n        end\n\n        local rankingUI = self:ResolveComponentSafe(self.Entity, \"RankingUIComponent\", nil)\n        if rankingUI ~= nil and rankingUI.ApplyVisibilityClient ~= nil then\n            pcall(function()\n                rankingUI:ApplyVisibilityClient(rankingVisible)\n            end)\n        end\n\n        local hudComponent = self:ResolveComponentSafe(self.Entity, \"HUDComponent\", nil)\n        if hudComponent ~= nil and hudComponent.ApplyLobbyStateClient ~= nil then\n            pcall(function()\n                hudComponent:ApplyLobbyStateClient(isLobby)\n            end)\n        end\n    end\n\n    -- Sync callback is main UI state trigger after server authoritative lobby flag changes.\n    @ExecSpace(\"ClientOnly\")\n    method void OnSyncProperty(string propertyName, any value)\n        if propertyName ~= \"IsLobbyActive\" then\n            return\n        end\n        self:ApplyLobbyUIClient(self:ResolveEffectiveLobbyStateClient())\n    end\n\n    -- Resolves client-side lobby state with local fallback path for startup races.\n    @ExecSpace(\"ClientOnly\")\n    method boolean ResolveEffectiveLobbyStateClient()\n        return self.IsLobbyActive\n    end\n\n    -- Binds start button once and connects click callback to server start request.\n    @ExecSpace(\"ClientOnly\")\n    method void BindStartButtonClient()\n        if self._T.StartButtonHandler ~= nil then\n            return\n        end\n\n        local startButton = self:ResolveEntityByPathPair(self.StartButtonPath, self.StartButtonFallbackPath)\n        if startButton == nil or isvalid(startButton) == false then\n            return\n        end\n\n        if startButton.ButtonComponent == nil then\n            pcall(function()\n                startButton:AddComponent(\"MOD.Core.ButtonComponent\")\n            end)\n        end\n\n        local callback = function(event)\n            self:HandleStartButtonClickClient(event)\n        end\n        self._T.StartButtonHandler = startButton:ConnectEvent(ButtonClickEvent, callback)\n    end\n\n    method Entity ResolveEntityByPathPair(string primaryPath, string fallbackPath)\n        local target = nil\n        if primaryPath ~= nil and primaryPath ~= \"\" then\n            target = _EntityService:GetEntityByPath(primaryPath)\n        end\n        if (target == nil or isvalid(target) == false) and fallbackPath ~= nil and fallbackPath ~= \"\" then\n            target = _EntityService:GetEntityByPath(fallbackPath)\n        end\n        return target\n    end\n\n    -- In-game map transition uses RoomService static-room move with target map name.\n    @ExecSpace(\"ServerOnly\")\n    method boolean MoveOwnerToInGameMapIfNeeded()\n        if self.UseMapSplit == false then\n            return true\n        end\n\n        local userId = self:GetOwnerUserId()\n        if userId == nil or userId == \"\" then\n            return false\n        end\n\n        local moveOk, moved = pcall(function()\n            return _RoomService:MoveUserToStaticRoom(userId, self.InGameMapName)\n        end)\n        if moveOk == false then\n            return false\n        end\n        return moved\n    end\n\n    -- Lobby map transition mirrors in-game move path for consistent flow behavior.\n    @ExecSpace(\"ServerOnly\")\n    method boolean MoveOwnerToLobbyMapIfNeeded()\n        if self.UseMapSplit == false then\n            return true\n        end\n\n        local userId = self:GetOwnerUserId()\n        if userId == nil or userId == \"\" then\n            return false\n        end\n\n        local moveOk, moved = pcall(function()\n            return _RoomService:MoveUserToStaticRoom(userId, self.LobbyMapName)\n        end)\n        if moveOk == false then\n            return false\n        end\n        return moved\n    end\n\n    -- Starts speedrun timer via dedicated component interface.\n    @ExecSpace(\"ServerOnly\")\n    method void StartRunTimerServer()\n        local timerComponent = self:ResolveComponentSafe(self.Entity, \"SpeedrunTimerComponent\", \"IsRunning\")\n        if timerComponent == nil then\n            return\n        end\n\n        if timerComponent.StartRunWithCountdown ~= nil then\n            pcall(function()\n                timerComponent:StartRunWithCountdown()\n            end)\n            return\n        end\n\n        if timerComponent.StartRunNow ~= nil then\n            pcall(function()\n                timerComponent:StartRunNow()\n            end)\n        end\n    end\n\n    -- Completes timer flow using available interface (CompleteRun preferred).\n    @ExecSpace(\"ServerOnly\")\n    method void CompleteRunTimerServer()\n        local timerComponent = self:ResolveComponentSafe(self.Entity, \"SpeedrunTimerComponent\", \"IsRunning\")\n        if timerComponent == nil then\n            return\n        end\n\n        if timerComponent.CompleteRun ~= nil then\n            pcall(function()\n                timerComponent:CompleteRun()\n            end)\n            return\n        end\n\n        if timerComponent.ResetRun ~= nil then\n            pcall(function()\n                timerComponent:ResetRun()\n            end)\n        end\n    end\n\n    -- Owner resolver is shared by room-move and request validation paths.\n    method string GetOwnerUserId()\n        local userId = \"\"\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent ~= nil then\n            local playerOk, playerUserId = pcall(function()\n                return playerComponent.UserId\n            end)\n            if playerOk == true and playerUserId ~= nil and playerUserId ~= \"\" then\n                userId = playerUserId\n            end\n        end\n\n        if userId ~= \"\" then\n            return userId\n        end\n\n        local localPlayer = _UserService.LocalPlayer\n        if localPlayer ~= nil and isvalid(localPlayer) == true then\n            local localOk, localUserId = pcall(function()\n                return localPlayer.PlayerComponent.UserId\n            end)\n            if localOk == true and localUserId ~= nil then\n                return localUserId\n            end\n        end\n\n        return \"\"\n    end\n\n    -- Movement lock uses shared utility path first to keep cross-component writes consistent.\n    method boolean SetCanMoveSafely(boolean canMove)\n        if _GRUtil ~= nil and _GRUtil.TrySetCanMove ~= nil then\n            return _GRUtil.TrySetCanMove(self.Entity, canMove)\n        end\n\n        local movementComponent = self:ResolveComponentSafe(self.Entity, \"MovementComponent\", \"CanMove\")\n        if movementComponent == nil then\n            return false\n        end\n\n        local ok, _ = pcall(function()\n            movementComponent.CanMove = canMove\n        end)\n        return ok\n    end\n\n    -- Attack lock mirrors movement lock strategy and gracefully handles missing fire component.\n    method boolean SetCanAttackSafely(boolean canAttack)\n        local fireComponent = self:ResolveComponentSafe(self.Entity, \"FireSystemComponent\", \"CanAttack\")\n        if fireComponent == nil then\n            return false\n        end\n\n        if _GRUtil ~= nil and _GRUtil.TrySetField ~= nil then\n            return _GRUtil.TrySetField(fireComponent, \"CanAttack\", canAttack)\n        end\n\n        local ok, _ = pcall(function()\n            fireComponent.CanAttack = canAttack\n        end)\n        return ok\n    end\n\n    -- EndPlay unbinds button event handler to avoid duplicate callbacks on re-init.\n    method void OnEndPlay()\n        local startButton = self:ResolveEntityByPathPair(self.StartButtonPath, self.StartButtonFallbackPath)\n        if startButton ~= nil and self._T.StartButtonHandler ~= nil then\n            pcall(function()\n                startButton:DisconnectEvent(ButtonClickEvent, self._T.StartButtonHandler)\n            end)\n        end\n        self._T.StartButtonHandler = nil\n    end\n\n    -- Utility bootstrap first; fallback local lookup is retained when global utility is unavailable.\n    method void EnsureGRUtil()\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, _ = pcall(function()\n                utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    method Component ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return _GRUtil.ResolveComponent(targetEntity, scriptName, markerField)\n        end\n\n        local prefixedName = scriptName\n        local plainName = scriptName\n        if string.sub(scriptName, 1, 7) == \"script.\" then\n            plainName = string.sub(scriptName, 8)\n        else\n            prefixedName = \"script.\" .. scriptName\n        end\n\n        local component = targetEntity:GetComponent(prefixedName)\n        if component == nil then\n            component = targetEntity:GetComponent(plainName)\n        end\n        if component == nil then\n            return nil\n        end\n\n        if markerField ~= nil and markerField ~= \"\" then\n            local ok, _ = pcall(function()\n                return component[markerField]\n            end)\n            if ok == false then\n                return nil\n            end\n        end\n\n        return component\n    end\n\n    method boolean IsOwnerRequest(string requestUserId)\n        if _GRUtil ~= nil and _GRUtil.IsOwner ~= nil then\n            return _GRUtil.IsOwner(self.Entity, requestUserId)\n        end\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent == nil then\n            return true\n        end\n\n        if requestUserId == nil or requestUserId == \"\" then\n            return true\n        end\n\n        return requestUserId == playerComponent.UserId\n    end\nend\n"
    }
  }
}