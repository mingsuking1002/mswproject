{
  "Id": "",
  "GameId": "",
  "EntryKey": "codeblock://b7898975-709f-4b65-b152-d45b3b4d665f",
  "ContentType": "x-mod/codeblock",
  "Content": "",
  "Usage": 0,
  "UsePublish": 1,
  "UseService": 0,
  "CoreVersion": "26.1.0.0",
  "StudioVersion": "",
  "DynamicLoading": 0,
  "ContentProto": {
    "Use": "Json",
    "Json": {
      "CoreVersion": {
        "Major": 0,
        "Minor": 2
      },
      "ScriptVersion": {
        "Major": 1,
        "Minor": 1
      },
      "Description": "",
      "Id": "b7898975-709f-4b65-b152-d45b3b4d665f",
      "Language": 1,
      "Name": "RankingComponent",
      "Type": 1,
      "Source": 1,
      "Target": "@Component\nscript RankingComponent extends Component\n\n    property number TimeAttackBestTime = -1\n    property integer InfiniteModeBestKills = 0\n\n    property integer DisplayCount = 100\n    property integer MaxRankScanCount = 2000\n    property number MinimumValidClearTime = 5.0\n    property number MaximumValidClearTime = 7200.0\n    property integer MaximumValidKills = 1000000\n\n    property string TimeAttackStorageName = \"GR_TimeAttack\"\n    property string InfiniteStorageName = \"GR_Infinite\"\n    property string TimeAttackLocalKey = \"Ranking_TimeAttackBest\"\n    property string InfiniteLocalKey = \"Ranking_InfiniteBest\"\n\n    -- Server initializes local best records from storage so result-screen comparison is deterministic.\n    @ExecSpace(\"ServerOnly\")\n    method void OnInitialize()\n        self:EnsureGRUtil()\n        self:LoadLocalBestRecordsServer()\n    end\n\n    -- Client utility bootstrap allows ranking UI requests to share the same safe component resolution logic.\n    @ExecSpace(\"ClientOnly\")\n    method void OnBeginPlay()\n        self:EnsureGRUtil()\n    end\n\n    -- TimeAttack submit validates record server-side and uploads only when local PB improves.\n    @ExecSpace(\"ServerOnly\")\n    method boolean SubmitTimeAttackRecordServer(number elapsedTime)\n        if self:IsValidTimeAttackRecord(elapsedTime) == false then\n            return false\n        end\n\n        local isNewRecord = false\n        if self.TimeAttackBestTime < 0 then\n            isNewRecord = true\n        elseif elapsedTime < self.TimeAttackBestTime then\n            isNewRecord = true\n        end\n        if isNewRecord == false then\n            return false\n        end\n\n        self.TimeAttackBestTime = elapsedTime\n        self:SaveLocalBestRecordServer(1, elapsedTime)\n        self:UploadTimeAttackRecordServer(elapsedTime)\n        return true\n    end\n\n    -- Infinite-mode submit follows same PB-only policy to reduce unnecessary storage writes.\n    @ExecSpace(\"ServerOnly\")\n    method boolean SubmitInfiniteRecordServer(integer killCount)\n        if self:IsValidInfiniteRecord(killCount) == false then\n            return false\n        end\n\n        local isNewRecord = (killCount > self.InfiniteModeBestKills)\n        if isNewRecord == false then\n            return false\n        end\n\n        self.InfiniteModeBestKills = killCount\n        self:SaveLocalBestRecordServer(2, killCount)\n        self:UploadInfiniteRecordServer(killCount)\n        return true\n    end\n\n    -- Ranking snapshot request is server-routed so top/my-rank calculations are protected from client spoofing.\n    @ExecSpace(\"Server\")\n    method void RequestRankingSnapshotServer(integer mode)\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n\n        local finalMode = self:NormalizeMode(mode)\n        local topRanks = self:GetTopRanksServer(finalMode, self.DisplayCount)\n        local myRank = self:GetMyRankServer(finalMode)\n        self:ReceiveRankingSnapshotClient(finalMode, topRanks, myRank)\n    end\n\n    -- Client snapshot receiver caches latest ranking payload for UI components.\n    @ExecSpace(\"Client\")\n    method void ReceiveRankingSnapshotClient(integer mode, table topRanks, table myRank)\n        self._T.LastSnapshotMode = mode\n        self._T.LastTopRanks = topRanks\n        self._T.LastMyRank = myRank\n    end\n\n    -- Returns top-N ranking rows from sortable storage using mode-specific sort direction.\n    @ExecSpace(\"ServerOnly\")\n    method table GetTopRanksServer(integer mode, integer count)\n        local finalMode = self:NormalizeMode(mode)\n        local displayCount = math.max(1, math.floor(count))\n        local storage = self:GetSortableStorageByMode(finalMode)\n        local rows = {}\n        if storage == nil then\n            return rows\n        end\n\n        local sortDirection = SortDirection.Ascending\n        if finalMode == 2 then\n            sortDirection = SortDirection.Descending\n        end\n\n        local readOk, errorCode, pages = pcall(function()\n            return storage:GetSortedAndWait(sortDirection, 0, displayCount - 1)\n        end)\n        if readOk == false or errorCode ~= 0 or pages == nil then\n            return rows\n        end\n\n        local rankIndex = 0\n        while true do\n            local pageItems = pages:GetCurrentPageDatas()\n            if pageItems ~= nil then\n                for _, item in pairs(pageItems) do\n                    rankIndex += 1\n                    local userId = item.KeyInfo.Key\n                    local score = item.Value\n\n                    local row = {}\n                    row.Mode = finalMode\n                    row.Rank = rankIndex\n                    row.UserId = userId\n                    row.Nickname = self:ResolveNicknameByUserId(userId)\n                    row.Score = score\n                    row.DisplayValue = self:FormatScoreForDisplay(finalMode, score)\n                    table.insert(rows, row)\n\n                    if #rows >= displayCount then\n                        return rows\n                    end\n                end\n            end\n\n            if pages.IsLastPage == true then\n                break\n            end\n\n            local loadOk, loadCode = pcall(function()\n                return pages:LoadNextPageAndWait()\n            end)\n            if loadOk == false or loadCode ~= 0 then\n                break\n            end\n            pages:MoveToNextPageAndWait()\n        end\n\n        return rows\n    end\n\n    -- My-rank lookup scans sorted pages safely with upper bound to avoid heavy loops on large boards.\n    @ExecSpace(\"ServerOnly\")\n    method table GetMyRankServer(integer mode)\n        local finalMode = self:NormalizeMode(mode)\n        local userId = self:GetOwnerUserId()\n        local result = {}\n        result.Mode = finalMode\n        result.Rank = -1\n        result.UserId = userId\n        result.Nickname = self:ResolveNicknameByUserId(userId)\n        result.Score = 0\n        result.DisplayValue = \"-\"\n\n        if userId == nil or userId == \"\" then\n            return result\n        end\n\n        local storage = self:GetSortableStorageByMode(finalMode)\n        if storage == nil then\n            return result\n        end\n\n        local sortDirection = SortDirection.Ascending\n        if finalMode == 2 then\n            sortDirection = SortDirection.Descending\n        end\n\n        local readOk, errorCode, pages = pcall(function()\n            return storage:GetSortedAndWait(sortDirection, 0, math.max(self.DisplayCount, 100) - 1)\n        end)\n        if readOk == false or errorCode ~= 0 or pages == nil then\n            return result\n        end\n\n        local rankIndex = 0\n        local maxScan = math.max(self.MaxRankScanCount, self.DisplayCount)\n\n        while true do\n            local pageItems = pages:GetCurrentPageDatas()\n            if pageItems ~= nil then\n                for _, item in pairs(pageItems) do\n                    rankIndex += 1\n                    if item.KeyInfo.Key == userId then\n                        result.Rank = rankIndex\n                        result.Score = item.Value\n                        result.DisplayValue = self:FormatScoreForDisplay(finalMode, item.Value)\n                        return result\n                    end\n\n                    if rankIndex >= maxScan then\n                        return result\n                    end\n                end\n            end\n\n            if pages.IsLastPage == true then\n                break\n            end\n\n            local loadOk, loadCode = pcall(function()\n                return pages:LoadNextPageAndWait()\n            end)\n            if loadOk == false or loadCode ~= 0 then\n                break\n            end\n            pages:MoveToNextPageAndWait()\n        end\n\n        local getOk, getCode, myScore = pcall(function()\n            return storage:GetAndWait(userId)\n        end)\n        if getOk == true and getCode == 0 then\n            result.Score = myScore\n            result.DisplayValue = self:FormatScoreForDisplay(finalMode, myScore)\n        end\n\n        return result\n    end\n\n    -- Loads local PB from UserDataStorage to preserve per-user ranking baseline.\n    @ExecSpace(\"ServerOnly\")\n    method void LoadLocalBestRecordsServer()\n        local userId = self:GetOwnerUserId()\n        if userId == nil or userId == \"\" then\n            return\n        end\n\n        local userStorage = _DataStorageService:GetUserDataStorage(userId)\n        if userStorage == nil then\n            return\n        end\n\n        local timeOk, timeCode, timeValue = pcall(function()\n            return userStorage:GetAndWait(self.TimeAttackLocalKey)\n        end)\n        if timeOk == true and timeCode == 0 and timeValue ~= nil and timeValue ~= \"\" then\n            local parsed = tonumber(timeValue)\n            if parsed ~= nil then\n                self.TimeAttackBestTime = parsed\n            end\n        end\n\n        local killOk, killCode, killValue = pcall(function()\n            return userStorage:GetAndWait(self.InfiniteLocalKey)\n        end)\n        if killOk == true and killCode == 0 and killValue ~= nil and killValue ~= \"\" then\n            local parsedKill = tonumber(killValue)\n            if parsedKill ~= nil then\n                self.InfiniteModeBestKills = math.max(0, math.floor(parsedKill))\n            end\n        end\n    end\n\n    -- Saves PB locally only after record update to minimize storage writes.\n    @ExecSpace(\"ServerOnly\")\n    method void SaveLocalBestRecordServer(integer mode, number value)\n        local userId = self:GetOwnerUserId()\n        if userId == nil or userId == \"\" then\n            return\n        end\n\n        local userStorage = _DataStorageService:GetUserDataStorage(userId)\n        if userStorage == nil then\n            return\n        end\n\n        local finalMode = self:NormalizeMode(mode)\n        if finalMode == 1 then\n            pcall(function()\n                userStorage:SetAndWait(self.TimeAttackLocalKey, tostring(value))\n            end)\n            return\n        end\n\n        pcall(function()\n            userStorage:SetAndWait(self.InfiniteLocalKey, tostring(math.floor(value)))\n        end)\n    end\n\n    -- TimeAttack upload stores milliseconds so ascending sort yields faster-time-first ranking.\n    @ExecSpace(\"ServerOnly\")\n    method void UploadTimeAttackRecordServer(number elapsedTime)\n        local storage = self:GetSortableStorageByMode(1)\n        if storage == nil then\n            return\n        end\n\n        local userId = self:GetOwnerUserId()\n        if userId == nil or userId == \"\" then\n            return\n        end\n\n        local milliSeconds = math.max(1, math.floor(elapsedTime * 1000))\n        pcall(function()\n            storage:SetAndWait(userId, milliSeconds)\n        end)\n    end\n\n    -- Infinite upload stores kill count directly so descending sort yields higher-kill-first ranking.\n    @ExecSpace(\"ServerOnly\")\n    method void UploadInfiniteRecordServer(integer killCount)\n        local storage = self:GetSortableStorageByMode(2)\n        if storage == nil then\n            return\n        end\n\n        local userId = self:GetOwnerUserId()\n        if userId == nil or userId == \"\" then\n            return\n        end\n\n        local clampedKill = math.max(0, math.floor(killCount))\n        pcall(function()\n            storage:SetAndWait(userId, clampedKill)\n        end)\n    end\n\n    method SortableDataStorage GetSortableStorageByMode(integer mode)\n        local finalMode = self:NormalizeMode(mode)\n        if finalMode == 1 then\n            return _DataStorageService:GetSortableDataStorage(self.TimeAttackStorageName)\n        end\n        return _DataStorageService:GetSortableDataStorage(self.InfiniteStorageName)\n    end\n\n    method boolean IsValidTimeAttackRecord(number elapsedTime)\n        if elapsedTime < self.MinimumValidClearTime then\n            return false\n        end\n        if elapsedTime > self.MaximumValidClearTime then\n            return false\n        end\n        return true\n    end\n\n    method boolean IsValidInfiniteRecord(integer killCount)\n        if killCount < 0 then\n            return false\n        end\n        if killCount > self.MaximumValidKills then\n            return false\n        end\n        return true\n    end\n\n    method integer NormalizeMode(integer mode)\n        if math.floor(mode) == 2 then\n            return 2\n        end\n        return 1\n    end\n\n    -- Converts stored integer score to mode-specific UI text format.\n    method string FormatScoreForDisplay(integer mode, integer scoreValue)\n        local finalMode = self:NormalizeMode(mode)\n        if finalMode == 1 then\n            local total = math.max(0, scoreValue)\n            local minute = math.floor(total / 60000)\n            local second = math.floor((total % 60000) / 1000)\n            local centisecond = math.floor((total % 1000) / 10)\n            return string.format(\"%02d:%02d.%02d\", minute, second, centisecond)\n        end\n\n        return tostring(math.max(0, scoreValue))\n    end\n\n    -- Nickname resolver prefers user service cache and falls back to userId for offline entries.\n    method string ResolveNicknameByUserId(string userId)\n        if userId == nil or userId == \"\" then\n            return \"Unknown\"\n        end\n\n        local users = _UserService.Users\n        if users ~= nil then\n            local userOk, userInfo = pcall(function()\n                return users[userId]\n            end)\n            if userOk == true and userInfo ~= nil then\n                local nickOk, nick = pcall(function()\n                    return userInfo.Nickname\n                end)\n                if nickOk == true and nick ~= nil and nick ~= \"\" then\n                    return nick\n                end\n            end\n        end\n\n        return userId\n    end\n\n    -- User id resolver is shared by ranking storage and local PB storage paths.\n    method string GetOwnerUserId()\n        local userId = \"\"\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent ~= nil then\n            local playerOk, playerUserId = pcall(function()\n                return playerComponent.UserId\n            end)\n            if playerOk == true and playerUserId ~= nil and playerUserId ~= \"\" then\n                userId = playerUserId\n            end\n        end\n\n        if userId ~= \"\" then\n            return userId\n        end\n\n        local localPlayer = _UserService.LocalPlayer\n        if localPlayer ~= nil and isvalid(localPlayer) == true then\n            local localOk, localUserId = pcall(function()\n                return localPlayer.PlayerComponent.UserId\n            end)\n            if localOk == true and localUserId ~= nil then\n                return localUserId\n            end\n        end\n\n        return \"\"\n    end\n\n    -- Utility bootstrap first; fallback local lookup is retained if global utility registration fails.\n    method void EnsureGRUtil()\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, _ = pcall(function()\n                utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    method Component ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return _GRUtil.ResolveComponent(targetEntity, scriptName, markerField)\n        end\n\n        local prefixedName = scriptName\n        local plainName = scriptName\n        if string.sub(scriptName, 1, 7) == \"script.\" then\n            plainName = string.sub(scriptName, 8)\n        else\n            prefixedName = \"script.\" .. scriptName\n        end\n\n        local component = targetEntity:GetComponent(prefixedName)\n        if component == nil then\n            component = targetEntity:GetComponent(plainName)\n        end\n        if component == nil then\n            return nil\n        end\n\n        if markerField ~= nil and markerField ~= \"\" then\n            local ok, _ = pcall(function()\n                return component[markerField]\n            end)\n            if ok == false then\n                return nil\n            end\n        end\n\n        return component\n    end\n\n    method boolean IsOwnerRequest(string requestUserId)\n        if _GRUtil ~= nil and _GRUtil.IsOwner ~= nil then\n            return _GRUtil.IsOwner(self.Entity, requestUserId)\n        end\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent == nil then\n            return true\n        end\n\n        if requestUserId == nil or requestUserId == \"\" then\n            return true\n        end\n\n        return requestUserId == playerComponent.UserId\n    end\nend\n"
    }
  }
}