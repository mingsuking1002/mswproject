{
  "Id": "",
  "GameId": "",
  "EntryKey": "codeblock://59bf4b8b-0c79-4c0f-b167-96f5de3761e1",
  "ContentType": "x-mod/codeblock",
  "Content": "",
  "Usage": 0,
  "UsePublish": 1,
  "UseService": 0,
  "CoreVersion": "26.1.0.0",
  "StudioVersion": "",
  "DynamicLoading": 0,
  "ContentProto": {
    "Use": "Json",
    "Json": {
      "CoreVersion": {
        "Major": 0,
        "Minor": 2
      },
      "ScriptVersion": {
        "Major": 1,
        "Minor": 1
      },
      "Description": "",
      "Id": "59bf4b8b-0c79-4c0f-b167-96f5de3761e1",
      "Language": 1,
      "Name": "MovementComponent",
      "Type": 1,
      "Source": 1,
      "Target": "@Component\nscript MovementComponent extends Component\n\n    @Sync\n    property number SpeedMultiplier = 1.0\n    @Sync\n    property boolean CanMove = true\n    @Sync\n    property integer FacingDirection = 1\n\n    property number MoveSpeed = 1.0\n\n    -- Server initializes authoritative input cache so movement always has a deterministic source.\n    @ExecSpace(\"ServerOnly\")\n    method void OnInitialize()\n        self._T.ServerInputDirection = Vector2.zero\n        self:EnsureGRUtil()\n    end\n\n    -- Client bootstraps GR utility first to keep ownership checks and component lookup behavior consistent.\n    @ExecSpace(\"ClientOnly\")\n    method void OnBeginPlay()\n        self:EnsureGRUtil()\n    end\n\n    -- Every movement key transition is sampled client-side and sent to server as intent only.\n    @EventSender(\"Service\", \"InputService\")\n    handler HandleKeyDownEvent(KeyDownEvent event)\n        local key = event.key\n        if self:IsMovementKey(key) == false then\n            return\n        end\n\n        self:SubmitMoveInput(self:GetMoveInputClient())\n    end\n\n    -- Key release is processed through the same path to keep stuck-key state from persisting.\n    @EventSender(\"Service\", \"InputService\")\n    handler HandleKeyUpEvent(KeyUpEvent event)\n        local key = event.key\n        if self:IsMovementKey(key) == false then\n            return\n        end\n\n        self:SubmitMoveInput(self:GetMoveInputClient())\n    end\n\n    -- Server is the only place that applies final movement so modified clients cannot move directly.\n    @ExecSpace(\"ServerOnly\")\n    method void OnUpdate(number delta)\n        local moveDirection = self._T.ServerInputDirection\n        if self.CanMove == false then\n            moveDirection = Vector2.zero\n        end\n\n        local finalSpeed = self.MoveSpeed * self.SpeedMultiplier\n        if finalSpeed \u003c 0 then\n            finalSpeed = 0\n        end\n\n        self:ApplyMovementServer(moveDirection, finalSpeed, delta)\n        self:UpdateFacingDirection(moveDirection)\n        self:UpdateStateAnimation(moveDirection)\n    end\n\n    method boolean IsMovementKey(KeyboardKey key)\n        if key == KeyboardKey.W then\n            return true\n        end\n        if key == KeyboardKey.A then\n            return true\n        end\n        if key == KeyboardKey.S then\n            return true\n        end\n        if key == KeyboardKey.D then\n            return true\n        end\n\n        return false\n    end\n\n    -- Server-side ownership validation prevents other clients from pushing movement for this entity.\n    @ExecSpace(\"Server\")\n    method void SubmitMoveInput(Vector2 moveDirection)\n        if moveDirection == nil then\n            return\n        end\n        if self.Entity == nil or isvalid(self.Entity) == false then\n            return\n        end\n\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n\n        self._T.ServerInputDirection = self:ClampInputDirection(moveDirection)\n    end\n\n    -- Client reads current WASD state to reduce server polling cost.\n    @ExecSpace(\"ClientOnly\")\n    method Vector2 GetMoveInputClient()\n        if self.CanMove == false then\n            return Vector2.zero\n        end\n\n        local x = 0\n        local y = 0\n\n        local upPressed = _InputService:IsKeyPressed(KeyboardKey.W)\n        local downPressed = _InputService:IsKeyPressed(KeyboardKey.S)\n        local leftPressed = _InputService:IsKeyPressed(KeyboardKey.A)\n        local rightPressed = _InputService:IsKeyPressed(KeyboardKey.D)\n\n        if upPressed == true and downPressed == false then\n            y = 1\n        elseif downPressed == true and upPressed == false then\n            y = -1\n        end\n\n        if rightPressed == true and leftPressed == false then\n            x = 1\n        elseif leftPressed == true and rightPressed == false then\n            x = -1\n        end\n\n        local direction = Vector2(x, y)\n        return self:ClampInputDirection(direction)\n    end\n\n    -- Input direction is normalized to apply diagonal speed correction.\n    method Vector2 ClampInputDirection(Vector2 inputDirection)\n        if inputDirection == nil then\n            return Vector2.zero\n        end\n\n        local sqrMagnitude = inputDirection:SqrMagnitude()\n        if sqrMagnitude \u003c= 0 then\n            return Vector2.zero\n        end\n\n        return inputDirection:Normalize()\n    end\n\n    -- Rigidbody is preferred for wall-slide behavior, with transform fallback for non-rigidbody entities.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyMovementServer(Vector2 moveDirection, number speed, number delta)\n        local rigidbody = self.Entity.RigidbodyComponent\n        if rigidbody ~= nil and isvalid(rigidbody) == true then\n            rigidbody.MoveVelocity = moveDirection * speed\n            return\n        end\n\n        local transform = self.Entity.TransformComponent\n        if transform == nil or isvalid(transform) == false then\n            return\n        end\n\n        local deltaX = moveDirection.x * speed * delta\n        local deltaY = moveDirection.y * speed * delta\n        transform:Translate(deltaX, deltaY)\n    end\n\n    -- Facing direction is synchronized from server to keep sprite orientation consistent across clients.\n    @ExecSpace(\"ServerOnly\")\n    method void UpdateFacingDirection(Vector2 moveDirection)\n        if moveDirection == nil then\n            return\n        end\n        if moveDirection:SqrMagnitude() \u003c= 0 then\n            return\n        end\n\n        local direction = self:ComputeFacingDirection(moveDirection)\n        if direction ~= self.FacingDirection then\n            self.FacingDirection = direction\n        end\n    end\n\n    method integer ComputeFacingDirection(Vector2 direction)\n        local angle = math.deg(math.atan(direction.y, direction.x))\n        if angle \u003c 0 then\n            angle = angle + 360\n        end\n\n        -- 8-direction index (1~8): right, up-right, up, up-left, left, down-left, down, down-right.\n        if angle \u003e= 337.5 or angle \u003c 22.5 then\n            return 1\n        elseif angle \u003c 67.5 then\n            return 2\n        elseif angle \u003c 112.5 then\n            return 3\n        elseif angle \u003c 157.5 then\n            return 4\n        elseif angle \u003c 202.5 then\n            return 5\n        elseif angle \u003c 247.5 then\n            return 6\n        elseif angle \u003c 292.5 then\n            return 7\n        else\n            return 8\n        end\n    end\n\n    -- State updates are server-authoritative to avoid divergent animation states per client.\n    @ExecSpace(\"ServerOnly\")\n    method void UpdateStateAnimation(Vector2 moveDirection)\n        local stateComponent = self:ResolveComponentSafe(self.Entity, \"StateComponent\", \"CurrentStateName\")\n        if stateComponent == nil then\n            return\n        end\n\n        if moveDirection ~= nil and moveDirection:SqrMagnitude() \u003e 0 then\n            if stateComponent.CurrentStateName ~= \"MOVE\" then\n                stateComponent:ChangeState(\"MOVE\")\n            end\n            return\n        end\n\n        if stateComponent.CurrentStateName ~= \"IDLE\" then\n            stateComponent:ChangeState(\"IDLE\")\n        end\n    end\n\n    -- Stops velocity explicitly on end play so recycled entities do not keep stale movement.\n    @ExecSpace(\"ServerOnly\")\n    method void OnEndPlay()\n        local rigidbody = self.Entity.RigidbodyComponent\n        if rigidbody ~= nil and isvalid(rigidbody) == true then\n            rigidbody.MoveVelocity = Vector2.zero\n        end\n    end\n\n    -- Tries to boot GR utility component first; if unavailable, downstream methods use direct safe fallback.\n    method void EnsureGRUtil()\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, _ = pcall(function()\n                utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    method Component ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return _GRUtil.ResolveComponent(targetEntity, scriptName, markerField)\n        end\n\n        local prefixedName = scriptName\n        local plainName = scriptName\n        if string.sub(scriptName, 1, 7) == \"script.\" then\n            plainName = string.sub(scriptName, 8)\n        else\n            prefixedName = \"script.\" .. scriptName\n        end\n\n        local component = targetEntity:GetComponent(prefixedName)\n        if component == nil then\n            component = targetEntity:GetComponent(plainName)\n        end\n        if component == nil then\n            return nil\n        end\n\n        if markerField ~= nil and markerField ~= \"\" then\n            local ok, _ = pcall(function()\n                return component[markerField]\n            end)\n            if ok == false then\n                return nil\n            end\n        end\n\n        return component\n    end\n\n    method boolean IsOwnerRequest(string requestUserId)\n        if _GRUtil ~= nil and _GRUtil.IsOwner ~= nil then\n            return _GRUtil.IsOwner(self.Entity, requestUserId)\n        end\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent == nil then\n            return true\n        end\n\n        if requestUserId == nil or requestUserId == \"\" then\n            return true\n        end\n\n        return requestUserId == playerComponent.UserId\n    end\nend\n"ServerOnly\")\n    method void OnInitialize()\n        self._T.ServerInputDirection = Vector2.zero\n        self:EnsureGRUtil()\n    end\n\n    -- Client bootstraps GR utility first to keep ownership checks and component lookup behavior consistent.\n    @ExecSpace(\"ClientOnly\")\n    method void OnBeginPlay()\n        self:EnsureGRUtil()\n    end\n\n    -- Every movement key transition is sampled client-side and sent to server as intent only.\n    @EventSender(\"Service\", \"InputService\")\n    handler HandleKeyDownEvent(KeyDownEvent event)\n        local key = event.key\n        if self:IsMovementKey(key) == false then\n            return\n        end\n\n        self:SubmitMoveInput(self:GetMoveInputClient())\n    end\n\n    -- Key release is processed through the same path to keep stuck-key state from persisting.\n    @EventSender(\"Service\", \"InputService\")\n    handler HandleKeyUpEvent(KeyUpEvent event)\n        local key = event.key\n        if self:IsMovementKey(key) == false then\n            return\n        end\n\n        self:SubmitMoveInput(self:GetMoveInputClient())\n    end\n\n    -- Server is the only place that applies final movement so modified clients cannot move directly.\n    @ExecSpace(\"ServerOnly\")\n    method void OnUpdate(number delta)\n        local moveDirection = self._T.ServerInputDirection\n        if self.CanMove == false then\n            moveDirection = Vector2.zero\n        end\n\n        local finalSpeed = self.MoveSpeed * self.SpeedMultiplier\n        if finalSpeed < 0 then\n            finalSpeed = 0\n        end\n\n        self:ApplyMovementServer(moveDirection, finalSpeed, delta)\n        self:UpdateFacingDirection(moveDirection)\n        self:UpdateStateAnimation(moveDirection)\n    end\n\n    method boolean IsMovementKey(KeyboardKey key)\n        if key == KeyboardKey.W then\n            return true\n        end\n        if key == KeyboardKey.A then\n            return true\n        end\n        if key == KeyboardKey.S then\n            return true\n        end\n        if key == KeyboardKey.D then\n            return true\n        end\n\n        return false\n    end\n\n    -- Server-side ownership validation prevents other clients from pushing movement for this entity.\n    @ExecSpace(\"Server\")\n    method void SubmitMoveInput(Vector2 moveDirection)\n        if moveDirection == nil then\n            return\n        end\n        if self.Entity == nil or isvalid(self.Entity) == false then\n            return\n        end\n\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n\n        self._T.ServerInputDirection = self:ClampInputDirection(moveDirection)\n    end\n\n    -- Client reads current WASD state to reduce server polling cost.\n    @ExecSpace(\"ClientOnly\")\n    method Vector2 GetMoveInputClient()\n        if self.CanMove == false then\n            return Vector2.zero\n        end\n\n        local x = 0\n        local y = 0\n\n        local upPressed = _InputService:IsKeyPressed(KeyboardKey.W)\n        local downPressed = _InputService:IsKeyPressed(KeyboardKey.S)\n        local leftPressed = _InputService:IsKeyPressed(KeyboardKey.A)\n        local rightPressed = _InputService:IsKeyPressed(KeyboardKey.D)\n\n        if upPressed == true and downPressed == false then\n            y = 1\n        elseif downPressed == true and upPressed == false then\n            y = -1\n        end\n\n        if rightPressed == true and leftPressed == false then\n            x = 1\n        elseif leftPressed == true and rightPressed == false then\n            x = -1\n        end\n\n        local direction = Vector2(x, y)\n        return self:ClampInputDirection(direction)\n    end\n\n    -- Input direction is normalized to apply diagonal speed correction.\n    method Vector2 ClampInputDirection(Vector2 inputDirection)\n        if inputDirection == nil then\n            return Vector2.zero\n        end\n\n        local sqrMagnitude = inputDirection:SqrMagnitude()\n        if sqrMagnitude <= 0 then\n            return Vector2.zero\n        end\n\n        return inputDirection:Normalize()\n    end\n\n    -- Rigidbody is preferred for wall-slide behavior, with transform fallback for non-rigidbody entities.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyMovementServer(Vector2 moveDirection, number speed, number delta)\n        local rigidbody = self.Entity.RigidbodyComponent\n        if rigidbody ~= nil and isvalid(rigidbody) == true then\n            rigidbody.MoveVelocity = moveDirection * speed\n            return\n        end\n\n        local transform = self.Entity.TransformComponent\n        if transform == nil or isvalid(transform) == false then\n            return\n        end\n\n        local deltaX = moveDirection.x * speed * delta\n        local deltaY = moveDirection.y * speed * delta\n        transform:Translate(deltaX, deltaY)\n    end\n\n    -- Facing direction is synchronized from server to keep sprite orientation consistent across clients.\n    @ExecSpace(\"ServerOnly\")\n    method void UpdateFacingDirection(Vector2 moveDirection)\n        if moveDirection == nil then\n            return\n        end\n        if moveDirection:SqrMagnitude() <= 0 then\n            return\n        end\n\n        local direction = self:ComputeFacingDirection(moveDirection)\n        if direction ~= self.FacingDirection then\n            self.FacingDirection = direction\n        end\n    end\n\n    method integer ComputeFacingDirection(Vector2 direction)\n        local angle = math.deg(math.atan(direction.y, direction.x))\n        if angle < 0 then\n            angle = angle + 360\n        end\n\n        -- 8-direction index (1~8): right, up-right, up, up-left, left, down-left, down, down-right.\n        if angle >= 337.5 or angle < 22.5 then\n            return 1\n        elseif angle < 67.5 then\n            return 2\n        elseif angle < 112.5 then\n            return 3\n        elseif angle < 157.5 then\n            return 4\n        elseif angle < 202.5 then\n            return 5\n        elseif angle < 247.5 then\n            return 6\n        elseif angle < 292.5 then\n            return 7\n        else\n            return 8\n        end\n    end\n\n    -- State updates are server-authoritative to avoid divergent animation states per client.\n    @ExecSpace(\"ServerOnly\")\n    method void UpdateStateAnimation(Vector2 moveDirection)\n        local stateComponent = self:ResolveComponentSafe(self.Entity, \"StateComponent\", \"CurrentStateName\")\n        if stateComponent == nil then\n            return\n        end\n\n        if moveDirection ~= nil and moveDirection:SqrMagnitude() > 0 then\n            if stateComponent.CurrentStateName ~= \"MOVE\" then\n                stateComponent:ChangeState(\"MOVE\")\n            end\n            return\n        end\n\n        if stateComponent.CurrentStateName ~= \"IDLE\" then\n            stateComponent:ChangeState(\"IDLE\")\n        end\n    end\n\n    -- Stops velocity explicitly on end play so recycled entities do not keep stale movement.\n    @ExecSpace(\"ServerOnly\")\n    method void OnEndPlay()\n        local rigidbody = self.Entity.RigidbodyComponent\n        if rigidbody ~= nil and isvalid(rigidbody) == true then\n            rigidbody.MoveVelocity = Vector2.zero\n        end\n    end\n\n    -- Tries to boot GR utility component first; if unavailable, downstream methods use direct safe fallback.\n    method void EnsureGRUtil()\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, _ = pcall(function()\n                utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    method Component ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return _GRUtil.ResolveComponent(targetEntity, scriptName, markerField)\n        end\n\n        local prefixedName = scriptName\n        local plainName = scriptName\n        if string.sub(scriptName, 1, 7) == \"script.\" then\n            plainName = string.sub(scriptName, 8)\n        else\n            prefixedName = \"script.\" .. scriptName\n        end\n\n        local component = targetEntity:GetComponent(prefixedName)\n        if component == nil then\n            component = targetEntity:GetComponent(plainName)\n        end\n        if component == nil then\n            return nil\n        end\n\n        if markerField ~= nil and markerField ~= \"\" then\n            local ok, _ = pcall(function()\n                return component[markerField]\n            end)\n            if ok == false then\n                return nil\n            end\n        end\n\n        return component\n    end\n\n    method boolean IsOwnerRequest(string requestUserId)\n        if _GRUtil ~= nil and _GRUtil.IsOwner ~= nil then\n            return _GRUtil.IsOwner(self.Entity, requestUserId)\n        end\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent == nil then\n            return true\n        end\n\n        if requestUserId == nil or requestUserId == \"\" then\n            return true\n        end\n\n        return requestUserId == playerComponent.UserId\n    end\nend\n"
    }
  }
}
