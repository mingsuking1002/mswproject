{
  "Id": "",
  "GameId": "",
  "EntryKey": "codeblock://95c1fdd5-e1d3-40ac-bf9c-eb46a62c59c5",
  "ContentType": "x-mod/codeblock",
  "Content": "",
  "Usage": 0,
  "UsePublish": 1,
  "UseService": 0,
  "CoreVersion": "26.1.0.0",
  "StudioVersion": "",
  "DynamicLoading": 0,
  "ContentProto": {
    "Use": "Json",
    "Json": {
      "CoreVersion": {
        "Major": 0,
        "Minor": 2
      },
      "ScriptVersion": {
        "Major": 1,
        "Minor": 1
      },
      "Description": "",
      "Id": "95c1fdd5-e1d3-40ac-bf9c-eb46a62c59c5",
      "Language": 1,
      "Name": "ShopManagerComponent",
      "Type": 1,
      "Source": 1,
      "Target": "@Component\nscript ShopManagerComponent extends Component\n\n    @Sync\n    property boolean IsShopOpen = false\n    @Sync\n    property integer ActiveShopIndex = 0\n\n    property number InteractionRange = 5\n    property Entity ShopEntity1 = nil\n    property Entity ShopEntity2 = nil\n    property Entity ShopEntity3 = nil\n    property Entity ShopEntity4 = nil\n\n    property string ShopDataTableName = \"ShopItemData\"\n    property number HealPercent = 30\n    property integer HealPrice = 100\n    property integer AmmoPrice = 50\n    property integer PassivePrice = 200\n\n    @Sync\n    property string Slot1Type = \"\"\n    @Sync\n    property string Slot1Name = \"\"\n    @Sync\n    property string Slot1Description = \"\"\n    @Sync\n    property integer Slot1Price = 0\n    @Sync\n    property boolean Slot1SoldOut = true\n\n    @Sync\n    property string Slot2Type = \"\"\n    @Sync\n    property string Slot2Name = \"\"\n    @Sync\n    property string Slot2Description = \"\"\n    @Sync\n    property integer Slot2Price = 0\n    @Sync\n    property boolean Slot2SoldOut = true\n\n    @Sync\n    property string Slot3Type = \"\"\n    @Sync\n    property string Slot3Name = \"\"\n    @Sync\n    property string Slot3Description = \"\"\n    @Sync\n    property integer Slot3Price = 0\n    @Sync\n    property boolean Slot3SoldOut = true\n\n    -- Server bootstraps utility and runtime caches so shop state is deterministic from first frame.\n    @ExecSpace(\"ServerOnly\")\n    method void OnInitialize()\n        self:EnsureGRUtil()\n        self._T.CurrentSlots = {}\n        self._T.ShopDataTable = nil\n        self._T.ShopRows = {}\n    end\n\n    -- Initial begin-play prepares data, resolves map entities, and activates one random shop.\n    @ExecSpace(\"ServerOnly\")\n    method void OnBeginPlay()\n        self:LoadShopDataServer()\n        self:ResolveShopEntitiesServer()\n        self:InitializeShopsServer()\n    end\n\n    -- Map re-entry re-resolves references because map transitions can invalidate entity handles.\n    @ExecSpace(\"ServerOnly\")\n    method void OnMapEnter(Entity enteredMap)\n        self:ResolveShopEntitiesServer()\n\n        if self.IsShopOpen == true then\n            self:SetShopEnabledByIndexServer(self.ActiveShopIndex, true)\n            return\n        end\n\n        local activeShop = self:GetShopEntityByIndex(self.ActiveShopIndex)\n        if activeShop == nil or isvalid(activeShop) == false then\n            self:InitializeShopsServer()\n            return\n        end\n\n        self:DisableAllShopsServer()\n        self:SetShopEnabledByIndexServer(self.ActiveShopIndex, true)\n    end\n\n    -- Client input only requests authoritative server actions; all validation remains server-side.\n    @EventSender(\"Service\", \"InputService\")\n    handler HandleKeyDownEvent(KeyDownEvent event)\n        if event == nil then\n            return\n        end\n\n        local key = event.key\n        if key == KeyboardKey.F then\n            if self.IsShopOpen == true then\n                return\n            end\n\n            self:RequestOpenShopServer()\n            return\n        end\n\n        if key == KeyboardKey.Escape then\n            if self.IsShopOpen == false then\n                return\n            end\n\n            self:RequestCloseShopServer()\n        end\n    end\n\n    -- Open request entry is server-authoritative to block spoofed client interaction attempts.\n    @ExecSpace(\"Server\")\n    method void RequestOpenShopServer()\n        if self:CanOpenShopForOwnerServer(senderUserId) == false then\n            return\n        end\n\n        self:OpenShopServer()\n    end\n\n    -- Public open gate is shared by WeaponSwap conflict guard to prioritize shop interaction near shop.\n    @ExecSpace(\"ServerOnly\")\n    method boolean CanOpenShopForOwnerServer(string requestUserId)\n        if self:IsOwnerRequest(requestUserId) == false then\n            return false\n        end\n        if self.IsShopOpen == true then\n            return false\n        end\n        if self.ActiveShopIndex <= 0 then\n            return false\n        end\n\n        local activeShop = self:GetShopEntityByIndex(self.ActiveShopIndex)\n        if activeShop == nil or isvalid(activeShop) == false then\n            return false\n        end\n\n        return self:IsWithinInteractionRangeServer(activeShop)\n    end\n\n    -- Purchase requests stay server-side so currency and reward effects cannot be forged by clients.\n    @ExecSpace(\"Server\")\n    method void RequestPurchaseServer(integer slotIndex)\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n        if self.IsShopOpen == false then\n            return\n        end\n\n        if self:IsValidSlotIndex(slotIndex) == false then\n            return\n        end\n\n        local finalSlotIndex = math.floor(slotIndex)\n        local slotData = self:GetSlotDataServer(finalSlotIndex)\n        if slotData == nil then\n            return\n        end\n        if slotData.IsSoldOut == true then\n            return\n        end\n\n        local price = math.max(0, math.floor(slotData.Price))\n        local goldComponent = self:ResolveComponentSafe(self.Entity, \"GoldComponent\", \"CurrentGold\")\n        if goldComponent == nil then\n            return\n        end\n\n        if goldComponent.CanAfford ~= nil then\n            local affordOk, canAfford = pcall(function()\n                return goldComponent:CanAfford(price)\n            end)\n            if affordOk == false or canAfford ~= true then\n                return\n            end\n        else\n            local currentGold = 0\n            local readOk, _ = pcall(function()\n                currentGold = goldComponent.CurrentGold\n            end)\n            if readOk == false or currentGold < price then\n                return\n            end\n        end\n\n        local spendOk, spendResult = pcall(function()\n            return goldComponent:SpendGold(price)\n        end)\n        if spendOk == false or spendResult ~= true then\n            return\n        end\n\n        self:ApplyPurchaseEffectServer(slotData.Type, slotData)\n\n        slotData.Type = \"soldout\"\n        slotData.Name = \"품절\"\n        slotData.Description = \"이미 구매 완료\"\n        slotData.Price = 0\n        slotData.IsSoldOut = true\n        self:SetSlotDataServer(finalSlotIndex, slotData)\n    end\n\n    -- Close requests are also server-authoritative to guarantee correct rotation and unlock sequence.\n    @ExecSpace(\"Server\")\n    method void RequestCloseShopServer()\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n        if self.IsShopOpen == false then\n            return\n        end\n\n        self:CloseAndRotateShopServer()\n    end\n\n    -- Open flow sets gameplay lock first, then builds sync slot payload for client UI rendering.\n    @ExecSpace(\"ServerOnly\")\n    method void OpenShopServer()\n        if self.IsShopOpen == true then\n            return\n        end\n\n        local activeShop = self:GetShopEntityByIndex(self.ActiveShopIndex)\n        if activeShop == nil or isvalid(activeShop) == false then\n            return\n        end\n\n        self.IsShopOpen = true\n        self:SetGameplayLockServer(true)\n        self:BuildCurrentSlotsServer()\n    end\n\n    -- Close flow deactivates current shop, rotates to another index, and resumes gameplay lock state.\n    @ExecSpace(\"ServerOnly\")\n    method void CloseAndRotateShopServer()\n        local previousIndex = self.ActiveShopIndex\n\n        self.IsShopOpen = false\n        self:ClearCurrentSlotsServer()\n        self:SetShopEnabledByIndexServer(previousIndex, false)\n        self:ChooseAndActivateNextShopServer(previousIndex)\n        self:SetGameplayLockServer(false)\n    end\n\n    -- Reset endpoint is used by lobby flow so each run starts from a clean shop rotation/state.\n    @ExecSpace(\"ServerOnly\")\n    method void ResetShopStateServer()\n        self.IsShopOpen = false\n        self:ClearCurrentSlotsServer()\n        self:SetGameplayLockServer(false)\n        self:DisableAllShopsServer()\n        self:ChooseAndActivateNextShopServer(0)\n    end\n\n    -- Initial activation always keeps exactly one shop enabled when at least one reference is valid.\n    @ExecSpace(\"ServerOnly\")\n    method void InitializeShopsServer()\n        self.IsShopOpen = false\n        self:ClearCurrentSlotsServer()\n        self:DisableAllShopsServer()\n        self:ChooseAndActivateNextShopServer(0)\n    end\n\n    -- Data table load is centralized so balance values can be adjusted without code changes.\n    @ExecSpace(\"ServerOnly\")\n    method void LoadShopDataServer()\n        self._T.ShopDataTable = nil\n        self._T.ShopRows = {}\n\n        if self.ShopDataTableName == nil or self.ShopDataTableName == \"\" then\n            return\n        end\n\n        local loadOk, tableData = pcall(function()\n            return _DataService:GetTable(self.ShopDataTableName)\n        end)\n        if loadOk == false or tableData == nil then\n            return\n        end\n\n        self._T.ShopDataTable = tableData\n\n        local rowsOk, rows = pcall(function()\n            return tableData:GetAllRow()\n        end)\n        if rowsOk == true and rows ~= nil then\n            self._T.ShopRows = rows\n        end\n    end\n\n    -- Resolver fills missing references from map names so Maker property wiring mistakes fail gracefully.\n    @ExecSpace(\"ServerOnly\")\n    method void ResolveShopEntitiesServer()\n        local mapEntity = self.Entity.CurrentMap\n        if mapEntity == nil or isvalid(mapEntity) == false then\n            return\n        end\n\n        if self.ShopEntity1 == nil or isvalid(self.ShopEntity1) == false then\n            self.ShopEntity1 = self:ResolveShopByNameCandidates(mapEntity, \"Shop_East\", \"ShopEast\", \"Shop1\")\n        end\n        if self.ShopEntity2 == nil or isvalid(self.ShopEntity2) == false then\n            self.ShopEntity2 = self:ResolveShopByNameCandidates(mapEntity, \"Shop_West\", \"ShopWest\", \"Shop2\")\n        end\n        if self.ShopEntity3 == nil or isvalid(self.ShopEntity3) == false then\n            self.ShopEntity3 = self:ResolveShopByNameCandidates(mapEntity, \"Shop_South\", \"ShopSouth\", \"Shop3\")\n        end\n        if self.ShopEntity4 == nil or isvalid(self.ShopEntity4) == false then\n            self.ShopEntity4 = self:ResolveShopByNameCandidates(mapEntity, \"Shop_North\", \"ShopNorth\", \"Shop4\")\n        end\n    end\n\n    -- Name fallback list reduces hard dependency on one exact naming convention for map entities.\n    method Entity ResolveShopByNameCandidates(Entity mapEntity, string primaryName, string fallbackNameA, string fallbackNameB)\n        if mapEntity == nil or isvalid(mapEntity) == false then\n            return nil\n        end\n\n        local candidates = {primaryName, fallbackNameA, fallbackNameB}\n        for _, candidate in pairs(candidates) do\n            if candidate ~= nil and candidate ~= \"\" then\n                local findOk, foundEntity = pcall(function()\n                    return mapEntity:GetChildByName(candidate, true)\n                end)\n                if findOk == true and foundEntity ~= nil and isvalid(foundEntity) == true then\n                    return foundEntity\n                end\n            end\n        end\n\n        return nil\n    end\n\n    -- Batch disable keeps only one active shop visible and avoids stale overlaps from previous cycles.\n    @ExecSpace(\"ServerOnly\")\n    method void DisableAllShopsServer()\n        for shopIndex = 1, 4 do\n            self:SetShopEnabledByIndexServer(shopIndex, false)\n        end\n    end\n\n    -- Rotation picks one random shop from remaining candidates while handling sparse reference setups.\n    @ExecSpace(\"ServerOnly\")\n    method void ChooseAndActivateNextShopServer(integer excludedIndex)\n        local validIndices = self:GetValidShopIndicesServer()\n        if validIndices == nil or #validIndices <= 0 then\n            self.ActiveShopIndex = 0\n            return\n        end\n\n        local candidates = {}\n        local blockedIndex = math.floor(excludedIndex)\n        for _, shopIndex in pairs(validIndices) do\n            if blockedIndex <= 0 or shopIndex ~= blockedIndex then\n                table.insert(candidates, shopIndex)\n            end\n        end\n\n        if #candidates <= 0 then\n            candidates = validIndices\n        end\n\n        local selectedIndex = self:PickRandomIndex(candidates)\n        if selectedIndex <= 0 then\n            self.ActiveShopIndex = 0\n            return\n        end\n\n        self.ActiveShopIndex = selectedIndex\n        self:SetShopEnabledByIndexServer(selectedIndex, true)\n    end\n\n    -- Valid-index collector centralizes entity reference checks for all rotation paths.\n    method table GetValidShopIndicesServer()\n        local validIndices = {}\n\n        for shopIndex = 1, 4 do\n            local shopEntity = self:GetShopEntityByIndex(shopIndex)\n            if shopEntity ~= nil and isvalid(shopEntity) == true then\n                table.insert(validIndices, shopIndex)\n            end\n        end\n\n        return validIndices\n    end\n\n    -- Random picker guards empty input so callers never receive nil and can keep integer flow.\n    method integer PickRandomIndex(table candidates)\n        if candidates == nil then\n            return 0\n        end\n        if #candidates <= 0 then\n            return 0\n        end\n\n        local randomIndex = math.random(1, #candidates)\n        return math.floor(candidates[randomIndex])\n    end\n\n    -- Indexed access keeps all shop-slot references in one function for easier future scaling.\n    method Entity GetShopEntityByIndex(integer shopIndex)\n        local finalIndex = math.floor(shopIndex)\n        if finalIndex == 1 then\n            return self.ShopEntity1\n        end\n        if finalIndex == 2 then\n            return self.ShopEntity2\n        end\n        if finalIndex == 3 then\n            return self.ShopEntity3\n        end\n        if finalIndex == 4 then\n            return self.ShopEntity4\n        end\n\n        return nil\n    end\n\n    -- Single enable wrapper ensures all map-object visibility writes stay synchronized and safe.\n    @ExecSpace(\"ServerOnly\")\n    method void SetShopEnabledByIndexServer(integer shopIndex, boolean enabled)\n        local targetEntity = self:GetShopEntityByIndex(shopIndex)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return\n        end\n\n        self:SetEntityEnableServer(targetEntity, enabled)\n    end\n\n    -- Uses SetEnable when available and falls back to Enable assignment to maximize compatibility.\n    @ExecSpace(\"ServerOnly\")\n    method void SetEntityEnableServer(Entity targetEntity, boolean enabled)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return\n        end\n\n        if targetEntity.SetEnable ~= nil then\n            pcall(function()\n                targetEntity:SetEnable(enabled, false, true)\n            end)\n            return\n        end\n\n        pcall(function()\n            targetEntity.Enable = enabled\n        end)\n    end\n\n    -- Distance validation is server-side to prevent interaction-range spoofing from clients.\n    @ExecSpace(\"ServerOnly\")\n    method boolean IsWithinInteractionRangeServer(Entity shopEntity)\n        local playerPosition = self:GetWorldPosition2D(self.Entity)\n        if playerPosition == nil then\n            return false\n        end\n\n        local shopPosition = self:GetWorldPosition2D(shopEntity)\n        if shopPosition == nil then\n            return false\n        end\n\n        local delta = playerPosition - shopPosition\n        local range = math.max(0, self.InteractionRange)\n        return delta:SqrMagnitude() <= (range * range)\n    end\n\n    -- Position conversion uses 2D plane coordinates because shop interaction is planar in this project.\n    method Vector2 GetWorldPosition2D(Entity targetEntity)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        local transform = targetEntity.TransformComponent\n        if transform == nil or isvalid(transform) == false then\n            return nil\n        end\n\n        local worldPosition = transform.WorldPosition\n        if worldPosition == nil then\n            return nil\n        end\n\n        return Vector2(worldPosition.x, worldPosition.y)\n    end\n\n    -- Slot builder snapshots current shop offers once per open to keep one transaction set consistent.\n    @ExecSpace(\"ServerOnly\")\n    method void BuildCurrentSlotsServer()\n        local slot1 = self:BuildSlotDataServer(\"heal\")\n        local slot2 = self:BuildSlotDataServer(\"ammo\")\n        local slot3 = self:BuildSlotDataServer(\"passive\")\n\n        self._T.CurrentSlots = {slot1, slot2, slot3}\n        self:ApplySlotSyncServer(1, slot1)\n        self:ApplySlotSyncServer(2, slot2)\n        self:ApplySlotSyncServer(3, slot3)\n    end\n\n    -- Slot clear prevents stale item text on client when panel closes and later reopens with new rolls.\n    @ExecSpace(\"ServerOnly\")\n    method void ClearCurrentSlotsServer()\n        self._T.CurrentSlots = {}\n\n        local soldOut = {\n            Type = \"soldout\",\n            Name = \"품절\",\n            Description = \"\",\n            Price = 0,\n            IsSoldOut = true\n        }\n\n        self:ApplySlotSyncServer(1, soldOut)\n        self:ApplySlotSyncServer(2, soldOut)\n        self:ApplySlotSyncServer(3, soldOut)\n    end\n\n    -- Slot data creation reads DataTable first, then falls back to exposed balance properties.\n    @ExecSpace(\"ServerOnly\")\n    method table BuildSlotDataServer(string slotType)\n        local row = self:GetShopRowByTypeServer(slotType)\n\n        if slotType == \"heal\" then\n            local price = self:GetRowInteger(row, \"Price\", self.HealPrice)\n            local effectValue = self:GetRowNumber(row, \"EffectValue\", self.HealPercent)\n            local itemName = self:GetRowString(row, \"ItemName\", \"체력 회복\")\n            local description = self:GetRowString(row, \"Description\", \"최대 HP의 30% 회복\")\n            return {\n                Type = \"heal\",\n                Name = itemName,\n                Description = description,\n                Price = price,\n                EffectValue = effectValue,\n                IsSoldOut = false\n            }\n        end\n\n        if slotType == \"ammo\" then\n            local price = self:GetRowInteger(row, \"Price\", self.AmmoPrice)\n            local effectValue = self:GetRowNumber(row, \"EffectValue\", 1)\n            local itemName = self:GetRowString(row, \"ItemName\", \"탄약 보충\")\n            local description = self:GetRowString(row, \"Description\", \"전 무기 탄약 1세트 충전\")\n            return {\n                Type = \"ammo\",\n                Name = itemName,\n                Description = description,\n                Price = price,\n                EffectValue = effectValue,\n                IsSoldOut = false\n            }\n        end\n\n        if slotType == \"passive\" then\n            local price = self:GetRowInteger(row, \"Price\", self.PassivePrice)\n            local itemName = self:GetRowString(row, \"ItemName\", \"패시브 스킬\")\n            local description = self:GetRowString(row, \"Description\", \"추후 구현 예정\")\n            return {\n                Type = \"passive\",\n                Name = itemName,\n                Description = description,\n                Price = price,\n                EffectValue = 0,\n                IsSoldOut = false\n            }\n        end\n\n        return {\n            Type = \"soldout\",\n            Name = \"품절\",\n            Description = \"\",\n            Price = 0,\n            EffectValue = 0,\n            IsSoldOut = true\n        }\n    end\n\n    -- Row resolver supports both FindRow and full-row scan to tolerate varying table authoring styles.\n    @ExecSpace(\"ServerOnly\")\n    method UserDataRow GetShopRowByTypeServer(string slotType)\n        if self._T.ShopDataTable ~= nil and slotType ~= nil and slotType ~= \"\" then\n            local findOk, findRow = pcall(function()\n                return self._T.ShopDataTable:FindRow(\"SlotType\", slotType)\n            end)\n            if findOk == true and findRow ~= nil then\n                return findRow\n            end\n        end\n\n        local rows = self._T.ShopRows\n        if rows == nil then\n            return nil\n        end\n\n        for _, row in pairs(rows) do\n            local rowType = self:GetRowString(row, \"SlotType\", \"\")\n            if rowType == slotType then\n                return row\n            end\n        end\n\n        return nil\n    end\n\n    -- String reader protects against missing columns and keeps fallback text centralized.\n    method string GetRowString(UserDataRow row, string columnName, string fallbackValue)\n        if row == nil then\n            return fallbackValue\n        end\n        if columnName == nil or columnName == \"\" then\n            return fallbackValue\n        end\n\n        local readOk, text = pcall(function()\n            return row:GetItem(columnName)\n        end)\n        if readOk == false or text == nil or text == \"\" then\n            return fallbackValue\n        end\n\n        return tostring(text)\n    end\n\n    -- Integer reader converts table text safely and prevents invalid rows from breaking purchase logic.\n    method integer GetRowInteger(UserDataRow row, string columnName, integer fallbackValue)\n        local text = self:GetRowString(row, columnName, \"\")\n        if text == nil or text == \"\" then\n            return math.max(0, math.floor(fallbackValue))\n        end\n\n        local parsed = tonumber(text)\n        if parsed == nil then\n            return math.max(0, math.floor(fallbackValue))\n        end\n\n        return math.max(0, math.floor(parsed))\n    end\n\n    -- Number reader keeps percentage/effect values data-driven while preserving sane defaults.\n    method number GetRowNumber(UserDataRow row, string columnName, number fallbackValue)\n        local text = self:GetRowString(row, columnName, \"\")\n        if text == nil or text == \"\" then\n            return fallbackValue\n        end\n\n        local parsed = tonumber(text)\n        if parsed == nil then\n            return fallbackValue\n        end\n\n        return parsed\n    end\n\n    -- Slot getter returns a clone to ensure callers cannot mutate internal slot cache accidentally.\n    method table GetSlotDataServer(integer slotIndex)\n        local finalSlotIndex = self:ClampSlotIndex(slotIndex)\n        if self._T.CurrentSlots == nil then\n            return nil\n        end\n\n        local source = self._T.CurrentSlots[finalSlotIndex]\n        if source == nil then\n            return nil\n        end\n\n        return self:CloneSlotData(source)\n    end\n\n    -- Slot setter centralizes mutation and sync-field propagation for consistent client rendering.\n    method void SetSlotDataServer(integer slotIndex, table slotData)\n        local finalSlotIndex = self:ClampSlotIndex(slotIndex)\n        if self._T.CurrentSlots == nil then\n            self._T.CurrentSlots = {}\n        end\n\n        local clone = self:CloneSlotData(slotData)\n        self._T.CurrentSlots[finalSlotIndex] = clone\n        self:ApplySlotSyncServer(finalSlotIndex, clone)\n    end\n\n    -- Clone utility avoids cross-reference side effects between runtime cache and temporary locals.\n    method table CloneSlotData(table sourceSlot)\n        local clone = {}\n        if sourceSlot == nil then\n            return clone\n        end\n\n        for key, value in pairs(sourceSlot) do\n            clone[key] = value\n        end\n        return clone\n    end\n\n    -- Sync-field projection keeps ShopUI implementation simple without exposing server-only _T tables.\n    method void ApplySlotSyncServer(integer slotIndex, table slotData)\n        local data = self:CloneSlotData(slotData)\n\n        local slotType = \"soldout\"\n        local slotName = \"품절\"\n        local slotDescription = \"\"\n        local slotPrice = 0\n        local slotSoldOut = true\n\n        if data.Type ~= nil then\n            slotType = tostring(data.Type)\n        end\n        if data.Name ~= nil and data.Name ~= \"\" then\n            slotName = tostring(data.Name)\n        end\n        if data.Description ~= nil then\n            slotDescription = tostring(data.Description)\n        end\n        if data.Price ~= nil then\n            slotPrice = math.max(0, math.floor(data.Price))\n        end\n        if data.IsSoldOut ~= nil then\n            slotSoldOut = data.IsSoldOut\n        else\n            slotSoldOut = (slotType == \"soldout\")\n        end\n\n        if slotIndex == 1 then\n            self.Slot1Type = slotType\n            self.Slot1Name = slotName\n            self.Slot1Description = slotDescription\n            self.Slot1Price = slotPrice\n            self.Slot1SoldOut = slotSoldOut\n            return\n        end\n        if slotIndex == 2 then\n            self.Slot2Type = slotType\n            self.Slot2Name = slotName\n            self.Slot2Description = slotDescription\n            self.Slot2Price = slotPrice\n            self.Slot2SoldOut = slotSoldOut\n            return\n        end\n\n        self.Slot3Type = slotType\n        self.Slot3Name = slotName\n        self.Slot3Description = slotDescription\n        self.Slot3Price = slotPrice\n        self.Slot3SoldOut = slotSoldOut\n    end\n\n    -- Purchase effect router keeps slot-specific reward logic isolated for easy future extension.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyPurchaseEffectServer(string slotType, table slotData)\n        if slotType == \"heal\" then\n            local healPercent = self.HealPercent\n            if slotData ~= nil and slotData.EffectValue ~= nil then\n                healPercent = slotData.EffectValue\n            end\n\n            self:ApplyHealPurchaseServer(healPercent)\n            return\n        end\n\n        if slotType == \"ammo\" then\n            local refillValue = 1\n            if slotData ~= nil and slotData.EffectValue ~= nil then\n                refillValue = slotData.EffectValue\n            end\n\n            self:ApplyAmmoPurchaseServer(refillValue)\n            return\n        end\n\n        if slotType == \"passive\" then\n            log(\"[ShopManagerComponent] Passive purchase is placeholder in phase 1.\")\n        end\n    end\n\n    -- Heal is server-applied from MaxHP percentage to preserve anti-cheat authority.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyHealPurchaseServer(number healPercent)\n        local hpComponent = self:ResolveComponentSafe(self.Entity, \"HPSystemComponent\", \"CurrentHP\")\n        if hpComponent == nil then\n            return\n        end\n        if hpComponent.Heal == nil then\n            return\n        end\n\n        local maxHp = 0\n        local readOk, _ = pcall(function()\n            maxHp = hpComponent.MaxHP\n        end)\n        if readOk == false or maxHp <= 0 then\n            return\n        end\n\n        local clampedPercent = math.max(0, healPercent)\n        local healAmount = math.floor(maxHp * (clampedPercent * 0.01))\n        if healAmount <= 0 then\n            healAmount = 1\n        end\n\n        pcall(function()\n            hpComponent:Heal(healAmount)\n        end)\n    end\n\n    -- Ammo refill updates all weapon slots so swap flow remains consistent after leaving shop.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyAmmoPurchaseServer(number effectValue)\n        local reloadComponent = self:ResolveComponentSafe(self.Entity, \"ReloadComponent\", \"CurrentAmmo\")\n        if reloadComponent == nil then\n            return\n        end\n\n        if reloadComponent.CancelCurrentReload ~= nil then\n            pcall(function()\n                reloadComponent:CancelCurrentReload()\n            end)\n        end\n\n        local slotCount = 1\n        pcall(function()\n            slotCount = math.max(1, math.floor(reloadComponent.WeaponSlotCount))\n        end)\n\n        local maxAmmo = 0\n        pcall(function()\n            maxAmmo = math.max(0, math.floor(reloadComponent.MaxAmmo))\n        end)\n\n        if effectValue ~= nil and effectValue <= 0 then\n            return\n        end\n\n        for slot = 1, slotCount do\n            if reloadComponent.SetSlotAmmo ~= nil then\n                pcall(function()\n                    reloadComponent:SetSlotAmmo(slot, maxAmmo)\n                end)\n            end\n        end\n\n        pcall(function()\n            reloadComponent.CurrentAmmo = maxAmmo\n        end)\n        pcall(function()\n            reloadComponent.IsReloading = false\n        end)\n    end\n\n    -- Central gameplay lock path pauses movement/attack/timer and closes swap menu to avoid UI conflicts.\n    @ExecSpace(\"ServerOnly\")\n    method void SetGameplayLockServer(boolean locked)\n        self:SetCanMoveSafely(not locked)\n        self:SetCanAttackSafely(not locked)\n\n        local timerComponent = self:ResolveComponentSafe(self.Entity, \"SpeedrunTimerComponent\", \"IsRunning\")\n        if timerComponent ~= nil and timerComponent.SetPauseSource ~= nil then\n            pcall(function()\n                timerComponent:SetPauseSource(\"shop\", locked)\n            end)\n        end\n\n        if locked == true then\n            self:TryCloseWeaponSwapMenuServer()\n        end\n    end\n\n    -- Swap menu is force-closed on shop open so the single-key interaction model remains deterministic.\n    @ExecSpace(\"ServerOnly\")\n    method void TryCloseWeaponSwapMenuServer()\n        local swapComponent = self:ResolveComponentSafe(self.Entity, \"WeaponSwapComponent\", \"IsSwapMenuOpen\")\n        if swapComponent == nil then\n            return\n        end\n        if swapComponent.CloseSwapMenuServer == nil then\n            return\n        end\n\n        local openState = false\n        local readOk, _ = pcall(function()\n            openState = swapComponent.IsSwapMenuOpen\n        end)\n        if readOk == false or openState == false then\n            return\n        end\n\n        pcall(function()\n            swapComponent:CloseSwapMenuServer()\n        end)\n    end\n\n    -- Movement lock setter prefers shared utility API to keep write safety consistent project-wide.\n    method boolean SetCanMoveSafely(boolean canMove)\n        if self._T.GRUtil ~= nil and self._T.GRUtil.TrySetCanMove ~= nil then\n            return self._T.GRUtil.TrySetCanMove(self.Entity, canMove)\n        end\n\n        local movementComponent = self:ResolveComponentSafe(self.Entity, \"MovementComponent\", \"CanMove\")\n        if movementComponent == nil then\n            return false\n        end\n\n        local writeOk, _ = pcall(function()\n            movementComponent.CanMove = canMove\n        end)\n        return writeOk\n    end\n\n    -- Attack lock mirrors movement lock with fallback write path when utility API is unavailable.\n    method boolean SetCanAttackSafely(boolean canAttack)\n        local fireComponent = self:ResolveComponentSafe(self.Entity, \"FireSystemComponent\", \"CanAttack\")\n        if fireComponent == nil then\n            return false\n        end\n\n        if self._T.GRUtil ~= nil and self._T.GRUtil.TrySetField ~= nil then\n            return self._T.GRUtil.TrySetField(fireComponent, \"CanAttack\", canAttack)\n        end\n\n        local writeOk, _ = pcall(function()\n            fireComponent.CanAttack = canAttack\n        end)\n        return writeOk\n    end\n\n    -- EndPlay always releases shop lock so recycled entities do not keep paused gameplay state.\n    @ExecSpace(\"ServerOnly\")\n    method void OnEndPlay()\n        if self.IsShopOpen == true then\n            self.IsShopOpen = false\n        end\n        self:SetGameplayLockServer(false)\n    end\n\n    -- Slot index normalization keeps all slot table access bounded to the fixed 1~3 range.\n    method integer ClampSlotIndex(integer slotIndex)\n        local normalized = math.floor(slotIndex)\n        if normalized < 1 then\n            return 1\n        end\n        if normalized > 3 then\n            return 3\n        end\n        return normalized\n    end\n\n    -- External purchase API must reject out-of-range values instead of clamping to avoid unintended buys.\n    method boolean IsValidSlotIndex(integer slotIndex)\n        local normalized = math.floor(slotIndex)\n        if normalized < 1 then\n            return false\n        end\n        if normalized > 3 then\n            return false\n        end\n        return true\n    end\n\n    -- Utility bootstrap first; fallback local lookup remains when global util registration fails.\n    method void EnsureGRUtil()\n        if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, utilApi = pcall(function()\n                return utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and utilApi ~= nil then\n                self._T.GRUtil = utilApi\n            end\n            if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    -- Safe resolver supports both prefixed and plain script names to avoid lookup mismatch failures.\n    method any ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then\n            return self._T.GRUtil.ResolveComponent(targetEntity, scriptName, markerField)\n        end\n\n        local prefixedName = scriptName\n        local plainName = scriptName\n        if string.sub(scriptName, 1, 7) == \"script.\" then\n            plainName = string.sub(scriptName, 8)\n        else\n            prefixedName = \"script.\" .. scriptName\n        end\n\n        local component = targetEntity:GetComponent(prefixedName)\n        if component == nil then\n            component = targetEntity:GetComponent(plainName)\n        end\n        if component == nil then\n            return nil\n        end\n\n        if markerField ~= nil and markerField ~= \"\" then\n            local checkOk, _ = pcall(function()\n                return component[markerField]\n            end)\n            if checkOk == false then\n                return nil\n            end\n        end\n\n        return component\n    end\n\n    -- Owner check blocks cross-player RPC attempts while keeping local fallback for non-player contexts.\n    method boolean IsOwnerRequest(string requestUserId)\n        if self._T.GRUtil ~= nil and self._T.GRUtil.IsOwner ~= nil then\n            return self._T.GRUtil.IsOwner(self.Entity, requestUserId)\n        end\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent == nil then\n            return true\n        end\n\n        if requestUserId == nil or requestUserId == \"\" then\n            return true\n        end\n\n        return requestUserId == playerComponent.UserId\n    end\nend\n"
    }
  }
}