@Component
script RankingComponent extends Component

    property number TimeAttackBestTime = -1
    property integer InfiniteModeBestKills = 0

    property integer DisplayCount = 100
    property integer MaxRankScanCount = 2000
    property number MinimumValidClearTime = 5.0
    property number MaximumValidClearTime = 7200.0
    property integer MaximumValidKills = 1000000

    property string TimeAttackStorageName = "GR_TimeAttack"
    property string InfiniteStorageName = "GR_Infinite"
    property string TimeAttackLocalKey = "Ranking_TimeAttackBest"
    property string InfiniteLocalKey = "Ranking_InfiniteBest"

    -- Server initializes local best records from storage so result-screen comparison is deterministic.
    @ExecSpace("ServerOnly")
    method void OnInitialize()
        self:EnsureGRUtil()
        self:LoadLocalBestRecordsServer()
    end

    -- Client utility bootstrap allows ranking UI requests to share the same safe component resolution logic.
    @ExecSpace("ClientOnly")
    method void OnBeginPlay()
        self:EnsureGRUtil()
    end

    -- TimeAttack submit validates record server-side and uploads only when local PB improves.
    @ExecSpace("ServerOnly")
    method boolean SubmitTimeAttackRecordServer(number elapsedTime)
        if self:IsValidTimeAttackRecord(elapsedTime) == false then
            return false
        end

        local isNewRecord = false
        if self.TimeAttackBestTime < 0 then
            isNewRecord = true
        elseif elapsedTime < self.TimeAttackBestTime then
            isNewRecord = true
        end
        if isNewRecord == false then
            return false
        end

        self.TimeAttackBestTime = elapsedTime
        self:SaveLocalBestRecordServer(1, elapsedTime)
        self:UploadTimeAttackRecordServer(elapsedTime)
        return true
    end

    -- Infinite-mode submit follows same PB-only policy to reduce unnecessary storage writes.
    @ExecSpace("ServerOnly")
    method boolean SubmitInfiniteRecordServer(integer killCount)
        if self:IsValidInfiniteRecord(killCount) == false then
            return false
        end

        local isNewRecord = (killCount > self.InfiniteModeBestKills)
        if isNewRecord == false then
            return false
        end

        self.InfiniteModeBestKills = killCount
        self:SaveLocalBestRecordServer(2, killCount)
        self:UploadInfiniteRecordServer(killCount)
        return true
    end

    -- Ranking snapshot request is server-routed so top/my-rank calculations are protected from client spoofing.
    @ExecSpace("Server")
    method void RequestRankingSnapshotServer(integer mode)
        if self:IsOwnerRequest(senderUserId) == false then
            return
        end

        local finalMode = self:NormalizeMode(mode)
        local topRanks = self:GetTopRanksServer(finalMode, self.DisplayCount)
        local myRank = self:GetMyRankServer(finalMode)
        self:ReceiveRankingSnapshotClient(finalMode, topRanks, myRank)
    end

    -- Client snapshot receiver caches latest ranking payload for UI components.
    @ExecSpace("Client")
    method void ReceiveRankingSnapshotClient(integer mode, table topRanks, table myRank)
        self._T.LastSnapshotMode = mode
        self._T.LastTopRanks = topRanks
        self._T.LastMyRank = myRank
    end

    -- Returns top-N ranking rows from sortable storage using mode-specific sort direction.
    @ExecSpace("ServerOnly")
    method table GetTopRanksServer(integer mode, integer count)
        local finalMode = self:NormalizeMode(mode)
        local displayCount = math.max(1, math.floor(count))
        local storage = self:GetSortableStorageByMode(finalMode)
        local rows = {}
        if storage == nil then
            return rows
        end

        local sortDirection = SortDirection.Ascending
        if finalMode == 2 then
            sortDirection = SortDirection.Descending
        end

        local readOk, errorCode, pages = pcall(function()
            return storage:GetSortedAndWait(sortDirection, 0, displayCount - 1)
        end)
        if readOk == false or errorCode ~= 0 or pages == nil then
            return rows
        end

        local rankIndex = 0
        while true do
            local pageItems = pages:GetCurrentPageDatas()
            if pageItems ~= nil then
                for _, item in pairs(pageItems) do
                    rankIndex += 1
                    local userId = item.KeyInfo.Key
                    local score = item.Value

                    local row = {}
                    row.Mode = finalMode
                    row.Rank = rankIndex
                    row.UserId = userId
                    row.Nickname = self:ResolveNicknameByUserId(userId)
                    row.Score = score
                    row.DisplayValue = self:FormatScoreForDisplay(finalMode, score)
                    table.insert(rows, row)

                    if #rows >= displayCount then
                        return rows
                    end
                end
            end

            if pages.IsLastPage == true then
                break
            end

            local loadOk, loadCode = pcall(function()
                return pages:LoadNextPageAndWait()
            end)
            if loadOk == false or loadCode ~= 0 then
                break
            end
            pages:MoveToNextPageAndWait()
        end

        return rows
    end

    -- My-rank lookup scans sorted pages safely with upper bound to avoid heavy loops on large boards.
    @ExecSpace("ServerOnly")
    method table GetMyRankServer(integer mode)
        local finalMode = self:NormalizeMode(mode)
        local userId = self:GetOwnerUserId()
        local result = {}
        result.Mode = finalMode
        result.Rank = -1
        result.UserId = userId
        result.Nickname = self:ResolveNicknameByUserId(userId)
        result.Score = 0
        result.DisplayValue = "-"

        if userId == nil or userId == "" then
            return result
        end

        local storage = self:GetSortableStorageByMode(finalMode)
        if storage == nil then
            return result
        end

        local sortDirection = SortDirection.Ascending
        if finalMode == 2 then
            sortDirection = SortDirection.Descending
        end

        local readOk, errorCode, pages = pcall(function()
            return storage:GetSortedAndWait(sortDirection, 0, math.max(self.DisplayCount, 100) - 1)
        end)
        if readOk == false or errorCode ~= 0 or pages == nil then
            return result
        end

        local rankIndex = 0
        local maxScan = math.max(self.MaxRankScanCount, self.DisplayCount)

        while true do
            local pageItems = pages:GetCurrentPageDatas()
            if pageItems ~= nil then
                for _, item in pairs(pageItems) do
                    rankIndex += 1
                    if item.KeyInfo.Key == userId then
                        result.Rank = rankIndex
                        result.Score = item.Value
                        result.DisplayValue = self:FormatScoreForDisplay(finalMode, item.Value)
                        return result
                    end

                    if rankIndex >= maxScan then
                        return result
                    end
                end
            end

            if pages.IsLastPage == true then
                break
            end

            local loadOk, loadCode = pcall(function()
                return pages:LoadNextPageAndWait()
            end)
            if loadOk == false or loadCode ~= 0 then
                break
            end
            pages:MoveToNextPageAndWait()
        end

        local getOk, getCode, myScore = pcall(function()
            return storage:GetAndWait(userId)
        end)
        if getOk == true and getCode == 0 then
            result.Score = myScore
            result.DisplayValue = self:FormatScoreForDisplay(finalMode, myScore)
        end

        return result
    end

    -- Loads local PB from UserDataStorage to preserve per-user ranking baseline.
    @ExecSpace("ServerOnly")
    method void LoadLocalBestRecordsServer()
        local userId = self:GetOwnerUserId()
        if userId == nil or userId == "" then
            return
        end

        local userStorage = _DataStorageService:GetUserDataStorage(userId)
        if userStorage == nil then
            return
        end

        local timeOk, timeCode, timeValue = pcall(function()
            return userStorage:GetAndWait(self.TimeAttackLocalKey)
        end)
        if timeOk == true and timeCode == 0 and timeValue ~= nil and timeValue ~= "" then
            local parsed = tonumber(timeValue)
            if parsed ~= nil then
                self.TimeAttackBestTime = parsed
            end
        end

        local killOk, killCode, killValue = pcall(function()
            return userStorage:GetAndWait(self.InfiniteLocalKey)
        end)
        if killOk == true and killCode == 0 and killValue ~= nil and killValue ~= "" then
            local parsedKill = tonumber(killValue)
            if parsedKill ~= nil then
                self.InfiniteModeBestKills = math.max(0, math.floor(parsedKill))
            end
        end
    end

    -- Saves PB locally only after record update to minimize storage writes.
    @ExecSpace("ServerOnly")
    method void SaveLocalBestRecordServer(integer mode, number value)
        local userId = self:GetOwnerUserId()
        if userId == nil or userId == "" then
            return
        end

        local userStorage = _DataStorageService:GetUserDataStorage(userId)
        if userStorage == nil then
            return
        end

        local finalMode = self:NormalizeMode(mode)
        if finalMode == 1 then
            pcall(function()
                userStorage:SetAndWait(self.TimeAttackLocalKey, tostring(value))
            end)
            return
        end

        pcall(function()
            userStorage:SetAndWait(self.InfiniteLocalKey, tostring(math.floor(value)))
        end)
    end

    -- TimeAttack upload stores milliseconds so ascending sort yields faster-time-first ranking.
    @ExecSpace("ServerOnly")
    method void UploadTimeAttackRecordServer(number elapsedTime)
        local storage = self:GetSortableStorageByMode(1)
        if storage == nil then
            return
        end

        local userId = self:GetOwnerUserId()
        if userId == nil or userId == "" then
            return
        end

        local milliSeconds = math.max(1, math.floor(elapsedTime * 1000))
        pcall(function()
            storage:SetAndWait(userId, milliSeconds)
        end)
    end

    -- Infinite upload stores kill count directly so descending sort yields higher-kill-first ranking.
    @ExecSpace("ServerOnly")
    method void UploadInfiniteRecordServer(integer killCount)
        local storage = self:GetSortableStorageByMode(2)
        if storage == nil then
            return
        end

        local userId = self:GetOwnerUserId()
        if userId == nil or userId == "" then
            return
        end

        local clampedKill = math.max(0, math.floor(killCount))
        pcall(function()
            storage:SetAndWait(userId, clampedKill)
        end)
    end

    method SortableDataStorage GetSortableStorageByMode(integer mode)
        local finalMode = self:NormalizeMode(mode)
        if finalMode == 1 then
            return _DataStorageService:GetSortableDataStorage(self.TimeAttackStorageName)
        end
        return _DataStorageService:GetSortableDataStorage(self.InfiniteStorageName)
    end

    method boolean IsValidTimeAttackRecord(number elapsedTime)
        if elapsedTime < self.MinimumValidClearTime then
            return false
        end
        if elapsedTime > self.MaximumValidClearTime then
            return false
        end
        return true
    end

    method boolean IsValidInfiniteRecord(integer killCount)
        if killCount < 0 then
            return false
        end
        if killCount > self.MaximumValidKills then
            return false
        end
        return true
    end

    method integer NormalizeMode(integer mode)
        if math.floor(mode) == 2 then
            return 2
        end
        return 1
    end

    -- Converts stored integer score to mode-specific UI text format.
    method string FormatScoreForDisplay(integer mode, integer scoreValue)
        local finalMode = self:NormalizeMode(mode)
        if finalMode == 1 then
            local total = math.max(0, scoreValue)
            local minute = math.floor(total / 60000)
            local second = math.floor((total % 60000) / 1000)
            local centisecond = math.floor((total % 1000) / 10)
            return string.format("%02d:%02d.%02d", minute, second, centisecond)
        end

        return tostring(math.max(0, scoreValue))
    end

    -- Nickname resolver prefers user service cache and falls back to userId for offline entries.
    method string ResolveNicknameByUserId(string userId)
        if userId == nil or userId == "" then
            return "Unknown"
        end

        local users = _UserService.Users
        if users ~= nil then
            local userOk, userInfo = pcall(function()
                return users[userId]
            end)
            if userOk == true and userInfo ~= nil then
                local nickOk, nick = pcall(function()
                    return userInfo.Nickname
                end)
                if nickOk == true and nick ~= nil and nick ~= "" then
                    return nick
                end
            end
        end

        return userId
    end

    -- User id resolver is shared by ranking storage and local PB storage paths.
    method string GetOwnerUserId()
        local userId = ""

        local playerComponent = self.Entity.PlayerComponent
        if playerComponent ~= nil then
            local playerOk, playerUserId = pcall(function()
                return playerComponent.UserId
            end)
            if playerOk == true and playerUserId ~= nil and playerUserId ~= "" then
                userId = playerUserId
            end
        end

        if userId ~= "" then
            return userId
        end

        local localPlayer = _UserService.LocalPlayer
        if localPlayer ~= nil and isvalid(localPlayer) == true then
            local localOk, localUserId = pcall(function()
                return localPlayer.PlayerComponent.UserId
            end)
            if localOk == true and localUserId ~= nil then
                return localUserId
            end
        end

        return ""
    end

    -- Utility bootstrap first; fallback local lookup is retained if global utility registration fails.
    method void EnsureGRUtil()
        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then
            return
        end

        local utilComponent = nil
        if self.Entity ~= nil and isvalid(self.Entity) == true then
            utilComponent = self.Entity:GetComponent("script.GRUtilModule")
            if utilComponent == nil then
                utilComponent = self.Entity:GetComponent("GRUtilModule")
            end
            if utilComponent == nil then
                local addOk1, addResult1 = pcall(function()
                    return self.Entity:AddComponent("script.GRUtilModule")
                end)
                if addOk1 == true then
                    utilComponent = addResult1
                end
            end
            if utilComponent == nil then
                local addOk2, addResult2 = pcall(function()
                    return self.Entity:AddComponent("GRUtilModule")
                end)
                if addOk2 == true then
                    utilComponent = addResult2
                end
            end
        end

        if utilComponent ~= nil and isvalid(utilComponent) == true then
            local bootstrapOk, _ = pcall(function()
                utilComponent:BootstrapUtil()
            end)
            if bootstrapOk == true and _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then
                return
            end
        end

        self._T.UseGRUtilFallback = true
    end

    method Component ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)
        if targetEntity == nil or isvalid(targetEntity) == false then
            return nil
        end

        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then
            return _GRUtil.ResolveComponent(targetEntity, scriptName, markerField)
        end

        local prefixedName = scriptName
        local plainName = scriptName
        if string.sub(scriptName, 1, 7) == "script." then
            plainName = string.sub(scriptName, 8)
        else
            prefixedName = "script." .. scriptName
        end

        local component = targetEntity:GetComponent(prefixedName)
        if component == nil then
            component = targetEntity:GetComponent(plainName)
        end
        if component == nil then
            return nil
        end

        if markerField ~= nil and markerField ~= "" then
            local ok, _ = pcall(function()
                return component[markerField]
            end)
            if ok == false then
                return nil
            end
        end

        return component
    end

    method boolean IsOwnerRequest(string requestUserId)
        if _GRUtil ~= nil and _GRUtil.IsOwner ~= nil then
            return _GRUtil.IsOwner(self.Entity, requestUserId)
        end

        local playerComponent = self.Entity.PlayerComponent
        if playerComponent == nil then
            return true
        end

        if requestUserId == nil or requestUserId == "" then
            return true
        end

        return requestUserId == playerComponent.UserId
    end
end
