{
  "Id": "",
  "GameId": "",
  "EntryKey": "codeblock://b82cd488-a792-4293-9c96-87e6378ebfc3",
  "ContentType": "x-mod/codeblock",
  "Content": "",
  "Usage": 0,
  "UsePublish": 1,
  "UseService": 0,
  "CoreVersion": "26.1.0.0",
  "StudioVersion": "",
  "DynamicLoading": 0,
  "ContentProto": {
    "Use": "Json",
    "Json": {
      "CoreVersion": {
        "Major": 0,
        "Minor": 2
      },
      "ScriptVersion": {
        "Major": 1,
        "Minor": 1
      },
      "Description": "",
      "Id": "b82cd488-a792-4293-9c96-87e6378ebfc3",
      "Language": 1,
      "Name": "TagManagerComponent",
      "Type": 1,
      "Source": 1,
      "Target": "@Component\nscript TagManagerComponent extends Component\n\n    @Sync\n    property integer CurrentCharIndex = 1\n    property number TagCooldown = 3.0\n    @Sync\n    property boolean IsTagReady = true\n    property number InvincibleTime = 0.5\n    @Sync\n    property boolean IsTagLocked = false\n\n    property boolean DisableMoveDuringTag = true\n    property boolean CancelReloadOnTag = true\n    property number SwapLockDuration = 0.1\n\n    property string CharacterAAvatarRuid = \"\"\n    property string CharacterBAvatarRuid = \"\"\n\n    -- Server initializes character snapshot buffers so both characters keep independent combat state.\n    @ExecSpace(\"ServerOnly\")\n    method void OnInitialize()\n        self:EnsureGRUtil()\n\n        self.CurrentCharIndex = self:ClampCharacterIndex(self.CurrentCharIndex)\n        self.IsTagReady = true\n        self._T.TagCooldownTimerId = 0\n        self._T.TagInvincibleTimerId = 0\n        self._T.TagUnlockTimerId = 0\n        self._T.IsTagInProgress = false\n\n        self._T.CharacterStates = {}\n        self._T.CharacterStates[1] = self:CaptureCurrentCharacterState()\n        self._T.CharacterStates[2] = self:CloneCharacterState(self._T.CharacterStates[1])\n    end\n\n    -- Client bootstraps utility so owner validation and component lookup conventions match other scripts.\n    @ExecSpace(\"ClientOnly\")\n    method void OnBeginPlay()\n        self:EnsureGRUtil()\n    end\n\n    -- Q requests server-authoritative tag swap; all swap decisions stay on server.\n    @EventSender(\"Service\", \"InputService\")\n    handler HandleKeyDownEvent(KeyDownEvent event)\n        if event.key ~= KeyboardKey.Q then\n            return\n        end\n\n        self:RequestTagServer()\n    end\n\n    -- Server request entry checks ownership and state-gating before executing swap.\n    @ExecSpace(\"Server\")\n    method void RequestTagServer()\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n        if self:CanTagServer() == false then\n            return\n        end\n\n        self:ExecuteTagSwapServer()\n    end\n\n    -- Gate keeps cooldown, lock, death, and swap-menu conflicts consistent in one place.\n    @ExecSpace(\"ServerOnly\")\n    method boolean CanTagServer()\n        if self.Entity == nil or isvalid(self.Entity) == false then\n            return false\n        end\n        if self.IsTagLocked == true then\n            return false\n        end\n        if self.IsTagReady == false then\n            return false\n        end\n        if self._T.IsTagInProgress == true then\n            return false\n        end\n\n        local hpComponent = self:ResolveComponentSafe(self.Entity, \"HPSystemComponent\", \"IsDead\")\n        if hpComponent ~= nil then\n            local deadOk, isDead = pcall(function()\n                return hpComponent.IsDead\n            end)\n            if deadOk == true and isDead == true then\n                return false\n            end\n        end\n\n        local swapComponent = self:ResolveComponentSafe(self.Entity, \"WeaponSwapComponent\", \"IsSwapMenuOpen\")\n        if swapComponent ~= nil then\n            local menuOk, menuOpen = pcall(function()\n                return swapComponent.IsSwapMenuOpen\n            end)\n            if menuOk == true and menuOpen == true then\n                return false\n            end\n        end\n\n        return true\n    end\n\n    -- Core swap saves current character data and loads the standby character data atomically.\n    @ExecSpace(\"ServerOnly\")\n    method void ExecuteTagSwapServer()\n        self._T.IsTagInProgress = true\n        local fromIndex = self:ClampCharacterIndex(self.CurrentCharIndex)\n        local toIndex = self:GetOtherCharacterIndex(fromIndex)\n\n        if self.DisableMoveDuringTag == true then\n            self:SetCanMoveSafely(false)\n        end\n\n        self:StoreCharacterState(fromIndex)\n        self:ApplyCharacterState(toIndex)\n        self.CurrentCharIndex = toIndex\n\n        self:ApplyCharacterVisualServer(toIndex)\n        self:ApplyInvincibleWindowServer()\n        self:TriggerEntrySkillServer(toIndex)\n        self:StartTagCooldownServer()\n        self:StartMovementUnlockServer()\n        self:NotifyTagChangedClient(toIndex)\n    end\n\n    -- Cooldown timer is server-driven to prevent client clock manipulation.\n    @ExecSpace(\"ServerOnly\")\n    method void StartTagCooldownServer()\n        if self._T.TagCooldownTimerId ~= nil and self._T.TagCooldownTimerId \u003e 0 then\n            _TimerService:ClearTimer(self._T.TagCooldownTimerId)\n            self._T.TagCooldownTimerId = 0\n        end\n\n        self.IsTagReady = false\n        local cooldown = math.max(self.TagCooldown, 0)\n\n        local restoreTagReady = function()\n            self.IsTagReady = true\n            self._T.TagCooldownTimerId = 0\n        end\n\n        self._T.TagCooldownTimerId = _TimerService:SetTimerOnce(restoreTagReady, cooldown)\n    end\n\n    -- Short movement unlock timer prevents immediate move while swap transition is still being applied.\n    @ExecSpace(\"ServerOnly\")\n    method void StartMovementUnlockServer()\n        if self.DisableMoveDuringTag == false then\n            self:SetCanMoveSafely(true)\n            self._T.IsTagInProgress = false\n            return\n        end\n\n        if self._T.TagUnlockTimerId ~= nil and self._T.TagUnlockTimerId \u003e 0 then\n            _TimerService:ClearTimer(self._T.TagUnlockTimerId)\n            self._T.TagUnlockTimerId = 0\n        end\n\n        local unlockDelay = math.max(self.SwapLockDuration, 0)\n        local unlockMove = function()\n            self:SetCanMoveSafely(true)\n            self._T.TagUnlockTimerId = 0\n            self._T.IsTagInProgress = false\n        end\n\n        self._T.TagUnlockTimerId = _TimerService:SetTimerOnce(unlockMove, unlockDelay)\n    end\n\n    -- Invincibility window protects tag entry frames and is always cleared by timer.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyInvincibleWindowServer()\n        local hpComponent = self:ResolveComponentSafe(self.Entity, \"HPSystemComponent\", \"IsInvincible\")\n        if hpComponent == nil then\n            return\n        end\n\n        if self._T.TagInvincibleTimerId ~= nil and self._T.TagInvincibleTimerId \u003e 0 then\n            _TimerService:ClearTimer(self._T.TagInvincibleTimerId)\n            self._T.TagInvincibleTimerId = 0\n        end\n\n        pcall(function()\n            hpComponent.IsInvincible = true\n        end)\n\n        local duration = math.max(self.InvincibleTime, 0)\n        local clearInvincible = function()\n            pcall(function()\n                hpComponent.IsInvincible = false\n            end)\n            self._T.TagInvincibleTimerId = 0\n        end\n\n        self._T.TagInvincibleTimerId = _TimerService:SetTimerOnce(clearInvincible, duration)\n    end\n\n    -- Captures HP/weapon/reload state snapshot for the currently active character.\n    @ExecSpace(\"ServerOnly\")\n    method table CaptureCurrentCharacterState()\n        local state = {}\n        state.Timestamp = _UtilLogic.ServerElapsedSeconds\n\n        local hpComponent = self:ResolveComponentSafe(self.Entity, \"HPSystemComponent\", \"CurrentHP\")\n        if hpComponent ~= nil then\n            local hpOk, hpValue = pcall(function()\n                return hpComponent.CurrentHP\n            end)\n            if hpOk == true and hpValue ~= nil then\n                state.CurrentHP = hpValue\n            end\n        end\n\n        local swapComponent = self:ResolveComponentSafe(self.Entity, \"WeaponSwapComponent\", \"CurrentWeaponSlot\")\n        if swapComponent ~= nil and swapComponent.ExportWeaponSwapState ~= nil then\n            local exportOk, exportState = pcall(function()\n                return swapComponent:ExportWeaponSwapState()\n            end)\n            if exportOk == true and exportState ~= nil then\n                state.WeaponSwapState = exportState\n            end\n        end\n\n        local reloadComponent = self:ResolveComponentSafe(self.Entity, \"ReloadComponent\", \"CurrentWeaponSlot\")\n        if reloadComponent ~= nil then\n            local ammoBySlot = {}\n            local slotCount = 4\n            if swapComponent ~= nil then\n                local countOk, countValue = pcall(function()\n                    return swapComponent.WeaponSlotCount\n                end)\n                if countOk == true and countValue ~= nil then\n                    slotCount = math.max(1, math.floor(countValue))\n                end\n            end\n\n            for slot = 1, slotCount do\n                local ammoOk, ammoValue = pcall(function()\n                    return reloadComponent:GetSlotAmmo(slot)\n                end)\n                if ammoOk == true and ammoValue ~= nil then\n                    ammoBySlot[slot] = ammoValue\n                end\n            end\n\n            state.AmmoBySlot = ammoBySlot\n        end\n\n        return state\n    end\n\n    -- Applies target character snapshot and restores linked components to that state.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyCharacterState(integer charIndex)\n        local targetIndex = self:ClampCharacterIndex(charIndex)\n        local state = self._T.CharacterStates[targetIndex]\n        if state == nil then\n            state = self:CaptureCurrentCharacterState()\n            self._T.CharacterStates[targetIndex] = state\n        end\n\n        local hpComponent = self:ResolveComponentSafe(self.Entity, \"HPSystemComponent\", \"CurrentHP\")\n        if hpComponent ~= nil and state.CurrentHP ~= nil then\n            pcall(function()\n                hpComponent.CurrentHP = math.max(0, math.floor(state.CurrentHP))\n                hpComponent.IsDead = (hpComponent.CurrentHP \u003c= 0)\n            end)\n        end\n\n        local swapComponent = self:ResolveComponentSafe(self.Entity, \"WeaponSwapComponent\", \"CurrentWeaponSlot\")\n        if swapComponent ~= nil and state.WeaponSwapState ~= nil and swapComponent.ImportWeaponSwapState ~= nil then\n            pcall(function()\n                swapComponent:ImportWeaponSwapState(state.WeaponSwapState)\n            end)\n        end\n\n        local reloadComponent = self:ResolveComponentSafe(self.Entity, \"ReloadComponent\", \"CurrentAmmo\")\n        if reloadComponent ~= nil and state.AmmoBySlot ~= nil then\n            if self.CancelReloadOnTag == true then\n                pcall(function()\n                    reloadComponent:CancelCurrentReload()\n                end)\n            end\n            for slot, ammo in pairs(state.AmmoBySlot) do\n                pcall(function()\n                    reloadComponent:SetSlotAmmo(slot, ammo)\n                end)\n            end\n        end\n    end\n\n    -- Stores active character snapshot back into its index.\n    @ExecSpace(\"ServerOnly\")\n    method void StoreCharacterState(integer charIndex)\n        local index = self:ClampCharacterIndex(charIndex)\n        self._T.CharacterStates[index] = self:CaptureCurrentCharacterState()\n    end\n\n    -- Avatar switch hook is optional and uses pcall so missing avatar APIs do not break swap flow.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyCharacterVisualServer(integer charIndex)\n        local avatarRenderer = self.Entity.AvatarRendererComponent\n        if avatarRenderer == nil or isvalid(avatarRenderer) == false then\n            return\n        end\n\n        local targetRuid = self.CharacterAAvatarRuid\n        if self:ClampCharacterIndex(charIndex) == 2 then\n            targetRuid = self.CharacterBAvatarRuid\n        end\n        if targetRuid == nil or targetRuid == \"\" then\n            return\n        end\n\n        pcall(function()\n            avatarRenderer.CurrentBodyRuid = targetRuid\n        end)\n        pcall(function()\n            avatarRenderer.BodyRuid = targetRuid\n        end)\n        pcall(function()\n            avatarRenderer:ApplyBody(targetRuid)\n        end)\n    end\n\n    -- Entry-skill hook stays isolated so character-specific skill scripts can be added without rewiring tag flow.\n    @ExecSpace(\"ServerOnly\")\n    method void TriggerEntrySkillServer(integer charIndex)\n        local entrySkill = self:ResolveComponentSafe(self.Entity, \"TagEntrySkillComponent\", nil)\n        if entrySkill ~= nil and entrySkill.TriggerEntrySkill ~= nil then\n            pcall(function()\n                entrySkill:TriggerEntrySkill(charIndex)\n            end)\n            return\n        end\n\n        log(\"[TagManagerComponent] Entry skill placeholder executed for char index: \" .. tostring(charIndex))\n    end\n\n    -- Client callback keeps UI/avatar overlays synchronized with the current active character index.\n    @ExecSpace(\"Client\")\n    method void NotifyTagChangedClient(integer charIndex)\n        local weaponUI = self:ResolveComponentSafe(self.Entity, \"WeaponWheelUIComponent\", nil)\n        if weaponUI ~= nil and weaponUI.OnTagChangedClient ~= nil then\n            pcall(function()\n                weaponUI:OnTagChangedClient(charIndex)\n            end)\n        end\n    end\n\n    -- External systems can lock/unlock tag by calling a dedicated server method.\n    @ExecSpace(\"ServerOnly\")\n    method void SetTagLocked(boolean locked)\n        self.IsTagLocked = locked\n    end\n\n    -- Export API allows bootstrap/meta systems to snapshot per-character states externally.\n    @ExecSpace(\"ServerOnly\")\n    method table ExportCharacterState(integer charIndex)\n        local index = self:ClampCharacterIndex(charIndex)\n        local state = self._T.CharacterStates[index]\n        if state == nil then\n            return nil\n        end\n        return self:CloneCharacterState(state)\n    end\n\n    -- Import API allows external recovery without direct table mutation.\n    @ExecSpace(\"ServerOnly\")\n    method void ImportCharacterState(integer charIndex, table state)\n        if state == nil then\n            return\n        end\n        local index = self:ClampCharacterIndex(charIndex)\n        self._T.CharacterStates[index] = self:CloneCharacterState(state)\n    end\n\n    method integer ClampCharacterIndex(integer charIndex)\n        if math.floor(charIndex) \u003c= 1 then\n            return 1\n        end\n        return 2\n    end\n\n    method integer GetOtherCharacterIndex(integer charIndex)\n        if self:ClampCharacterIndex(charIndex) == 1 then\n            return 2\n        end\n        return 1\n    end\n\n    -- Clone helper avoids accidental shared-table mutation between character snapshots.\n    method table CloneCharacterState(table source)\n        local clone = {}\n        if source == nil then\n            return clone\n        end\n\n        for key, value in pairs(source) do\n            if type(value) == \"table\" then\n                local nested = {}\n                for key2, value2 in pairs(value) do\n                    nested[key2] = value2\n                end\n                clone[key] = nested\n            else\n                clone[key] = value\n            end\n        end\n\n        return clone\n    end\n\n    -- Movement write uses shared util path first so all authority checks stay centralized.\n    method boolean SetCanMoveSafely(boolean canMove)\n        if _GRUtil ~= nil and _GRUtil.TrySetCanMove ~= nil then\n            return _GRUtil.TrySetCanMove(self.Entity, canMove)\n        end\n\n        local movementComponent = self:ResolveComponentSafe(self.Entity, \"MovementComponent\", \"CanMove\")\n        if movementComponent == nil then\n            return false\n        end\n\n        local ok, _ = pcall(function()\n            movementComponent.CanMove = canMove\n        end)\n        return ok\n    end\n\n    -- EndPlay clears timers so tag callbacks never fire on destroyed entities.\n    @ExecSpace(\"ServerOnly\")\n    method void OnEndPlay()\n        if self._T.TagCooldownTimerId ~= nil and self._T.TagCooldownTimerId \u003e 0 then\n            _TimerService:ClearTimer(self._T.TagCooldownTimerId)\n            self._T.TagCooldownTimerId = 0\n        end\n        if self._T.TagInvincibleTimerId ~= nil and self._T.TagInvincibleTimerId \u003e 0 then\n            _TimerService:ClearTimer(self._T.TagInvincibleTimerId)\n            self._T.TagInvincibleTimerId = 0\n        end\n        if self._T.TagUnlockTimerId ~= nil and self._T.TagUnlockTimerId \u003e 0 then\n            _TimerService:ClearTimer(self._T.TagUnlockTimerId)\n            self._T.TagUnlockTimerId = 0\n        end\n    end\n\n    -- Utility bootstrap first; fallback local lookup is kept for resiliency when util component is missing.\n    method void EnsureGRUtil()\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, _ = pcall(function()\n                utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    method Component ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return _GRUtil.ResolveComponent(targetEntity, scriptName, markerField)\n        end\n\n        local prefixedName = scriptName\n        local plainName = scriptName\n        if string.sub(scriptName, 1, 7) == \"script.\" then\n            plainName = string.sub(scriptName, 8)\n        else\n            prefixedName = \"script.\" .. scriptName\n        end\n\n        local component = targetEntity:GetComponent(prefixedName)\n        if component == nil then\n            component = targetEntity:GetComponent(plainName)\n        end\n        if component == nil then\n            return nil\n        end\n\n        if markerField ~= nil and markerField ~= \"\" then\n            local ok, _ = pcall(function()\n                return component[markerField]\n            end)\n            if ok == false then\n                return nil\n            end\n        end\n\n        return component\n    end\n\n    method boolean IsOwnerRequest(string requestUserId)\n        if _GRUtil ~= nil and _GRUtil.IsOwner ~= nil then\n            return _GRUtil.IsOwner(self.Entity, requestUserId)\n        end\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent == nil then\n            return true\n        end\n\n        if requestUserId == nil or requestUserId == \"\" then\n            return true\n        end\n\n        return requestUserId == playerComponent.UserId\n    end\nend\n"\"\n    property string CharacterBAvatarRuid = \"\"\n\n    -- Server initializes character snapshot buffers so both characters keep independent combat state.\n    @ExecSpace(\"ServerOnly\")\n    method void OnInitialize()\n        self:EnsureGRUtil()\n\n        self.CurrentCharIndex = self:ClampCharacterIndex(self.CurrentCharIndex)\n        self.IsTagReady = true\n        self._T.TagCooldownTimerId = 0\n        self._T.TagInvincibleTimerId = 0\n        self._T.TagUnlockTimerId = 0\n        self._T.IsTagInProgress = false\n\n        self._T.CharacterStates = {}\n        self._T.CharacterStates[1] = self:CaptureCurrentCharacterState()\n        self._T.CharacterStates[2] = self:CloneCharacterState(self._T.CharacterStates[1])\n    end\n\n    -- Client bootstraps utility so owner validation and component lookup conventions match other scripts.\n    @ExecSpace(\"ClientOnly\")\n    method void OnBeginPlay()\n        self:EnsureGRUtil()\n    end\n\n    -- Q requests server-authoritative tag swap; all swap decisions stay on server.\n    @EventSender(\"Service\", \"InputService\")\n    handler HandleKeyDownEvent(KeyDownEvent event)\n        if event.key ~= KeyboardKey.Q then\n            return\n        end\n\n        self:RequestTagServer()\n    end\n\n    -- Server request entry checks ownership and state-gating before executing swap.\n    @ExecSpace(\"Server\")\n    method void RequestTagServer()\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n        if self:CanTagServer() == false then\n            return\n        end\n\n        self:ExecuteTagSwapServer()\n    end\n\n    -- Gate keeps cooldown, lock, death, and swap-menu conflicts consistent in one place.\n    @ExecSpace(\"ServerOnly\")\n    method boolean CanTagServer()\n        if self.Entity == nil or isvalid(self.Entity) == false then\n            return false\n        end\n        if self.IsTagLocked == true then\n            return false\n        end\n        if self.IsTagReady == false then\n            return false\n        end\n        if self._T.IsTagInProgress == true then\n            return false\n        end\n\n        local hpComponent = self:ResolveComponentSafe(self.Entity, \"HPSystemComponent\", \"IsDead\")\n        if hpComponent ~= nil then\n            local deadOk, isDead = pcall(function()\n                return hpComponent.IsDead\n            end)\n            if deadOk == true and isDead == true then\n                return false\n            end\n        end\n\n        local swapComponent = self:ResolveComponentSafe(self.Entity, \"WeaponSwapComponent\", \"IsSwapMenuOpen\")\n        if swapComponent ~= nil then\n            local menuOk, menuOpen = pcall(function()\n                return swapComponent.IsSwapMenuOpen\n            end)\n            if menuOk == true and menuOpen == true then\n                return false\n            end\n        end\n\n        return true\n    end\n\n    -- Core swap saves current character data and loads the standby character data atomically.\n    @ExecSpace(\"ServerOnly\")\n    method void ExecuteTagSwapServer()\n        self._T.IsTagInProgress = true\n        local fromIndex = self:ClampCharacterIndex(self.CurrentCharIndex)\n        local toIndex = self:GetOtherCharacterIndex(fromIndex)\n\n        if self.DisableMoveDuringTag == true then\n            self:SetCanMoveSafely(false)\n        end\n\n        self:StoreCharacterState(fromIndex)\n        self:ApplyCharacterState(toIndex)\n        self.CurrentCharIndex = toIndex\n\n        self:ApplyCharacterVisualServer(toIndex)\n        self:ApplyInvincibleWindowServer()\n        self:TriggerEntrySkillServer(toIndex)\n        self:StartTagCooldownServer()\n        self:StartMovementUnlockServer()\n        self:NotifyTagChangedClient(toIndex)\n    end\n\n    -- Cooldown timer is server-driven to prevent client clock manipulation.\n    @ExecSpace(\"ServerOnly\")\n    method void StartTagCooldownServer()\n        if self._T.TagCooldownTimerId ~= nil and self._T.TagCooldownTimerId > 0 then\n            _TimerService:ClearTimer(self._T.TagCooldownTimerId)\n            self._T.TagCooldownTimerId = 0\n        end\n\n        self.IsTagReady = false\n        local cooldown = math.max(self.TagCooldown, 0)\n\n        local restoreTagReady = function()\n            self.IsTagReady = true\n            self._T.TagCooldownTimerId = 0\n        end\n\n        self._T.TagCooldownTimerId = _TimerService:SetTimerOnce(restoreTagReady, cooldown)\n    end\n\n    -- Short movement unlock timer prevents immediate move while swap transition is still being applied.\n    @ExecSpace(\"ServerOnly\")\n    method void StartMovementUnlockServer()\n        if self.DisableMoveDuringTag == false then\n            self:SetCanMoveSafely(true)\n            self._T.IsTagInProgress = false\n            return\n        end\n\n        if self._T.TagUnlockTimerId ~= nil and self._T.TagUnlockTimerId > 0 then\n            _TimerService:ClearTimer(self._T.TagUnlockTimerId)\n            self._T.TagUnlockTimerId = 0\n        end\n\n        local unlockDelay = math.max(self.SwapLockDuration, 0)\n        local unlockMove = function()\n            self:SetCanMoveSafely(true)\n            self._T.TagUnlockTimerId = 0\n            self._T.IsTagInProgress = false\n        end\n\n        self._T.TagUnlockTimerId = _TimerService:SetTimerOnce(unlockMove, unlockDelay)\n    end\n\n    -- Invincibility window protects tag entry frames and is always cleared by timer.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyInvincibleWindowServer()\n        local hpComponent = self:ResolveComponentSafe(self.Entity, \"HPSystemComponent\", \"IsInvincible\")\n        if hpComponent == nil then\n            return\n        end\n\n        if self._T.TagInvincibleTimerId ~= nil and self._T.TagInvincibleTimerId > 0 then\n            _TimerService:ClearTimer(self._T.TagInvincibleTimerId)\n            self._T.TagInvincibleTimerId = 0\n        end\n\n        pcall(function()\n            hpComponent.IsInvincible = true\n        end)\n\n        local duration = math.max(self.InvincibleTime, 0)\n        local clearInvincible = function()\n            pcall(function()\n                hpComponent.IsInvincible = false\n            end)\n            self._T.TagInvincibleTimerId = 0\n        end\n\n        self._T.TagInvincibleTimerId = _TimerService:SetTimerOnce(clearInvincible, duration)\n    end\n\n    -- Captures HP/weapon/reload state snapshot for the currently active character.\n    @ExecSpace(\"ServerOnly\")\n    method table CaptureCurrentCharacterState()\n        local state = {}\n        state.Timestamp = _UtilLogic.ServerElapsedSeconds\n\n        local hpComponent = self:ResolveComponentSafe(self.Entity, \"HPSystemComponent\", \"CurrentHP\")\n        if hpComponent ~= nil then\n            local hpOk, hpValue = pcall(function()\n                return hpComponent.CurrentHP\n            end)\n            if hpOk == true and hpValue ~= nil then\n                state.CurrentHP = hpValue\n            end\n        end\n\n        local swapComponent = self:ResolveComponentSafe(self.Entity, \"WeaponSwapComponent\", \"CurrentWeaponSlot\")\n        if swapComponent ~= nil and swapComponent.ExportWeaponSwapState ~= nil then\n            local exportOk, exportState = pcall(function()\n                return swapComponent:ExportWeaponSwapState()\n            end)\n            if exportOk == true and exportState ~= nil then\n                state.WeaponSwapState = exportState\n            end\n        end\n\n        local reloadComponent = self:ResolveComponentSafe(self.Entity, \"ReloadComponent\", \"CurrentWeaponSlot\")\n        if reloadComponent ~= nil then\n            local ammoBySlot = {}\n            local slotCount = 4\n            if swapComponent ~= nil then\n                local countOk, countValue = pcall(function()\n                    return swapComponent.WeaponSlotCount\n                end)\n                if countOk == true and countValue ~= nil then\n                    slotCount = math.max(1, math.floor(countValue))\n                end\n            end\n\n            for slot = 1, slotCount do\n                local ammoOk, ammoValue = pcall(function()\n                    return reloadComponent:GetSlotAmmo(slot)\n                end)\n                if ammoOk == true and ammoValue ~= nil then\n                    ammoBySlot[slot] = ammoValue\n                end\n            end\n\n            state.AmmoBySlot = ammoBySlot\n        end\n\n        return state\n    end\n\n    -- Applies target character snapshot and restores linked components to that state.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyCharacterState(integer charIndex)\n        local targetIndex = self:ClampCharacterIndex(charIndex)\n        local state = self._T.CharacterStates[targetIndex]\n        if state == nil then\n            state = self:CaptureCurrentCharacterState()\n            self._T.CharacterStates[targetIndex] = state\n        end\n\n        local hpComponent = self:ResolveComponentSafe(self.Entity, \"HPSystemComponent\", \"CurrentHP\")\n        if hpComponent ~= nil and state.CurrentHP ~= nil then\n            pcall(function()\n                hpComponent.CurrentHP = math.max(0, math.floor(state.CurrentHP))\n                hpComponent.IsDead = (hpComponent.CurrentHP <= 0)\n            end)\n        end\n\n        local swapComponent = self:ResolveComponentSafe(self.Entity, \"WeaponSwapComponent\", \"CurrentWeaponSlot\")\n        if swapComponent ~= nil and state.WeaponSwapState ~= nil and swapComponent.ImportWeaponSwapState ~= nil then\n            pcall(function()\n                swapComponent:ImportWeaponSwapState(state.WeaponSwapState)\n            end)\n        end\n\n        local reloadComponent = self:ResolveComponentSafe(self.Entity, \"ReloadComponent\", \"CurrentAmmo\")\n        if reloadComponent ~= nil and state.AmmoBySlot ~= nil then\n            if self.CancelReloadOnTag == true then\n                pcall(function()\n                    reloadComponent:CancelCurrentReload()\n                end)\n            end\n            for slot, ammo in pairs(state.AmmoBySlot) do\n                pcall(function()\n                    reloadComponent:SetSlotAmmo(slot, ammo)\n                end)\n            end\n        end\n    end\n\n    -- Stores active character snapshot back into its index.\n    @ExecSpace(\"ServerOnly\")\n    method void StoreCharacterState(integer charIndex)\n        local index = self:ClampCharacterIndex(charIndex)\n        self._T.CharacterStates[index] = self:CaptureCurrentCharacterState()\n    end\n\n    -- Avatar switch hook is optional and uses pcall so missing avatar APIs do not break swap flow.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyCharacterVisualServer(integer charIndex)\n        local avatarRenderer = self.Entity.AvatarRendererComponent\n        if avatarRenderer == nil or isvalid(avatarRenderer) == false then\n            return\n        end\n\n        local targetRuid = self.CharacterAAvatarRuid\n        if self:ClampCharacterIndex(charIndex) == 2 then\n            targetRuid = self.CharacterBAvatarRuid\n        end\n        if targetRuid == nil or targetRuid == \"\" then\n            return\n        end\n\n        pcall(function()\n            avatarRenderer.CurrentBodyRuid = targetRuid\n        end)\n        pcall(function()\n            avatarRenderer.BodyRuid = targetRuid\n        end)\n        pcall(function()\n            avatarRenderer:ApplyBody(targetRuid)\n        end)\n    end\n\n    -- Entry-skill hook stays isolated so character-specific skill scripts can be added without rewiring tag flow.\n    @ExecSpace(\"ServerOnly\")\n    method void TriggerEntrySkillServer(integer charIndex)\n        local entrySkill = self:ResolveComponentSafe(self.Entity, \"TagEntrySkillComponent\", nil)\n        if entrySkill ~= nil and entrySkill.TriggerEntrySkill ~= nil then\n            pcall(function()\n                entrySkill:TriggerEntrySkill(charIndex)\n            end)\n            return\n        end\n\n        log(\"[TagManagerComponent] Entry skill placeholder executed for char index: \" .. tostring(charIndex))\n    end\n\n    -- Client callback keeps UI/avatar overlays synchronized with the current active character index.\n    @ExecSpace(\"Client\")\n    method void NotifyTagChangedClient(integer charIndex)\n        local weaponUI = self:ResolveComponentSafe(self.Entity, \"WeaponWheelUIComponent\", nil)\n        if weaponUI ~= nil and weaponUI.OnTagChangedClient ~= nil then\n            pcall(function()\n                weaponUI:OnTagChangedClient(charIndex)\n            end)\n        end\n    end\n\n    -- External systems can lock/unlock tag by calling a dedicated server method.\n    @ExecSpace(\"ServerOnly\")\n    method void SetTagLocked(boolean locked)\n        self.IsTagLocked = locked\n    end\n\n    -- Export API allows bootstrap/meta systems to snapshot per-character states externally.\n    @ExecSpace(\"ServerOnly\")\n    method table ExportCharacterState(integer charIndex)\n        local index = self:ClampCharacterIndex(charIndex)\n        local state = self._T.CharacterStates[index]\n        if state == nil then\n            return nil\n        end\n        return self:CloneCharacterState(state)\n    end\n\n    -- Import API allows external recovery without direct table mutation.\n    @ExecSpace(\"ServerOnly\")\n    method void ImportCharacterState(integer charIndex, table state)\n        if state == nil then\n            return\n        end\n        local index = self:ClampCharacterIndex(charIndex)\n        self._T.CharacterStates[index] = self:CloneCharacterState(state)\n    end\n\n    method integer ClampCharacterIndex(integer charIndex)\n        if math.floor(charIndex) <= 1 then\n            return 1\n        end\n        return 2\n    end\n\n    method integer GetOtherCharacterIndex(integer charIndex)\n        if self:ClampCharacterIndex(charIndex) == 1 then\n            return 2\n        end\n        return 1\n    end\n\n    -- Clone helper avoids accidental shared-table mutation between character snapshots.\n    method table CloneCharacterState(table source)\n        local clone = {}\n        if source == nil then\n            return clone\n        end\n\n        for key, value in pairs(source) do\n            if type(value) == \"table\" then\n                local nested = {}\n                for key2, value2 in pairs(value) do\n                    nested[key2] = value2\n                end\n                clone[key] = nested\n            else\n                clone[key] = value\n            end\n        end\n\n        return clone\n    end\n\n    -- Movement write uses shared util path first so all authority checks stay centralized.\n    method boolean SetCanMoveSafely(boolean canMove)\n        if _GRUtil ~= nil and _GRUtil.TrySetCanMove ~= nil then\n            return _GRUtil.TrySetCanMove(self.Entity, canMove)\n        end\n\n        local movementComponent = self:ResolveComponentSafe(self.Entity, \"MovementComponent\", \"CanMove\")\n        if movementComponent == nil then\n            return false\n        end\n\n        local ok, _ = pcall(function()\n            movementComponent.CanMove = canMove\n        end)\n        return ok\n    end\n\n    -- EndPlay clears timers so tag callbacks never fire on destroyed entities.\n    @ExecSpace(\"ServerOnly\")\n    method void OnEndPlay()\n        if self._T.TagCooldownTimerId ~= nil and self._T.TagCooldownTimerId > 0 then\n            _TimerService:ClearTimer(self._T.TagCooldownTimerId)\n            self._T.TagCooldownTimerId = 0\n        end\n        if self._T.TagInvincibleTimerId ~= nil and self._T.TagInvincibleTimerId > 0 then\n            _TimerService:ClearTimer(self._T.TagInvincibleTimerId)\n            self._T.TagInvincibleTimerId = 0\n        end\n        if self._T.TagUnlockTimerId ~= nil and self._T.TagUnlockTimerId > 0 then\n            _TimerService:ClearTimer(self._T.TagUnlockTimerId)\n            self._T.TagUnlockTimerId = 0\n        end\n    end\n\n    -- Utility bootstrap first; fallback local lookup is kept for resiliency when util component is missing.\n    method void EnsureGRUtil()\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, _ = pcall(function()\n                utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    method Component ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return _GRUtil.ResolveComponent(targetEntity, scriptName, markerField)\n        end\n\n        local prefixedName = scriptName\n        local plainName = scriptName\n        if string.sub(scriptName, 1, 7) == \"script.\" then\n            plainName = string.sub(scriptName, 8)\n        else\n            prefixedName = \"script.\" .. scriptName\n        end\n\n        local component = targetEntity:GetComponent(prefixedName)\n        if component == nil then\n            component = targetEntity:GetComponent(plainName)\n        end\n        if component == nil then\n            return nil\n        end\n\n        if markerField ~= nil and markerField ~= \"\" then\n            local ok, _ = pcall(function()\n                return component[markerField]\n            end)\n            if ok == false then\n                return nil\n            end\n        end\n\n        return component\n    end\n\n    method boolean IsOwnerRequest(string requestUserId)\n        if _GRUtil ~= nil and _GRUtil.IsOwner ~= nil then\n            return _GRUtil.IsOwner(self.Entity, requestUserId)\n        end\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent == nil then\n            return true\n        end\n\n        if requestUserId == nil or requestUserId == \"\" then\n            return true\n        end\n\n        return requestUserId == playerComponent.UserId\n    end\nend\n"
    }
  }
}
