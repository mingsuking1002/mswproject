{
  "Id": "",
  "GameId": "",
  "EntryKey": "codeblock://de11516a-5904-42cc-affe-49e26dd1da70",
  "ContentType": "x-mod/codeblock",
  "Content": "",
  "Usage": 0,
  "UsePublish": 1,
  "UseService": 0,
  "CoreVersion": "26.1.0.0",
  "StudioVersion": "",
  "DynamicLoading": 0,
  "ContentProto": {
    "Use": "Json",
    "Json": {
      "CoreVersion": {
        "Major": 0,
        "Minor": 2
      },
      "ScriptVersion": {
        "Major": 1,
        "Minor": 1
      },
      "Description": "",
      "Id": "de11516a-5904-42cc-affe-49e26dd1da70",
      "Language": 1,
      "Name": "WeaponSwapComponent",
      "Type": 1,
      "Source": 1,
      "Target": "@Component\nscript WeaponSwapComponent extends Component\n\n    @Sync\n    property integer CurrentWeaponSlot = 1\n    property integer WeaponSlotCount = 4\n    @Sync\n    property boolean IsSwapMenuOpen = false\n\n    property table Weapon1_Data = {}\n    property table Weapon2_Data = {}\n    property table Weapon3_Data = {}\n    property table Weapon4_Data = {}\n\n    property boolean PauseGameplayByFlag = true\n    property boolean UseClientTimeScalePause = false\n    property boolean CancelReloadOnSwap = true\n    property integer DefaultAmmo = 30\n    property integer DefaultDamage = 10\n    property number DefaultFireCooldown = 0.5\n    property number DefaultReloadTime = 1.5\n\n    -- Server initializes deterministic slot state so tag/swap can load valid data even before first fire.\n    @ExecSpace(\"ServerOnly\")\n    method void OnInitialize()\n        self:EnsureGRUtil()\n        self.CurrentWeaponSlot = self:ClampSlot(self.CurrentWeaponSlot)\n        self:InitializeSlotData()\n        self:ApplySlotDataToCombat(self.CurrentWeaponSlot)\n    end\n\n    -- Client initializes utility and local selection cache used by radial selection input.\n    @ExecSpace(\"ClientOnly\")\n    method void OnBeginPlay()\n        self:EnsureGRUtil()\n        self._T.PendingSlotClient = self.CurrentWeaponSlot\n    end\n\n    -- F toggles the menu, ESC cancels, and direction/mouse confirm follows the radial-selection intent.\n    @EventSender(\"Service\", \"InputService\")\n    handler HandleKeyDownEvent(KeyDownEvent event)\n        local key = event.key\n\n        if key == KeyboardKey.F then\n            if self.IsSwapMenuOpen == true then\n                self:RequestCancelSwapMenuServer()\n            else\n                self:RequestOpenSwapMenuServer()\n            end\n            return\n        end\n\n        if self.IsSwapMenuOpen == false then\n            return\n        end\n\n        if key == KeyboardKey.Escape then\n            self:RequestCancelSwapMenuServer()\n            return\n        end\n\n        if key == KeyboardKey.W or key == KeyboardKey.D or key == KeyboardKey.S or key == KeyboardKey.A then\n            self._T.PendingSlotClient = self:DirectionKeyToSlot(key)\n            self:NotifySwapMenuClient(true, self._T.PendingSlotClient, self.CurrentWeaponSlot)\n            return\n        end\n\n        if key == KeyboardKey.Mouse0 or key == KeyboardKey.Space then\n            local selectedSlot = self._T.PendingSlotClient\n            if selectedSlot == nil then\n                selectedSlot = self.CurrentWeaponSlot\n            end\n            self:RequestConfirmSwapServer(selectedSlot)\n        end\n    end\n\n    -- Client-to-server request validates owner and state before opening menu.\n    @ExecSpace(\"Server\")\n    method void RequestOpenSwapMenuServer()\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n        if self:IsSwapAvailableServer() == false then\n            return\n        end\n\n        self:OpenSwapMenuServer()\n    end\n\n    -- Cancel request keeps close/resume behavior in one authoritative server path.\n    @ExecSpace(\"Server\")\n    method void RequestCancelSwapMenuServer()\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n        if self.IsSwapMenuOpen == false then\n            return\n        end\n\n        self:CloseSwapMenuServer()\n    end\n\n    -- Confirm request applies selected slot only on server to prevent client-side forced weapon changes.\n    @ExecSpace(\"Server\")\n    method void RequestConfirmSwapServer(integer selectedSlot)\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n        if self.IsSwapMenuOpen == false then\n            return\n        end\n\n        local finalSlot = self:ClampSlot(selectedSlot)\n        self:ConfirmSwapServer(finalSlot)\n    end\n\n    -- Open transition pauses gameplay logic and blocks combat/movement inputs.\n    @ExecSpace(\"ServerOnly\")\n    method void OpenSwapMenuServer()\n        if self.IsSwapMenuOpen == true then\n            return\n        end\n\n        self.IsSwapMenuOpen = true\n        self:SetGameplayLockServer(true)\n        self:NotifySwapMenuClient(true, self.CurrentWeaponSlot, self.CurrentWeaponSlot)\n    end\n\n    -- Close transition resumes gameplay and clears temporary UI state.\n    @ExecSpace(\"ServerOnly\")\n    method void CloseSwapMenuServer()\n        if self.IsSwapMenuOpen == false then\n            return\n        end\n\n        self.IsSwapMenuOpen = false\n        self:SetGameplayLockServer(false)\n        self:NotifySwapMenuClient(false, self.CurrentWeaponSlot, self.CurrentWeaponSlot)\n    end\n\n    -- Slot confirmation snapshots previous slot runtime data before loading the new slot.\n    @ExecSpace(\"ServerOnly\")\n    method void ConfirmSwapServer(integer selectedSlot)\n        if self.IsSwapMenuOpen == false then\n            return\n        end\n\n        local fromSlot = self.CurrentWeaponSlot\n        local toSlot = self:ClampSlot(selectedSlot)\n\n        self:CaptureRuntimeToSlot(fromSlot)\n        self.CurrentWeaponSlot = toSlot\n        self:ApplySlotDataToCombat(toSlot)\n        self:CloseSwapMenuServer()\n    end\n\n    -- Swap availability gate centralizes death/lock checks for consistent UX.\n    @ExecSpace(\"ServerOnly\")\n    method boolean IsSwapAvailableServer()\n        if self.Entity == nil or isvalid(self.Entity) == false then\n            return false\n        end\n        if self.IsSwapMenuOpen == true then\n            return false\n        end\n\n        local hpComponent = self:ResolveComponentSafe(self.Entity, \"HPSystemComponent\", \"IsDead\")\n        if hpComponent ~= nil then\n            local deadOk, isDead = pcall(function()\n                return hpComponent.IsDead\n            end)\n            if deadOk == true and isDead == true then\n                return false\n            end\n        end\n\n        local tagManager = self:ResolveComponentSafe(self.Entity, \"TagManagerComponent\", \"IsTagLocked\")\n        if tagManager ~= nil then\n            local lockOk, isLocked = pcall(function()\n                return tagManager.IsTagLocked\n            end)\n            if lockOk == true and isLocked == true then\n                return false\n            end\n        end\n\n        return true\n    end\n\n    -- Slot data is initialized once so all slot read/write paths can assume schema presence.\n    @ExecSpace(\"ServerOnly\")\n    method void InitializeSlotData()\n        self.Weapon1_Data = self:NormalizeSlotData(self.Weapon1_Data, 1)\n        self.Weapon2_Data = self:NormalizeSlotData(self.Weapon2_Data, 2)\n        self.Weapon3_Data = self:NormalizeSlotData(self.Weapon3_Data, 3)\n        self.Weapon4_Data = self:NormalizeSlotData(self.Weapon4_Data, 4)\n    end\n\n    -- Data normalization prevents missing fields from older save/state payloads.\n    method table NormalizeSlotData(table source, integer slot)\n        local data = source\n        if data == nil then\n            data = {}\n        end\n\n        if data.WeaponId == nil or data.WeaponId == \"\" then\n            data.WeaponId = \"Weapon\" .. tostring(slot)\n        end\n        if data.Ammo == nil then\n            data.Ammo = self.DefaultAmmo\n        end\n        if data.IsReloading == nil then\n            data.IsReloading = false\n        end\n        if data.Damage == nil then\n            data.Damage = self.DefaultDamage\n        end\n        if data.FireCooldown == nil then\n            data.FireCooldown = self.DefaultFireCooldown\n        end\n        if data.ReloadTime == nil then\n            data.ReloadTime = self.DefaultReloadTime\n        end\n        if data.ProjectileSpeed == nil then\n            data.ProjectileSpeed = 20\n        end\n        if data.ProjectileRange == nil then\n            data.ProjectileRange = 15\n        end\n        if data.ProjectileLifetime == nil then\n            data.ProjectileLifetime = 2\n        end\n        if data.ProjectileSpread == nil then\n            data.ProjectileSpread = 0\n        end\n        if data.ProjectileModelId == nil then\n            data.ProjectileModelId = \"\"\n        end\n\n        return data\n    end\n\n    -- Runtime snapshot keeps ammo/cooldown values synchronized into slot state before switching away.\n    @ExecSpace(\"ServerOnly\")\n    method void CaptureRuntimeToSlot(integer slot)\n        local finalSlot = self:ClampSlot(slot)\n        local data = self:GetSlotDataBySlot(finalSlot)\n        data = self:NormalizeSlotData(data, finalSlot)\n\n        local reloadComponent = self:ResolveComponentSafe(self.Entity, \"ReloadComponent\", \"CurrentAmmo\")\n        if reloadComponent ~= nil then\n            local ammoValue = data.Ammo\n            local ammoOk, ammoResult = pcall(function()\n                return reloadComponent:GetSlotAmmo(finalSlot)\n            end)\n            if ammoOk == true and ammoResult ~= nil then\n                ammoValue = ammoResult\n            end\n            data.Ammo = math.max(0, math.floor(ammoValue))\n\n            local reloadOk, reloadState = pcall(function()\n                return reloadComponent.IsReloading\n            end)\n            if reloadOk == true then\n                data.IsReloading = reloadState\n            end\n        end\n\n        local fireComponent = self:ResolveComponentSafe(self.Entity, \"FireSystemComponent\", \"BaseWeaponAttack\")\n        if fireComponent ~= nil then\n            local damageOk, damageValue = pcall(function()\n                return fireComponent.BaseWeaponAttack\n            end)\n            if damageOk == true and damageValue ~= nil then\n                data.Damage = math.max(0, math.floor(damageValue))\n            end\n\n            local cooldownOk, cooldownValue = pcall(function()\n                return fireComponent.FireCooldown\n            end)\n            if cooldownOk == true and cooldownValue ~= nil then\n                data.FireCooldown = math.max(0, cooldownValue)\n            end\n\n            local speedOk, speedValue = pcall(function()\n                return fireComponent.ProjectileSpeed\n            end)\n            if speedOk == true and speedValue ~= nil then\n                data.ProjectileSpeed = speedValue\n            end\n\n            local rangeOk, rangeValue = pcall(function()\n                return fireComponent.ProjectileRange\n            end)\n            if rangeOk == true and rangeValue ~= nil then\n                data.ProjectileRange = rangeValue\n            end\n\n            local lifeOk, lifeValue = pcall(function()\n                return fireComponent.ProjectileLifetime\n            end)\n            if lifeOk == true and lifeValue ~= nil then\n                data.ProjectileLifetime = lifeValue\n            end\n\n            local spreadOk, spreadValue = pcall(function()\n                return fireComponent.ProjectileSpread\n            end)\n            if spreadOk == true and spreadValue ~= nil then\n                data.ProjectileSpread = spreadValue\n            end\n\n            local modelOk, modelValue = pcall(function()\n                return fireComponent.ProjectileModelId\n            end)\n            if modelOk == true and modelValue ~= nil then\n                data.ProjectileModelId = modelValue\n            end\n        end\n\n        self:SetSlotDataBySlot(finalSlot, data)\n    end\n\n    -- Applying slot data routes through Reload/Fire so all downstream combat logic uses one source of truth.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplySlotDataToCombat(integer slot)\n        local finalSlot = self:ClampSlot(slot)\n        local data = self:NormalizeSlotData(self:GetSlotDataBySlot(finalSlot), finalSlot)\n        self:SetSlotDataBySlot(finalSlot, data)\n\n        local reloadComponent = self:ResolveComponentSafe(self.Entity, \"ReloadComponent\", \"CurrentAmmo\")\n        if reloadComponent ~= nil then\n            if self.CancelReloadOnSwap == true then\n                pcall(function()\n                    reloadComponent:CancelCurrentReload()\n                end)\n            end\n\n            pcall(function()\n                reloadComponent:SetCurrentWeaponSlot(finalSlot)\n            end)\n            pcall(function()\n                reloadComponent:SetSlotAmmo(finalSlot, data.Ammo)\n            end)\n            pcall(function()\n                reloadComponent.ReloadTime = data.ReloadTime\n            end)\n            pcall(function()\n                reloadComponent.FireRate = data.FireCooldown\n            end)\n        end\n\n        local fireComponent = self:ResolveComponentSafe(self.Entity, \"FireSystemComponent\", \"BaseWeaponAttack\")\n        if fireComponent ~= nil then\n            pcall(function()\n                fireComponent.BaseWeaponAttack = data.Damage\n            end)\n            pcall(function()\n                fireComponent.FireCooldown = data.FireCooldown\n            end)\n            pcall(function()\n                fireComponent.ProjectileSpeed = data.ProjectileSpeed\n            end)\n            pcall(function()\n                fireComponent.ProjectileRange = data.ProjectileRange\n            end)\n            pcall(function()\n                fireComponent.ProjectileLifetime = data.ProjectileLifetime\n            end)\n            pcall(function()\n                fireComponent.ProjectileSpread = data.ProjectileSpread\n            end)\n            pcall(function()\n                fireComponent.ProjectileModelId = data.ProjectileModelId\n            end)\n        end\n\n        self:NotifySwapMenuClient(self.IsSwapMenuOpen, finalSlot, self.CurrentWeaponSlot)\n    end\n\n    -- Export API is consumed by TagManager so each character can preserve independent 4-slot state.\n    @ExecSpace(\"ServerOnly\")\n    method table ExportWeaponSwapState()\n        self:CaptureRuntimeToSlot(self.CurrentWeaponSlot)\n\n        local state = {}\n        state.CurrentWeaponSlot = self.CurrentWeaponSlot\n        state.Weapon1_Data = self:CloneSlotData(self.Weapon1_Data)\n        state.Weapon2_Data = self:CloneSlotData(self.Weapon2_Data)\n        state.Weapon3_Data = self:CloneSlotData(self.Weapon3_Data)\n        state.Weapon4_Data = self:CloneSlotData(self.Weapon4_Data)\n        return state\n    end\n\n    -- Import API restores previously saved per-character weapon state and reapplies combat parameters.\n    @ExecSpace(\"ServerOnly\")\n    method void ImportWeaponSwapState(table state)\n        if state == nil then\n            return\n        end\n\n        if state.Weapon1_Data ~= nil then\n            self.Weapon1_Data = self:NormalizeSlotData(self:CloneSlotData(state.Weapon1_Data), 1)\n        end\n        if state.Weapon2_Data ~= nil then\n            self.Weapon2_Data = self:NormalizeSlotData(self:CloneSlotData(state.Weapon2_Data), 2)\n        end\n        if state.Weapon3_Data ~= nil then\n            self.Weapon3_Data = self:NormalizeSlotData(self:CloneSlotData(state.Weapon3_Data), 3)\n        end\n        if state.Weapon4_Data ~= nil then\n            self.Weapon4_Data = self:NormalizeSlotData(self:CloneSlotData(state.Weapon4_Data), 4)\n        end\n\n        if state.CurrentWeaponSlot ~= nil then\n            self.CurrentWeaponSlot = self:ClampSlot(state.CurrentWeaponSlot)\n        end\n\n        self:ApplySlotDataToCombat(self.CurrentWeaponSlot)\n    end\n\n    -- Gameplay lock toggles movement, attack, and timer pause in one place for open/close consistency.\n    @ExecSpace(\"ServerOnly\")\n    method void SetGameplayLockServer(boolean locked)\n        self:SetCanMoveSafely(not locked)\n        self:SetCanAttackSafely(not locked)\n\n        local timerComponent = self:ResolveComponentSafe(self.Entity, \"SpeedrunTimerComponent\", \"IsRunning\")\n        if timerComponent ~= nil and timerComponent.SetPauseSource ~= nil and self.PauseGameplayByFlag == true then\n            pcall(function()\n                timerComponent:SetPauseSource(\"WeaponSwap\", locked)\n            end)\n        end\n\n        if self.UseClientTimeScalePause == true then\n            if locked == true then\n                self:ApplyClientTimeScale(0)\n            else\n                self:ApplyClientTimeScale(1)\n            end\n        end\n    end\n\n    -- Client-only time scale branch is optional fallback when project chooses visual time-stop over logic pause.\n    @ExecSpace(\"Client\")\n    method void ApplyClientTimeScale(number scale)\n        local targetScale = scale\n        if targetScale \u003c 0 then\n            targetScale = 0\n        end\n        if targetScale \u003e 1 then\n            targetScale = 1\n        end\n\n        pcall(function()\n            _UtilLogic:SetClientTimeScale(targetScale)\n        end)\n    end\n\n    -- UI callback is isolated so Phase 4 wheel implementation can attach without changing server flow.\n    @ExecSpace(\"Client\")\n    method void NotifySwapMenuClient(boolean visible, integer highlightedSlot, integer currentSlot)\n        self._T.PendingSlotClient = highlightedSlot\n\n        local wheelComponent = self:ResolveComponentSafe(self.Entity, \"WeaponWheelUIComponent\", nil)\n        if wheelComponent ~= nil and wheelComponent.ApplyWeaponWheelStateClient ~= nil then\n            pcall(function()\n                wheelComponent:ApplyWeaponWheelStateClient(visible, highlightedSlot, currentSlot)\n            end)\n        end\n    end\n\n    -- Direction mapping follows the radial layout (W up, D right, S down, A left).\n    method integer DirectionKeyToSlot(KeyboardKey key)\n        if key == KeyboardKey.W then\n            return 1\n        end\n        if key == KeyboardKey.D then\n            return 2\n        end\n        if key == KeyboardKey.S then\n            return 3\n        end\n        if key == KeyboardKey.A then\n            return 4\n        end\n\n        return self.CurrentWeaponSlot\n    end\n\n    method integer ClampSlot(integer slot)\n        local maxSlot = math.max(self.WeaponSlotCount, 1)\n        local value = math.floor(slot)\n        if value \u003c 1 then\n            return 1\n        end\n        if value \u003e maxSlot then\n            return maxSlot\n        end\n        return value\n    end\n\n    method table GetSlotDataBySlot(integer slot)\n        local finalSlot = self:ClampSlot(slot)\n        if finalSlot == 1 then\n            return self.Weapon1_Data\n        elseif finalSlot == 2 then\n            return self.Weapon2_Data\n        elseif finalSlot == 3 then\n            return self.Weapon3_Data\n        end\n        return self.Weapon4_Data\n    end\n\n    method void SetSlotDataBySlot(integer slot, table data)\n        local finalSlot = self:ClampSlot(slot)\n        if finalSlot == 1 then\n            self.Weapon1_Data = data\n        elseif finalSlot == 2 then\n            self.Weapon2_Data = data\n        elseif finalSlot == 3 then\n            self.Weapon3_Data = data\n        else\n            self.Weapon4_Data = data\n        end\n    end\n\n    -- Clone utility avoids reference sharing between slots and tag character snapshots.\n    method table CloneSlotData(table source)\n        local clone = {}\n        if source == nil then\n            return clone\n        end\n\n        for key, value in pairs(source) do\n            clone[key] = value\n        end\n        return clone\n    end\n\n    -- Movement lock uses shared util path first to keep cross-component write policy centralized.\n    method boolean SetCanMoveSafely(boolean canMove)\n        if _GRUtil ~= nil and _GRUtil.TrySetCanMove ~= nil then\n            return _GRUtil.TrySetCanMove(self.Entity, canMove)\n        end\n\n        local movementComponent = self:ResolveComponentSafe(self.Entity, \"MovementComponent\", \"CanMove\")\n        if movementComponent == nil then\n            return false\n        end\n\n        local ok, _ = pcall(function()\n            movementComponent.CanMove = canMove\n        end)\n        return ok\n    end\n\n    -- Attack lock follows the same safe-write strategy to avoid hard failures on missing components.\n    method boolean SetCanAttackSafely(boolean canAttack)\n        local fireComponent = self:ResolveComponentSafe(self.Entity, \"FireSystemComponent\", \"CanAttack\")\n        if fireComponent == nil then\n            return false\n        end\n\n        if _GRUtil ~= nil and _GRUtil.TrySetField ~= nil then\n            return _GRUtil.TrySetField(fireComponent, \"CanAttack\", canAttack)\n        end\n\n        local ok, _ = pcall(function()\n            fireComponent.CanAttack = canAttack\n        end)\n        return ok\n    end\n\n    -- EndPlay restores menu side effects so entity reuse never keeps pause/lock states.\n    @ExecSpace(\"ServerOnly\")\n    method void OnEndPlay()\n        if self.IsSwapMenuOpen == true then\n            self:CloseSwapMenuServer()\n        end\n    end\n\n    -- Utility bootstrap first; fallback path keeps local safe lookup when global utility is absent.\n    method void EnsureGRUtil()\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, _ = pcall(function()\n                utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    method Component ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return _GRUtil.ResolveComponent(targetEntity, scriptName, markerField)\n        end\n\n        local prefixedName = scriptName\n        local plainName = scriptName\n        if string.sub(scriptName, 1, 7) == \"script.\" then\n            plainName = string.sub(scriptName, 8)\n        else\n            prefixedName = \"script.\" .. scriptName\n        end\n\n        local component = targetEntity:GetComponent(prefixedName)\n        if component == nil then\n            component = targetEntity:GetComponent(plainName)\n        end\n        if component == nil then\n            return nil\n        end\n\n        if markerField ~= nil and markerField ~= \"\" then\n            local ok, _ = pcall(function()\n                return component[markerField]\n            end)\n            if ok == false then\n                return nil\n            end\n        end\n\n        return component\n    end\n\n    method boolean IsOwnerRequest(string requestUserId)\n        if _GRUtil ~= nil and _GRUtil.IsOwner ~= nil then\n            return _GRUtil.IsOwner(self.Entity, requestUserId)\n        end\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent == nil then\n            return true\n        end\n\n        if requestUserId == nil or requestUserId == \"\" then\n            return true\n        end\n\n        return requestUserId == playerComponent.UserId\n    end\nend\n"ServerOnly\")\n    method void OnInitialize()\n        self:EnsureGRUtil()\n        self.CurrentWeaponSlot = self:ClampSlot(self.CurrentWeaponSlot)\n        self:InitializeSlotData()\n        self:ApplySlotDataToCombat(self.CurrentWeaponSlot)\n    end\n\n    -- Client initializes utility and local selection cache used by radial selection input.\n    @ExecSpace(\"ClientOnly\")\n    method void OnBeginPlay()\n        self:EnsureGRUtil()\n        self._T.PendingSlotClient = self.CurrentWeaponSlot\n    end\n\n    -- F toggles the menu, ESC cancels, and direction/mouse confirm follows the radial-selection intent.\n    @EventSender(\"Service\", \"InputService\")\n    handler HandleKeyDownEvent(KeyDownEvent event)\n        local key = event.key\n\n        if key == KeyboardKey.F then\n            if self.IsSwapMenuOpen == true then\n                self:RequestCancelSwapMenuServer()\n            else\n                self:RequestOpenSwapMenuServer()\n            end\n            return\n        end\n\n        if self.IsSwapMenuOpen == false then\n            return\n        end\n\n        if key == KeyboardKey.Escape then\n            self:RequestCancelSwapMenuServer()\n            return\n        end\n\n        if key == KeyboardKey.W or key == KeyboardKey.D or key == KeyboardKey.S or key == KeyboardKey.A then\n            self._T.PendingSlotClient = self:DirectionKeyToSlot(key)\n            self:NotifySwapMenuClient(true, self._T.PendingSlotClient, self.CurrentWeaponSlot)\n            return\n        end\n\n        if key == KeyboardKey.Mouse0 or key == KeyboardKey.Space then\n            local selectedSlot = self._T.PendingSlotClient\n            if selectedSlot == nil then\n                selectedSlot = self.CurrentWeaponSlot\n            end\n            self:RequestConfirmSwapServer(selectedSlot)\n        end\n    end\n\n    -- Client-to-server request validates owner and state before opening menu.\n    @ExecSpace(\"Server\")\n    method void RequestOpenSwapMenuServer()\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n        if self:IsSwapAvailableServer() == false then\n            return\n        end\n\n        self:OpenSwapMenuServer()\n    end\n\n    -- Cancel request keeps close/resume behavior in one authoritative server path.\n    @ExecSpace(\"Server\")\n    method void RequestCancelSwapMenuServer()\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n        if self.IsSwapMenuOpen == false then\n            return\n        end\n\n        self:CloseSwapMenuServer()\n    end\n\n    -- Confirm request applies selected slot only on server to prevent client-side forced weapon changes.\n    @ExecSpace(\"Server\")\n    method void RequestConfirmSwapServer(integer selectedSlot)\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n        if self.IsSwapMenuOpen == false then\n            return\n        end\n\n        local finalSlot = self:ClampSlot(selectedSlot)\n        self:ConfirmSwapServer(finalSlot)\n    end\n\n    -- Open transition pauses gameplay logic and blocks combat/movement inputs.\n    @ExecSpace(\"ServerOnly\")\n    method void OpenSwapMenuServer()\n        if self.IsSwapMenuOpen == true then\n            return\n        end\n\n        self.IsSwapMenuOpen = true\n        self:SetGameplayLockServer(true)\n        self:NotifySwapMenuClient(true, self.CurrentWeaponSlot, self.CurrentWeaponSlot)\n    end\n\n    -- Close transition resumes gameplay and clears temporary UI state.\n    @ExecSpace(\"ServerOnly\")\n    method void CloseSwapMenuServer()\n        if self.IsSwapMenuOpen == false then\n            return\n        end\n\n        self.IsSwapMenuOpen = false\n        self:SetGameplayLockServer(false)\n        self:NotifySwapMenuClient(false, self.CurrentWeaponSlot, self.CurrentWeaponSlot)\n    end\n\n    -- Slot confirmation snapshots previous slot runtime data before loading the new slot.\n    @ExecSpace(\"ServerOnly\")\n    method void ConfirmSwapServer(integer selectedSlot)\n        if self.IsSwapMenuOpen == false then\n            return\n        end\n\n        local fromSlot = self.CurrentWeaponSlot\n        local toSlot = self:ClampSlot(selectedSlot)\n\n        self:CaptureRuntimeToSlot(fromSlot)\n        self.CurrentWeaponSlot = toSlot\n        self:ApplySlotDataToCombat(toSlot)\n        self:CloseSwapMenuServer()\n    end\n\n    -- Swap availability gate centralizes death/lock checks for consistent UX.\n    @ExecSpace(\"ServerOnly\")\n    method boolean IsSwapAvailableServer()\n        if self.Entity == nil or isvalid(self.Entity) == false then\n            return false\n        end\n        if self.IsSwapMenuOpen == true then\n            return false\n        end\n\n        local hpComponent = self:ResolveComponentSafe(self.Entity, \"HPSystemComponent\", \"IsDead\")\n        if hpComponent ~= nil then\n            local deadOk, isDead = pcall(function()\n                return hpComponent.IsDead\n            end)\n            if deadOk == true and isDead == true then\n                return false\n            end\n        end\n\n        local tagManager = self:ResolveComponentSafe(self.Entity, \"TagManagerComponent\", \"IsTagLocked\")\n        if tagManager ~= nil then\n            local lockOk, isLocked = pcall(function()\n                return tagManager.IsTagLocked\n            end)\n            if lockOk == true and isLocked == true then\n                return false\n            end\n        end\n\n        return true\n    end\n\n    -- Slot data is initialized once so all slot read/write paths can assume schema presence.\n    @ExecSpace(\"ServerOnly\")\n    method void InitializeSlotData()\n        self.Weapon1_Data = self:NormalizeSlotData(self.Weapon1_Data, 1)\n        self.Weapon2_Data = self:NormalizeSlotData(self.Weapon2_Data, 2)\n        self.Weapon3_Data = self:NormalizeSlotData(self.Weapon3_Data, 3)\n        self.Weapon4_Data = self:NormalizeSlotData(self.Weapon4_Data, 4)\n    end\n\n    -- Data normalization prevents missing fields from older save/state payloads.\n    method table NormalizeSlotData(table source, integer slot)\n        local data = source\n        if data == nil then\n            data = {}\n        end\n\n        if data.WeaponId == nil or data.WeaponId == \"\" then\n            data.WeaponId = \"Weapon\" .. tostring(slot)\n        end\n        if data.Ammo == nil then\n            data.Ammo = self.DefaultAmmo\n        end\n        if data.IsReloading == nil then\n            data.IsReloading = false\n        end\n        if data.Damage == nil then\n            data.Damage = self.DefaultDamage\n        end\n        if data.FireCooldown == nil then\n            data.FireCooldown = self.DefaultFireCooldown\n        end\n        if data.ReloadTime == nil then\n            data.ReloadTime = self.DefaultReloadTime\n        end\n        if data.ProjectileSpeed == nil then\n            data.ProjectileSpeed = 20\n        end\n        if data.ProjectileRange == nil then\n            data.ProjectileRange = 15\n        end\n        if data.ProjectileLifetime == nil then\n            data.ProjectileLifetime = 2\n        end\n        if data.ProjectileSpread == nil then\n            data.ProjectileSpread = 0\n        end\n        if data.ProjectileModelId == nil then\n            data.ProjectileModelId = \"\"\n        end\n\n        return data\n    end\n\n    -- Runtime snapshot keeps ammo/cooldown values synchronized into slot state before switching away.\n    @ExecSpace(\"ServerOnly\")\n    method void CaptureRuntimeToSlot(integer slot)\n        local finalSlot = self:ClampSlot(slot)\n        local data = self:GetSlotDataBySlot(finalSlot)\n        data = self:NormalizeSlotData(data, finalSlot)\n\n        local reloadComponent = self:ResolveComponentSafe(self.Entity, \"ReloadComponent\", \"CurrentAmmo\")\n        if reloadComponent ~= nil then\n            local ammoValue = data.Ammo\n            local ammoOk, ammoResult = pcall(function()\n                return reloadComponent:GetSlotAmmo(finalSlot)\n            end)\n            if ammoOk == true and ammoResult ~= nil then\n                ammoValue = ammoResult\n            end\n            data.Ammo = math.max(0, math.floor(ammoValue))\n\n            local reloadOk, reloadState = pcall(function()\n                return reloadComponent.IsReloading\n            end)\n            if reloadOk == true then\n                data.IsReloading = reloadState\n            end\n        end\n\n        local fireComponent = self:ResolveComponentSafe(self.Entity, \"FireSystemComponent\", \"BaseWeaponAttack\")\n        if fireComponent ~= nil then\n            local damageOk, damageValue = pcall(function()\n                return fireComponent.BaseWeaponAttack\n            end)\n            if damageOk == true and damageValue ~= nil then\n                data.Damage = math.max(0, math.floor(damageValue))\n            end\n\n            local cooldownOk, cooldownValue = pcall(function()\n                return fireComponent.FireCooldown\n            end)\n            if cooldownOk == true and cooldownValue ~= nil then\n                data.FireCooldown = math.max(0, cooldownValue)\n            end\n\n            local speedOk, speedValue = pcall(function()\n                return fireComponent.ProjectileSpeed\n            end)\n            if speedOk == true and speedValue ~= nil then\n                data.ProjectileSpeed = speedValue\n            end\n\n            local rangeOk, rangeValue = pcall(function()\n                return fireComponent.ProjectileRange\n            end)\n            if rangeOk == true and rangeValue ~= nil then\n                data.ProjectileRange = rangeValue\n            end\n\n            local lifeOk, lifeValue = pcall(function()\n                return fireComponent.ProjectileLifetime\n            end)\n            if lifeOk == true and lifeValue ~= nil then\n                data.ProjectileLifetime = lifeValue\n            end\n\n            local spreadOk, spreadValue = pcall(function()\n                return fireComponent.ProjectileSpread\n            end)\n            if spreadOk == true and spreadValue ~= nil then\n                data.ProjectileSpread = spreadValue\n            end\n\n            local modelOk, modelValue = pcall(function()\n                return fireComponent.ProjectileModelId\n            end)\n            if modelOk == true and modelValue ~= nil then\n                data.ProjectileModelId = modelValue\n            end\n        end\n\n        self:SetSlotDataBySlot(finalSlot, data)\n    end\n\n    -- Applying slot data routes through Reload/Fire so all downstream combat logic uses one source of truth.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplySlotDataToCombat(integer slot)\n        local finalSlot = self:ClampSlot(slot)\n        local data = self:NormalizeSlotData(self:GetSlotDataBySlot(finalSlot), finalSlot)\n        self:SetSlotDataBySlot(finalSlot, data)\n\n        local reloadComponent = self:ResolveComponentSafe(self.Entity, \"ReloadComponent\", \"CurrentAmmo\")\n        if reloadComponent ~= nil then\n            if self.CancelReloadOnSwap == true then\n                pcall(function()\n                    reloadComponent:CancelCurrentReload()\n                end)\n            end\n\n            pcall(function()\n                reloadComponent:SetCurrentWeaponSlot(finalSlot)\n            end)\n            pcall(function()\n                reloadComponent:SetSlotAmmo(finalSlot, data.Ammo)\n            end)\n            pcall(function()\n                reloadComponent.ReloadTime = data.ReloadTime\n            end)\n            pcall(function()\n                reloadComponent.FireRate = data.FireCooldown\n            end)\n        end\n\n        local fireComponent = self:ResolveComponentSafe(self.Entity, \"FireSystemComponent\", \"BaseWeaponAttack\")\n        if fireComponent ~= nil then\n            pcall(function()\n                fireComponent.BaseWeaponAttack = data.Damage\n            end)\n            pcall(function()\n                fireComponent.FireCooldown = data.FireCooldown\n            end)\n            pcall(function()\n                fireComponent.ProjectileSpeed = data.ProjectileSpeed\n            end)\n            pcall(function()\n                fireComponent.ProjectileRange = data.ProjectileRange\n            end)\n            pcall(function()\n                fireComponent.ProjectileLifetime = data.ProjectileLifetime\n            end)\n            pcall(function()\n                fireComponent.ProjectileSpread = data.ProjectileSpread\n            end)\n            pcall(function()\n                fireComponent.ProjectileModelId = data.ProjectileModelId\n            end)\n        end\n\n        self:NotifySwapMenuClient(self.IsSwapMenuOpen, finalSlot, self.CurrentWeaponSlot)\n    end\n\n    -- Export API is consumed by TagManager so each character can preserve independent 4-slot state.\n    @ExecSpace(\"ServerOnly\")\n    method table ExportWeaponSwapState()\n        self:CaptureRuntimeToSlot(self.CurrentWeaponSlot)\n\n        local state = {}\n        state.CurrentWeaponSlot = self.CurrentWeaponSlot\n        state.Weapon1_Data = self:CloneSlotData(self.Weapon1_Data)\n        state.Weapon2_Data = self:CloneSlotData(self.Weapon2_Data)\n        state.Weapon3_Data = self:CloneSlotData(self.Weapon3_Data)\n        state.Weapon4_Data = self:CloneSlotData(self.Weapon4_Data)\n        return state\n    end\n\n    -- Import API restores previously saved per-character weapon state and reapplies combat parameters.\n    @ExecSpace(\"ServerOnly\")\n    method void ImportWeaponSwapState(table state)\n        if state == nil then\n            return\n        end\n\n        if state.Weapon1_Data ~= nil then\n            self.Weapon1_Data = self:NormalizeSlotData(self:CloneSlotData(state.Weapon1_Data), 1)\n        end\n        if state.Weapon2_Data ~= nil then\n            self.Weapon2_Data = self:NormalizeSlotData(self:CloneSlotData(state.Weapon2_Data), 2)\n        end\n        if state.Weapon3_Data ~= nil then\n            self.Weapon3_Data = self:NormalizeSlotData(self:CloneSlotData(state.Weapon3_Data), 3)\n        end\n        if state.Weapon4_Data ~= nil then\n            self.Weapon4_Data = self:NormalizeSlotData(self:CloneSlotData(state.Weapon4_Data), 4)\n        end\n\n        if state.CurrentWeaponSlot ~= nil then\n            self.CurrentWeaponSlot = self:ClampSlot(state.CurrentWeaponSlot)\n        end\n\n        self:ApplySlotDataToCombat(self.CurrentWeaponSlot)\n    end\n\n    -- Gameplay lock toggles movement, attack, and timer pause in one place for open/close consistency.\n    @ExecSpace(\"ServerOnly\")\n    method void SetGameplayLockServer(boolean locked)\n        self:SetCanMoveSafely(not locked)\n        self:SetCanAttackSafely(not locked)\n\n        local timerComponent = self:ResolveComponentSafe(self.Entity, \"SpeedrunTimerComponent\", \"IsRunning\")\n        if timerComponent ~= nil and timerComponent.SetPauseSource ~= nil and self.PauseGameplayByFlag == true then\n            pcall(function()\n                timerComponent:SetPauseSource(\"WeaponSwap\", locked)\n            end)\n        end\n\n        if self.UseClientTimeScalePause == true then\n            if locked == true then\n                self:ApplyClientTimeScale(0)\n            else\n                self:ApplyClientTimeScale(1)\n            end\n        end\n    end\n\n    -- Client-only time scale branch is optional fallback when project chooses visual time-stop over logic pause.\n    @ExecSpace(\"Client\")\n    method void ApplyClientTimeScale(number scale)\n        local targetScale = scale\n        if targetScale < 0 then\n            targetScale = 0\n        end\n        if targetScale > 1 then\n            targetScale = 1\n        end\n\n        pcall(function()\n            _UtilLogic:SetClientTimeScale(targetScale)\n        end)\n    end\n\n    -- UI callback is isolated so Phase 4 wheel implementation can attach without changing server flow.\n    @ExecSpace(\"Client\")\n    method void NotifySwapMenuClient(boolean visible, integer highlightedSlot, integer currentSlot)\n        self._T.PendingSlotClient = highlightedSlot\n\n        local wheelComponent = self:ResolveComponentSafe(self.Entity, \"WeaponWheelUIComponent\", nil)\n        if wheelComponent ~= nil and wheelComponent.ApplyWeaponWheelStateClient ~= nil then\n            pcall(function()\n                wheelComponent:ApplyWeaponWheelStateClient(visible, highlightedSlot, currentSlot)\n            end)\n        end\n    end\n\n    -- Direction mapping follows the radial layout (W up, D right, S down, A left).\n    method integer DirectionKeyToSlot(KeyboardKey key)\n        if key == KeyboardKey.W then\n            return 1\n        end\n        if key == KeyboardKey.D then\n            return 2\n        end\n        if key == KeyboardKey.S then\n            return 3\n        end\n        if key == KeyboardKey.A then\n            return 4\n        end\n\n        return self.CurrentWeaponSlot\n    end\n\n    method integer ClampSlot(integer slot)\n        local maxSlot = math.max(self.WeaponSlotCount, 1)\n        local value = math.floor(slot)\n        if value < 1 then\n            return 1\n        end\n        if value > maxSlot then\n            return maxSlot\n        end\n        return value\n    end\n\n    method table GetSlotDataBySlot(integer slot)\n        local finalSlot = self:ClampSlot(slot)\n        if finalSlot == 1 then\n            return self.Weapon1_Data\n        elseif finalSlot == 2 then\n            return self.Weapon2_Data\n        elseif finalSlot == 3 then\n            return self.Weapon3_Data\n        end\n        return self.Weapon4_Data\n    end\n\n    method void SetSlotDataBySlot(integer slot, table data)\n        local finalSlot = self:ClampSlot(slot)\n        if finalSlot == 1 then\n            self.Weapon1_Data = data\n        elseif finalSlot == 2 then\n            self.Weapon2_Data = data\n        elseif finalSlot == 3 then\n            self.Weapon3_Data = data\n        else\n            self.Weapon4_Data = data\n        end\n    end\n\n    -- Clone utility avoids reference sharing between slots and tag character snapshots.\n    method table CloneSlotData(table source)\n        local clone = {}\n        if source == nil then\n            return clone\n        end\n\n        for key, value in pairs(source) do\n            clone[key] = value\n        end\n        return clone\n    end\n\n    -- Movement lock uses shared util path first to keep cross-component write policy centralized.\n    method boolean SetCanMoveSafely(boolean canMove)\n        if _GRUtil ~= nil and _GRUtil.TrySetCanMove ~= nil then\n            return _GRUtil.TrySetCanMove(self.Entity, canMove)\n        end\n\n        local movementComponent = self:ResolveComponentSafe(self.Entity, \"MovementComponent\", \"CanMove\")\n        if movementComponent == nil then\n            return false\n        end\n\n        local ok, _ = pcall(function()\n            movementComponent.CanMove = canMove\n        end)\n        return ok\n    end\n\n    -- Attack lock follows the same safe-write strategy to avoid hard failures on missing components.\n    method boolean SetCanAttackSafely(boolean canAttack)\n        local fireComponent = self:ResolveComponentSafe(self.Entity, \"FireSystemComponent\", \"CanAttack\")\n        if fireComponent == nil then\n            return false\n        end\n\n        if _GRUtil ~= nil and _GRUtil.TrySetField ~= nil then\n            return _GRUtil.TrySetField(fireComponent, \"CanAttack\", canAttack)\n        end\n\n        local ok, _ = pcall(function()\n            fireComponent.CanAttack = canAttack\n        end)\n        return ok\n    end\n\n    -- EndPlay restores menu side effects so entity reuse never keeps pause/lock states.\n    @ExecSpace(\"ServerOnly\")\n    method void OnEndPlay()\n        if self.IsSwapMenuOpen == true then\n            self:CloseSwapMenuServer()\n        end\n    end\n\n    -- Utility bootstrap first; fallback path keeps local safe lookup when global utility is absent.\n    method void EnsureGRUtil()\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, _ = pcall(function()\n                utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    method Component ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return _GRUtil.ResolveComponent(targetEntity, scriptName, markerField)\n        end\n\n        local prefixedName = scriptName\n        local plainName = scriptName\n        if string.sub(scriptName, 1, 7) == \"script.\" then\n            plainName = string.sub(scriptName, 8)\n        else\n            prefixedName = \"script.\" .. scriptName\n        end\n\n        local component = targetEntity:GetComponent(prefixedName)\n        if component == nil then\n            component = targetEntity:GetComponent(plainName)\n        end\n        if component == nil then\n            return nil\n        end\n\n        if markerField ~= nil and markerField ~= \"\" then\n            local ok, _ = pcall(function()\n                return component[markerField]\n            end)\n            if ok == false then\n                return nil\n            end\n        end\n\n        return component\n    end\n\n    method boolean IsOwnerRequest(string requestUserId)\n        if _GRUtil ~= nil and _GRUtil.IsOwner ~= nil then\n            return _GRUtil.IsOwner(self.Entity, requestUserId)\n        end\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent == nil then\n            return true\n        end\n\n        if requestUserId == nil or requestUserId == \"\" then\n            return true\n        end\n\n        return requestUserId == playerComponent.UserId\n    end\nend\n"
    }
  }
}
