{
  "Id": "",
  "GameId": "",
  "EntryKey": "codeblock://0ab83961-9d57-4977-8220-81e42efc7c8a",
  "ContentType": "x-mod/codeblock",
  "Content": "",
  "Usage": 0,
  "UsePublish": 1,
  "UseService": 0,
  "CoreVersion": "26.1.0.0",
  "StudioVersion": "",
  "DynamicLoading": 0,
  "ContentProto": {
    "Use": "Json",
    "Json": {
      "CoreVersion": {
        "Major": 0,
        "Minor": 2
      },
      "ScriptVersion": {
        "Major": 1,
        "Minor": 1
      },
      "Description": "",
      "Id": "0ab83961-9d57-4977-8220-81e42efc7c8a",
      "Language": 1,
      "Name": "SpeedrunTimerComponent",
      "Type": 1,
      "Source": 1,
      "Target": "@Component\nscript SpeedrunTimerComponent extends Component\n\n    @Sync\n    property number ElapsedTime = 0.0\n    @Sync\n    property boolean IsRunning = false\n    property integer CurrentStageId = 1\n    @Sync\n    property number BestTime = -1\n\n    property number CountdownSeconds = 3.0\n    property number TextUpdateInterval = 0.05\n    property boolean AutoPauseBySwap = true\n\n    property Entity TimerTextEntity = nil\n    property string TimerStoragePrefix = \"Stage_\"\n    property string TimerStorageSuffix = \"_BestTime\"\n\n    -- Server initializes timer state and loads best record so run start is deterministic.\n    @ExecSpace(\"ServerOnly\")\n    method void OnInitialize()\n        self:EnsureGRUtil()\n        self.ElapsedTime = 0\n        self.IsRunning = false\n\n        self._T.CountdownTimerId = 0\n        self._T.PauseSources = {}\n        self._T.ClientTextTimerId = 0\n\n        self:LoadBestTimeFromStorageServer()\n    end\n\n    -- Client starts timer text loop and utility bootstrap for UI-only updates.\n    @ExecSpace(\"ClientOnly\")\n    method void OnBeginPlay()\n        self:EnsureGRUtil()\n        self:StartClientTimerTextLoop()\n        self:UpdateTimerTextClient(self.ElapsedTime, self.IsRunning)\n    end\n\n    -- Server accumulates authoritative elapsed time to keep speedrun record cheat-resistant.\n    @ExecSpace(\"ServerOnly\")\n    method void OnUpdate(number delta)\n        if self.IsRunning == false then\n            return\n        end\n        if self:IsPausedServer() == true then\n            return\n        end\n\n        self.ElapsedTime = self.ElapsedTime + delta\n    end\n\n    -- Countdown start method is used by bootstrap/lobby flow and resets state before run begins.\n    @ExecSpace(\"ServerOnly\")\n    method void StartRunWithCountdown()\n        self:ResetRun()\n\n        if self._T.CountdownTimerId ~= nil and self._T.CountdownTimerId > 0 then\n            _TimerService:ClearTimer(self._T.CountdownTimerId)\n            self._T.CountdownTimerId = 0\n        end\n\n        local countdown = math.max(self.CountdownSeconds, 0)\n        if countdown <= 0 then\n            self:StartRunNow()\n            return\n        end\n\n        local runStart = function()\n            self._T.CountdownTimerId = 0\n            self:StartRunNow()\n        end\n\n        self._T.CountdownTimerId = _TimerService:SetTimerOnce(runStart, countdown)\n    end\n\n    -- Immediate run start is separated so other systems can skip countdown while preserving same init flow.\n    @ExecSpace(\"ServerOnly\")\n    method void StartRunNow()\n        self.ElapsedTime = 0\n        self.IsRunning = true\n        self:TrySetTimerTextVisibleClient(true)\n    end\n\n    -- Completion finalizes run state once, evaluates best time, and forwards record to ranking.\n    @ExecSpace(\"ServerOnly\")\n    method void CompleteRun()\n        if self.IsRunning == false and self.ElapsedTime <= 0 then\n            return\n        end\n\n        self.IsRunning = false\n        self:EvaluateBestTimeServer()\n        self:NotifyRankingServer()\n        self:TrySetTimerTextVisibleClient(false)\n    end\n\n    -- Reset keeps timer in standby mode for retry flow and clears pending countdown callbacks.\n    @ExecSpace(\"ServerOnly\")\n    method void ResetRun()\n        self.IsRunning = false\n        self.ElapsedTime = 0\n\n        if self._T.CountdownTimerId ~= nil and self._T.CountdownTimerId > 0 then\n            _TimerService:ClearTimer(self._T.CountdownTimerId)\n            self._T.CountdownTimerId = 0\n        end\n    end\n\n    -- Pause source API allows swap/menu/shop systems to pause timer without directly mutating IsRunning.\n    @ExecSpace(\"ServerOnly\")\n    method void SetPauseSource(string sourceKey, boolean shouldPause)\n        if sourceKey == nil or sourceKey == \"\" then\n            return\n        end\n\n        if self._T.PauseSources == nil then\n            self._T.PauseSources = {}\n        end\n        self._T.PauseSources[sourceKey] = shouldPause\n    end\n\n    -- Explicit clear API is provided so external systems can release one pause source safely.\n    @ExecSpace(\"ServerOnly\")\n    method void ClearPauseSource(string sourceKey)\n        if sourceKey == nil or sourceKey == \"\" then\n            return\n        end\n        if self._T.PauseSources == nil then\n            return\n        end\n\n        self._T.PauseSources[sourceKey] = false\n    end\n\n    -- Server pause decision merges explicit pause sources and linked component state checks.\n    @ExecSpace(\"ServerOnly\")\n    method boolean IsPausedServer()\n        if self._T.PauseSources ~= nil then\n            for _, isPaused in pairs(self._T.PauseSources) do\n                if isPaused == true then\n                    return true\n                end\n            end\n        end\n\n        if self.AutoPauseBySwap == true then\n            local swapComponent = self:ResolveComponentSafe(self.Entity, \"WeaponSwapComponent\", \"IsSwapMenuOpen\")\n            if swapComponent ~= nil then\n                local swapOk, menuOpen = pcall(function()\n                    return swapComponent.IsSwapMenuOpen\n                end)\n                if swapOk == true and menuOpen == true then\n                    return true\n                end\n            end\n        end\n\n        local lobbyFlow = self:ResolveComponentSafe(self.Entity, \"LobbyFlowComponent\", \"IsLobbyActive\")\n        if lobbyFlow ~= nil then\n            local lobbyOk, isLobby = pcall(function()\n                return lobbyFlow.IsLobbyActive\n            end)\n            if lobbyOk == true and isLobby == true then\n                return true\n            end\n        end\n\n        return false\n    end\n\n    -- Best-time evaluation is server-only and writes storage only when record improves.\n    @ExecSpace(\"ServerOnly\")\n    method void EvaluateBestTimeServer()\n        local finalTime = self.ElapsedTime\n        if finalTime <= 0 then\n            return\n        end\n\n        local isNewRecord = false\n        if self.BestTime < 0 then\n            isNewRecord = true\n        elseif finalTime < self.BestTime then\n            isNewRecord = true\n        end\n\n        if isNewRecord == false then\n            return\n        end\n\n        self.BestTime = finalTime\n        self:SaveBestTimeToStorageServer(finalTime)\n        self:PlayNewRecordEffectClient()\n    end\n\n    -- Ranking forwarder keeps timer independent from ranking implementation details.\n    @ExecSpace(\"ServerOnly\")\n    method void NotifyRankingServer()\n        local rankingComponent = self:ResolveComponentSafe(self.Entity, \"RankingComponent\", nil)\n        if rankingComponent ~= nil and rankingComponent.SubmitTimeAttackRecordServer ~= nil then\n            pcall(function()\n                rankingComponent:SubmitTimeAttackRecordServer(self.ElapsedTime)\n            end)\n        end\n    end\n\n    -- Storage key is derived from stage id to keep per-stage best records separated.\n    method string GetBestTimeStorageKey()\n        return self.TimerStoragePrefix .. tostring(self.CurrentStageId) .. self.TimerStorageSuffix\n    end\n\n    -- Best-time loading reads user storage on server and falls back safely if unavailable.\n    @ExecSpace(\"ServerOnly\")\n    method void LoadBestTimeFromStorageServer()\n        local userId = self:GetOwnerUserId()\n        if userId == nil or userId == \"\" then\n            return\n        end\n\n        local userStorage = _DataStorageService:GetUserDataStorage(userId)\n        if userStorage == nil then\n            return\n        end\n\n        local key = self:GetBestTimeStorageKey()\n        local readOk, errorCode, value = pcall(function()\n            return userStorage:GetAndWait(key)\n        end)\n        if readOk == false then\n            return\n        end\n        if errorCode ~= 0 then\n            return\n        end\n        if value == nil or value == \"\" then\n            return\n        end\n\n        local parsed = tonumber(value)\n        if parsed ~= nil then\n            self.BestTime = parsed\n        end\n    end\n\n    -- Record save stores float seconds as string for consistent parsing across runs.\n    @ExecSpace(\"ServerOnly\")\n    method void SaveBestTimeToStorageServer(number bestTime)\n        local userId = self:GetOwnerUserId()\n        if userId == nil or userId == \"\" then\n            return\n        end\n\n        local userStorage = _DataStorageService:GetUserDataStorage(userId)\n        if userStorage == nil then\n            return\n        end\n\n        local key = self:GetBestTimeStorageKey()\n        pcall(function()\n            userStorage:SetAndWait(key, tostring(bestTime))\n        end)\n    end\n\n    -- Client timer loop updates text at fixed interval without requiring per-frame heavy UI work.\n    @ExecSpace(\"ClientOnly\")\n    method void StartClientTimerTextLoop()\n        if self._T.ClientTextTimerId ~= nil and self._T.ClientTextTimerId > 0 then\n            return\n        end\n\n        local interval = self.TextUpdateInterval\n        if interval <= 0 then\n            interval = 0.05\n        end\n\n        local updateText = function()\n            self:UpdateTimerTextClient(self.ElapsedTime, self.IsRunning)\n        end\n\n        self._T.ClientTextTimerId = _TimerService:SetTimerRepeat(updateText, interval, 0)\n    end\n\n    -- Visibility helper respects lobby guard and keeps lobby/in-game UI policy centralized.\n    @ExecSpace(\"Client\")\n    method void TrySetTimerTextVisibleClient(boolean visible)\n        local finalVisible = visible\n\n        local lobbyFlow = self:ResolveComponentSafe(self.Entity, \"LobbyFlowComponent\", \"IsLobbyActive\")\n        if lobbyFlow ~= nil then\n            local lobbyOk, isLobby = pcall(function()\n                return lobbyFlow.IsLobbyActive\n            end)\n            local hideOk, hideFlag = pcall(function()\n                return lobbyFlow.HideTimerDuringLobby\n            end)\n            if lobbyOk == true and hideOk == true and isLobby == true and hideFlag == true then\n                finalVisible = false\n            end\n        end\n\n        local textComponent = self:ResolveTimerTextComponentClient()\n        if textComponent == nil then\n            return\n        end\n\n        pcall(function()\n            textComponent.Entity.Enable = finalVisible\n        end)\n    end\n\n    -- Text update formats MM:SS.ms and is client-only to keep display concerns out of server flow.\n    @ExecSpace(\"ClientOnly\")\n    method void UpdateTimerTextClient(number elapsedTime, boolean isRunning)\n        local textComponent = self:ResolveTimerTextComponentClient()\n        if textComponent == nil then\n            return\n        end\n\n        local formatted = self:FormatElapsedTime(elapsedTime)\n        pcall(function()\n            textComponent.Text = formatted\n        end)\n\n        if isRunning == true then\n            self:TrySetTimerTextVisibleClient(true)\n        end\n    end\n\n    -- New-record client hook is isolated for future VFX/SFX expansion.\n    @ExecSpace(\"Client\")\n    method void PlayNewRecordEffectClient()\n        log(\"[SpeedrunTimerComponent] New Record!\")\n    end\n\n    -- Sync callback refreshes timer text immediately when synced values change.\n    @ExecSpace(\"ClientOnly\")\n    method void OnSyncProperty(string propertyName, any value)\n        if propertyName == \"ElapsedTime\" then\n            self:UpdateTimerTextClient(self.ElapsedTime, self.IsRunning)\n            return\n        end\n        if propertyName == \"IsRunning\" then\n            self:UpdateTimerTextClient(self.ElapsedTime, self.IsRunning)\n            if self.IsRunning == false then\n                self:TrySetTimerTextVisibleClient(false)\n            end\n            return\n        end\n        if propertyName == \"BestTime\" then\n            self:UpdateTimerTextClient(self.ElapsedTime, self.IsRunning)\n        end\n    end\n\n    -- Map enter reapplies visibility policy because UI entities can be reloaded on map transitions.\n    @ExecSpace(\"ClientOnly\")\n    method void OnMapEnter(Entity enteredMap)\n        self:UpdateTimerTextClient(self.ElapsedTime, self.IsRunning)\n        if self.IsRunning == true then\n            self:TrySetTimerTextVisibleClient(true)\n        else\n            self:TrySetTimerTextVisibleClient(false)\n        end\n    end\n\n    method string FormatElapsedTime(number timeValue)\n        local value = timeValue\n        if value < 0 then\n            value = 0\n        end\n\n        local totalSeconds = math.floor(value)\n        local minute = math.floor(totalSeconds / 60)\n        local second = totalSeconds % 60\n        local centisecond = math.floor((value - totalSeconds) * 100)\n        if centisecond < 0 then\n            centisecond = 0\n        elseif centisecond > 99 then\n            centisecond = 99\n        end\n\n        return string.format(\"%02d:%02d.%02d\", minute, second, centisecond)\n    end\n\n    -- Timer text resolve uses explicit entity reference first to avoid path-dependent runtime failures.\n    @ExecSpace(\"ClientOnly\")\n    method TextComponent ResolveTimerTextComponentClient()\n        if self.TimerTextEntity == nil or isvalid(self.TimerTextEntity) == false then\n            return nil\n        end\n\n        local textComponent = self.TimerTextEntity.TextComponent\n        if textComponent == nil or isvalid(textComponent) == false then\n            return nil\n        end\n\n        return textComponent\n    end\n\n    -- User id resolver is shared by storage read/write methods.\n    method string GetOwnerUserId()\n        local userId = \"\"\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent ~= nil then\n            local playerOk, playerUserId = pcall(function()\n                return playerComponent.UserId\n            end)\n            if playerOk == true and playerUserId ~= nil and playerUserId ~= \"\" then\n                userId = playerUserId\n            end\n        end\n\n        if userId ~= \"\" then\n            return userId\n        end\n\n        local localPlayer = _UserService.LocalPlayer\n        if localPlayer ~= nil and isvalid(localPlayer) == true then\n            local localOk, localUserId = pcall(function()\n                return localPlayer.PlayerComponent.UserId\n            end)\n            if localOk == true and localUserId ~= nil then\n                return localUserId\n            end\n        end\n\n        return \"\"\n    end\n\n    -- EndPlay clears all active timers to prevent stale callbacks after entity destruction.\n    method void OnEndPlay()\n        if self._T.CountdownTimerId ~= nil and self._T.CountdownTimerId > 0 then\n            _TimerService:ClearTimer(self._T.CountdownTimerId)\n            self._T.CountdownTimerId = 0\n        end\n        if self._T.ClientTextTimerId ~= nil and self._T.ClientTextTimerId > 0 then\n            _TimerService:ClearTimer(self._T.ClientTextTimerId)\n            self._T.ClientTextTimerId = 0\n        end\n    end\n\n    -- Utility bootstrap first; fallback local lookup is retained if global util registration is unavailable.\n    method void EnsureGRUtil()\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, _ = pcall(function()\n                utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    method Component ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return _GRUtil.ResolveComponent(targetEntity, scriptName, markerField)\n        end\n\n        local prefixedName = scriptName\n        local plainName = scriptName\n        if string.sub(scriptName, 1, 7) == \"script.\" then\n            plainName = string.sub(scriptName, 8)\n        else\n            prefixedName = \"script.\" .. scriptName\n        end\n\n        local component = targetEntity:GetComponent(prefixedName)\n        if component == nil then\n            component = targetEntity:GetComponent(plainName)\n        end\n        if component == nil then\n            return nil\n        end\n\n        if markerField ~= nil and markerField ~= \"\" then\n            local ok, _ = pcall(function()\n                return component[markerField]\n            end)\n            if ok == false then\n                return nil\n            end\n        end\n\n        return component\n    end\nend\n"
    }
  }
}