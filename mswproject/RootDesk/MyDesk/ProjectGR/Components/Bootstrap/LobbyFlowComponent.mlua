@Component
script LobbyFlowComponent extends Component

    @Sync
    property boolean IsLobbyActive = true

    property boolean UseMapSplit = true
    property string LobbyMapName = "lobby"
    property string InGameMapName = "1stage"

    property boolean AutoOpenRankingOnLobby = true
    property integer LobbyRankingTab = 1

    property string StartButtonPath = "/ui/DefaultGroup/GRStartButton"
    property string RankingTextPath = "/ui/DefaultGroup/GRRankingText"
    property string MyRankTextPath = "/ui/DefaultGroup/GRMyRankText"
    property string UIRootPath = "/ui/DefaultGroup"

    -- Server initializes utility and runtime-only button/debounce state.
    @ExecSpace("ServerOnly")
    method void OnInitialize()
        self:EnsureGRUtil()
        self._T.StartButtonHandler = nil
        self._T.StartButtonDebounce = false
        self._T.StartButtonDebounceTimerId = 0
    end

    -- Server applies initial lobby lock state so movement/attack authority starts consistently.
    @ExecSpace("ServerOnly")
    method void OnBeginPlay()
        self:ApplyInitialServerState()
    end

    -- Map enter refreshes UI immediately to prevent stale start/ranking widgets during map transitions.
    @ExecSpace("ClientOnly")
    method void OnMapEnter(Entity enteredMap)
        self:BindStartButtonClient()

        local mapName = self:GetMapNameSafe(enteredMap)
        if self:IsInGameMapName(mapName) == true then
            self:ApplyLobbyUIClient(false)
            return
        end

        local isLobby = self:ResolveEffectiveLobbyStateClient()
        self:ApplyLobbyUIClient(isLobby)
        if isLobby == true then
            self:RequestOpenLobbyRankingClient()
        end
    end

    -- Client retry loop binds late-loaded UI start button when component attach timing misses OnMapEnter.
    @ExecSpace("ClientOnly")
    method void OnUpdate(number delta)
        if self._T.StartButtonHandler ~= nil then
            return
        end

        local retryRemain = self._T.StartButtonRetryRemain
        if retryRemain == nil then
            retryRemain = 0
        end

        retryRemain = retryRemain - delta
        if retryRemain > 0 then
            self._T.StartButtonRetryRemain = retryRemain
            return
        end

        self._T.StartButtonRetryRemain = 0.3
        self:BindStartButtonClient()
    end

    -- Start button route is the only allowed game-start input path for this SPEC.
    @ExecSpace("ClientOnly")
    method void OnStartButtonClickedClient(ButtonClickEvent event)
        if self.IsLobbyActive == false then
            return
        end
        if self._T.StartButtonDebounce == true then
            return
        end

        self._T.StartButtonDebounce = true
        if self._T.StartButtonDebounceTimerId ~= nil and self._T.StartButtonDebounceTimerId > 0 then
            _TimerService:ClearTimer(self._T.StartButtonDebounceTimerId)
            self._T.StartButtonDebounceTimerId = 0
        end

        local clearDebounce = function()
            self._T.StartButtonDebounce = false
            self._T.StartButtonDebounceTimerId = 0
        end
        self._T.StartButtonDebounceTimerId = _TimerService:SetTimerOnce(clearDebounce, 0.25)

        self:RequestStartGameServer()
    end

    -- Server validates ownership and lobby state before transitioning to in-game map.
    @ExecSpace("Server")
    method void RequestStartGameServer()
        if self:IsOwnerRequest(senderUserId) == false then
            return
        end
        if self.IsLobbyActive == false then
            return
        end

        self:SetLobbyStateServer(false)
        self:MoveOwnerToInGameMapIfNeeded()
    end

    -- Run completion path keeps compatibility with existing HP/game-over integration.
    @ExecSpace("ServerOnly")
    method void HandleRunCompletedServer(boolean isClear)
        self:SetLobbyStateServer(true)
        self:MoveOwnerToLobbyMapIfNeeded()
    end

    -- Stage-fail alias is referenced by HPSystem fallback flow.
    @ExecSpace("ServerOnly")
    method void HandleStageFailedServer()
        self:HandleRunCompletedServer(false)
    end

    -- Initial server state aligns movement/attack lock policy with synced lobby flag.
    @ExecSpace("ServerOnly")
    method void ApplyInitialServerState()
        self:SetLobbyStateServer(self.IsLobbyActive)
    end

    -- Single authoritative lobby-state setter to keep sync and lock transitions in one path.
    @ExecSpace("ServerOnly")
    method void SetLobbyStateServer(boolean isLobby)
        self.IsLobbyActive = isLobby
        self:ApplyGameplayLockByLobbyServer(isLobby)
    end

    -- Gameplay lock uses core/combat components through GR utility-safe wrappers.
    @ExecSpace("ServerOnly")
    method void ApplyGameplayLockByLobbyServer(boolean isLobby)
        self:SetCanMoveSafely(not isLobby)
        self:SetCanAttackSafely(not isLobby)
    end

    -- Client UI authority lives only here: start/ranking/my-rank visibility by lobby state.
    @ExecSpace("ClientOnly")
    method void ApplyLobbyUIClient(boolean isLobby)
        local startButton = self:ResolveUIEntity(self.StartButtonPath)
        if startButton ~= nil and isvalid(startButton) == true then
            pcall(function()
                startButton.Enable = isLobby
                startButton.Visible = isLobby
            end)
        end

        local rankingText = self:ResolveUIEntity(self.RankingTextPath)
        if rankingText ~= nil and isvalid(rankingText) == true then
            pcall(function()
                rankingText.Enable = isLobby
                rankingText.Visible = isLobby
            end)
        end

        local myRankText = self:ResolveUIEntity(self.MyRankTextPath)
        if myRankText ~= nil and isvalid(myRankText) == true then
            pcall(function()
                myRankText.Enable = isLobby
                myRankText.Visible = isLobby
            end)
        end

        local rankingUI = self:ResolveComponentSafe(self.Entity, "RankingUIComponent", nil)
        if rankingUI ~= nil and rankingUI.ApplyVisibilityClient ~= nil then
            pcall(function()
                rankingUI:ApplyVisibilityClient(isLobby)
            end)
        end
    end

    -- Sync callback is the primary client trigger when server changes lobby authority state.
    @ExecSpace("ClientOnly")
    method void OnSyncProperty(string propertyName, any value)
        if propertyName ~= "IsLobbyActive" then
            return
        end

        self:BindStartButtonClient()
        local isLobby = self:ResolveEffectiveLobbyStateClient()
        self:ApplyLobbyUIClient(isLobby)
        if isLobby == true then
            self:RequestOpenLobbyRankingClient()
        end
    end

    -- Lobby state is derived from sync property; helper exists for startup race handling.
    @ExecSpace("ClientOnly")
    method boolean ResolveEffectiveLobbyStateClient()
        return self.IsLobbyActive
    end

    -- Lobby entry auto-opens ranking tab and requests fresh snapshot from server-side ranking logic.
    @ExecSpace("ClientOnly")
    method void RequestOpenLobbyRankingClient()
        if self.AutoOpenRankingOnLobby == false then
            return
        end

        local tab = self:NormalizeRankingTab(self.LobbyRankingTab)

        local rankingUI = self:ResolveComponentSafe(self.Entity, "RankingUIComponent", nil)
        if rankingUI ~= nil then
            if rankingUI.OpenTab ~= nil then
                pcall(function()
                    rankingUI:OpenTab(tab)
                end)
            elseif rankingUI.SetCurrentTabClient ~= nil then
                pcall(function()
                    rankingUI:SetCurrentTabClient(tab)
                end)
            end
        end

        local rankingComponent = self:ResolveComponentSafe(self.Entity, "RankingComponent", nil)
        if rankingComponent == nil then
            return
        end

        local displayCount = self:GetRankingDisplayCount(rankingUI, rankingComponent)
        if rankingComponent.RequestRankingDataServer ~= nil then
            pcall(function()
                rankingComponent:RequestRankingDataServer(tab, displayCount)
            end)
            return
        end

        if rankingComponent.RequestRankingSnapshotServer ~= nil then
            pcall(function()
                rankingComponent.DisplayCount = displayCount
            end)
            pcall(function()
                rankingComponent:RequestRankingSnapshotServer(tab)
            end)
        end
    end

    method integer NormalizeRankingTab(integer tab)
        if math.floor(tab) == 2 then
            return 2
        end
        return 1
    end

    method integer GetRankingDisplayCount(Component rankingUI, Component rankingComponent)
        local displayCount = 100

        if rankingUI ~= nil then
            local uiOk, uiCount = pcall(function()
                return rankingUI.DisplayCount
            end)
            if uiOk == true and uiCount ~= nil and uiCount > 0 then
                displayCount = math.floor(uiCount)
            end
        end

        if rankingComponent ~= nil then
            local rankingOk, rankingCount = pcall(function()
                return rankingComponent.DisplayCount
            end)
            if rankingOk == true and rankingCount ~= nil and rankingCount > 0 then
                displayCount = math.floor(rankingCount)
            end
        end

        if displayCount <= 0 then
            displayCount = 100
        end
        return displayCount
    end

    -- Binds start button once and connects click callback to the only allowed start route.
    @ExecSpace("ClientOnly")
    method void BindStartButtonClient()
        if self._T.StartButtonHandler ~= nil then
            return
        end

        local startButton = self:ResolveUIEntity(self.StartButtonPath)
        if startButton == nil or isvalid(startButton) == false then
            return
        end

        if startButton.ButtonComponent == nil then
            pcall(function()
                startButton:AddComponent("MOD.Core.ButtonComponent")
            end)
        end

        local callback = function(event)
            self:OnStartButtonClickedClient(event)
        end
        self._T.StartButtonHandler = startButton:ConnectEvent(ButtonClickEvent, callback)
    end

    -- Primary path lookup with UIRoot fallback keeps references stable across map transitions.
    method Entity ResolveUIEntity(string path)
        local target = nil
        if path ~= nil and path ~= "" then
            target = _EntityService:GetEntityByPath(path)
        end
        if target ~= nil and isvalid(target) == true then
            return target
        end

        if self.UIRootPath == nil or self.UIRootPath == "" then
            return nil
        end

        local root = _EntityService:GetEntityByPath(self.UIRootPath)
        if root == nil or isvalid(root) == false then
            return nil
        end

        local leafName = self:GetLeafName(path)
        if leafName == nil or leafName == "" then
            return nil
        end

        local child = nil
        local ok, result = pcall(function()
            return root:GetChildByName(leafName, true)
        end)
        if ok == true then
            child = result
        end

        return child
    end

    method string GetLeafName(string path)
        if path == nil or path == "" then
            return ""
        end

        local indexStart, indexEnd = string.find(path, "[^/]*$")
        if indexStart == nil then
            return path
        end
        return string.sub(path, indexStart, indexEnd)
    end

    method string GetMapNameSafe(Entity mapEntity)
        if mapEntity == nil or isvalid(mapEntity) == false then
            return ""
        end

        local ok, name = pcall(function()
            return mapEntity.Name
        end)
        if ok == true and name ~= nil then
            return tostring(name)
        end
        return ""
    end

    -- In-game map candidate list preserves SPEC map01 intent while allowing 1stage fallback in reset workspace.
    method table GetInGameMapCandidates()
        local candidates = {}
        local seen = {}

        local pushCandidate = function(mapName)
            if mapName == nil or mapName == "" then
                return
            end
            if seen[mapName] == true then
                return
            end

            seen[mapName] = true
            table.insert(candidates, mapName)
        end

        pushCandidate(self.InGameMapName)
        if self.InGameMapName == "map01" then
            pushCandidate("1stage")
        elseif self.InGameMapName == "1stage" then
            pushCandidate("map01")
        end

        return candidates
    end

    method boolean IsInGameMapName(string mapName)
        if mapName == nil or mapName == "" then
            return false
        end

        local candidates = self:GetInGameMapCandidates()
        for _, candidate in pairs(candidates) do
            if candidate == mapName then
                return true
            end
        end

        return false
    end

    -- In-game transition uses verified RoomService static-room API in current MSW version.
    @ExecSpace("ServerOnly")
    method boolean MoveOwnerToInGameMapIfNeeded()
        if self.UseMapSplit == false then
            return true
        end

        local userId = self:GetOwnerUserId()
        if userId == nil or userId == "" then
            return false
        end

        local candidates = self:GetInGameMapCandidates()
        for _, mapName in pairs(candidates) do
            local moveOk, moved = pcall(function()
                return _RoomService:MoveUserToStaticRoom(userId, mapName)
            end)
            if moveOk == true and moved == true then
                return true
            end

            local mapUri = mapName
            if string.sub(mapName, 1, 6) ~= "map://" then
                mapUri = "map://" .. mapName
            end

            local uriOk, uriMoved = pcall(function()
                return _RoomService:MoveUserToStaticRoom(userId, mapUri)
            end)
            if uriOk == true and uriMoved == true then
                return true
            end
        end

        return false
    end

    -- Lobby transition mirrors in-game transition API for consistent map split flow.
    @ExecSpace("ServerOnly")
    method boolean MoveOwnerToLobbyMapIfNeeded()
        if self.UseMapSplit == false then
            return true
        end

        local userId = self:GetOwnerUserId()
        if userId == nil or userId == "" then
            return false
        end

        local moveOk, moved = pcall(function()
            return _RoomService:MoveUserToStaticRoom(userId, self.LobbyMapName)
        end)
        if moveOk == true and moved == true then
            return true
        end

        local lobbyUri = self.LobbyMapName
        if string.sub(self.LobbyMapName, 1, 6) ~= "map://" then
            lobbyUri = "map://" .. self.LobbyMapName
        end

        local uriOk, uriMoved = pcall(function()
            return _RoomService:MoveUserToStaticRoom(userId, lobbyUri)
        end)
        if uriOk == true and uriMoved == true then
            return true
        end

        return false
    end

    -- Owner resolver is shared by room move and ownership checks.
    method string GetOwnerUserId()
        local userId = ""

        local playerComponent = self.Entity.PlayerComponent
        if playerComponent ~= nil then
            local playerOk, playerUserId = pcall(function()
                return playerComponent.UserId
            end)
            if playerOk == true and playerUserId ~= nil and playerUserId ~= "" then
                userId = playerUserId
            end
        end

        if userId ~= "" then
            return userId
        end

        local localPlayer = _UserService.LocalPlayer
        if localPlayer ~= nil and isvalid(localPlayer) == true then
            local localOk, localUserId = pcall(function()
                return localPlayer.PlayerComponent.UserId
            end)
            if localOk == true and localUserId ~= nil then
                return localUserId
            end
        end

        return ""
    end

    -- Movement lock uses GR utility path first to keep cross-component field writes consistent.
    method boolean SetCanMoveSafely(boolean canMove)
        if self._T.GRUtil ~= nil and self._T.GRUtil.TrySetCanMove ~= nil then
            return self._T.GRUtil.TrySetCanMove(self.Entity, canMove)
        end

        local movementComponent = self:ResolveComponentSafe(self.Entity, "MovementComponent", "CanMove")
        if movementComponent == nil then
            return false
        end

        local ok, _ = pcall(function()
            movementComponent.CanMove = canMove
        end)
        return ok
    end

    -- Attack lock mirrors movement lock and degrades safely when combat component is absent.
    method boolean SetCanAttackSafely(boolean canAttack)
        local fireComponent = self:ResolveComponentSafe(self.Entity, "FireSystemComponent", "CanAttack")
        if fireComponent == nil then
            return false
        end

        if self._T.GRUtil ~= nil and self._T.GRUtil.TrySetField ~= nil then
            return self._T.GRUtil.TrySetField(fireComponent, "CanAttack", canAttack)
        end

        local ok, _ = pcall(function()
            fireComponent.CanAttack = canAttack
        end)
        return ok
    end

    -- EndPlay clears button handlers and debounce timer to avoid duplicated callbacks on re-enter.
    method void OnEndPlay()
        local startButton = self:ResolveUIEntity(self.StartButtonPath)
        if startButton ~= nil and self._T.StartButtonHandler ~= nil then
            pcall(function()
                startButton:DisconnectEvent(ButtonClickEvent, self._T.StartButtonHandler)
            end)
        end
        self._T.StartButtonHandler = nil

        if self._T.StartButtonDebounceTimerId ~= nil and self._T.StartButtonDebounceTimerId > 0 then
            _TimerService:ClearTimer(self._T.StartButtonDebounceTimerId)
            self._T.StartButtonDebounceTimerId = 0
        end
        self._T.StartButtonDebounce = false
        self._T.StartButtonRetryRemain = 0
    end

    -- Utility bootstrap first; fallback local lookup remains when global utility registration fails.
    method void EnsureGRUtil()
        if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then
            return
        end

        local utilComponent = nil
        if self.Entity ~= nil and isvalid(self.Entity) == true then
            utilComponent = self.Entity:GetComponent("script.GRUtilModule")
            if utilComponent == nil then
                utilComponent = self.Entity:GetComponent("GRUtilModule")
            end
            if utilComponent == nil then
                local addOk1, addResult1 = pcall(function()
                    return self.Entity:AddComponent("script.GRUtilModule")
                end)
                if addOk1 == true then
                    utilComponent = addResult1
                end
            end
            if utilComponent == nil then
                local addOk2, addResult2 = pcall(function()
                    return self.Entity:AddComponent("GRUtilModule")
                end)
                if addOk2 == true then
                    utilComponent = addResult2
                end
            end
        end

        if utilComponent ~= nil and isvalid(utilComponent) == true then
            local bootstrapOk, utilApi = pcall(function()
                return utilComponent:BootstrapUtil()
            end)
            if bootstrapOk == true and utilApi ~= nil then
                self._T.GRUtil = utilApi
            end
            if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then
                return
            end
        end

        self._T.UseGRUtilFallback = true
    end

    method any ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)
        if targetEntity == nil or isvalid(targetEntity) == false then
            return nil
        end

        if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then
            return self._T.GRUtil.ResolveComponent(targetEntity, scriptName, markerField)
        end

        local prefixedName = scriptName
        local plainName = scriptName
        if string.sub(scriptName, 1, 7) == "script." then
            plainName = string.sub(scriptName, 8)
        else
            prefixedName = "script." .. scriptName
        end

        local component = targetEntity:GetComponent(prefixedName)
        if component == nil then
            component = targetEntity:GetComponent(plainName)
        end
        if component == nil then
            return nil
        end

        if markerField ~= nil and markerField ~= "" then
            local ok, _ = pcall(function()
                return component[markerField]
            end)
            if ok == false then
                return nil
            end
        end

        return component
    end

    method boolean IsOwnerRequest(string requestUserId)
        if self._T.GRUtil ~= nil and self._T.GRUtil.IsOwner ~= nil then
            return self._T.GRUtil.IsOwner(self.Entity, requestUserId)
        end

        local playerComponent = self.Entity.PlayerComponent
        if playerComponent == nil then
            return true
        end

        if requestUserId == nil or requestUserId == "" then
            return true
        end

        return requestUserId == playerComponent.UserId
    end
end
