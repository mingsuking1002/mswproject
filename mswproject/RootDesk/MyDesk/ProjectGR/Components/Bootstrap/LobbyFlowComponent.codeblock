{
  "Id": "",
  "GameId": "",
  "EntryKey": "codeblock://041160bb-4254-403c-bb04-6b254fec390a",
  "ContentType": "x-mod/codeblock",
  "Content": "",
  "Usage": 0,
  "UsePublish": 1,
  "UseService": 0,
  "CoreVersion": "26.1.0.0",
  "StudioVersion": "",
  "DynamicLoading": 0,
  "ContentProto": {
    "Use": "Json",
    "Json": {
      "CoreVersion": {
        "Major": 0,
        "Minor": 2
      },
      "ScriptVersion": {
        "Major": 1,
        "Minor": 1
      },
      "Description": "",
      "Id": "041160bb-4254-403c-bb04-6b254fec390a",
      "Language": 1,
      "Name": "LobbyFlowComponent",
      "Type": 1,
      "Source": 1,
      "Target": "@Component\nscript LobbyFlowComponent extends Component\n\n    @Sync\n    property boolean IsLobbyActive = true\n\n    property boolean UseMapSplit = false\n    property string LobbyMapName = \"games\"\n    property string InGameMapName = \"games\"\n\n    property boolean AutoOpenRankingOnLobby = true\n    property integer LobbyRankingTab = 1\n\n    property string StartButtonPath = \"/ui/DefaultGroup/GRStartButton\"\n    property string RankingTextPath = \"/ui/DefaultGroup/GRRankingText\"\n    property string MyRankTextPath = \"/ui/DefaultGroup/GRMyRankText\"\n    property string UIRootPath = \"/ui/DefaultGroup\"\n\n    -- Server initializes utility and runtime-only button/debounce state.\n    @ExecSpace(\"ServerOnly\")\n    method void OnInitialize()\n        self:EnsureGRUtil()\n        self._T.StartButtonHandler = nil\n        self._T.StartButtonDebounce = false\n        self._T.StartButtonDebounceTimerId = 0\n    end\n\n    -- Server applies initial lobby lock state so movement/attack authority starts consistently.\n    @ExecSpace(\"ServerOnly\")\n    method void OnBeginPlay()\n        self:ApplyInitialServerState()\n    end\n\n    -- Map enter refreshes UI immediately to prevent stale start/ranking widgets during map transitions.\n    @ExecSpace(\"ClientOnly\")\n    method void OnMapEnter(Entity enteredMap)\n        self:BindStartButtonClient()\n\n        if self.UseMapSplit == true then\n            local mapName = self:GetMapNameSafe(enteredMap)\n            if self:IsInGameMapName(mapName) == true then\n                self:ApplyLobbyUIClient(false)\n                return\n            end\n        end\n\n        local isLobby = self:ResolveEffectiveLobbyStateClient()\n        self:ApplyLobbyUIClient(isLobby)\n        if isLobby == true then\n            self:RequestOpenLobbyRankingClient()\n        end\n    end\n\n    -- Client retry loop binds late-loaded UI start button when component attach timing misses OnMapEnter.\n    @ExecSpace(\"ClientOnly\")\n    method void OnUpdate(number delta)\n        if self._T.StartButtonHandler ~= nil then\n            return\n        end\n\n        local retryRemain = self._T.StartButtonRetryRemain\n        if retryRemain == nil then\n            retryRemain = 0\n        end\n\n        retryRemain = retryRemain - delta\n        if retryRemain > 0 then\n            self._T.StartButtonRetryRemain = retryRemain\n            return\n        end\n\n        self._T.StartButtonRetryRemain = 0.3\n        self:BindStartButtonClient()\n    end\n\n    -- Start button route is the only allowed game-start input path for this SPEC.\n    @ExecSpace(\"ClientOnly\")\n    method void OnStartButtonClickedClient(ButtonClickEvent event)\n        if self.IsLobbyActive == false then\n            return\n        end\n        if self._T.StartButtonDebounce == true then\n            return\n        end\n\n        self._T.StartButtonDebounce = true\n        if self._T.StartButtonDebounceTimerId ~= nil and self._T.StartButtonDebounceTimerId > 0 then\n            _TimerService:ClearTimer(self._T.StartButtonDebounceTimerId)\n            self._T.StartButtonDebounceTimerId = 0\n        end\n\n        local clearDebounce = function()\n            self._T.StartButtonDebounce = false\n            self._T.StartButtonDebounceTimerId = 0\n        end\n        self._T.StartButtonDebounceTimerId = _TimerService:SetTimerOnce(clearDebounce, 0.25)\n\n        local requestUserId = self:GetOwnerUserId()\n        log(\"[LobbyFlow] Start clicked. requestUserId=\", requestUserId, \", map=\", self.InGameMapName)\n        self:RequestStartGameServer(requestUserId)\n    end\n\n    -- Server validates ownership and lobby state before transitioning to in-game map.\n    @ExecSpace(\"Server\")\n    method void RequestStartGameServer(string requestUserId)\n        if self.IsLobbyActive == false then\n            return\n        end\n\n        local targetUserId = requestUserId\n        if targetUserId == nil or targetUserId == \"\" then\n            targetUserId = self:GetOwnerUserId()\n        end\n        if targetUserId == nil or targetUserId == \"\" then\n            log_warning(\"[LobbyFlow] Start request blocked: empty user id.\")\n            return\n        end\n\n        log(\"[LobbyFlow] Start request accepted. userId=\", targetUserId, \", map=\", self.InGameMapName)\n        self:SetLobbyStateServer(false)\n        self:MoveUserToInGameMapByUserId(targetUserId)\n    end\n\n    -- Run completion path keeps compatibility with existing HP/game-over integration.\n    @ExecSpace(\"ServerOnly\")\n    method void HandleRunCompletedServer(boolean isClear)\n        self:TryResetGoldForOwnerServer()\n        self:TryResetShopForOwnerServer()\n        self:SetLobbyStateServer(true)\n        self:MoveOwnerToLobbyMapIfNeeded()\n    end\n\n    -- Lobby return resets run-lifetime gold so each run starts from deterministic initial currency.\n    @ExecSpace(\"ServerOnly\")\n    method void TryResetGoldForOwnerServer()\n        local goldComponent = self:ResolveComponentSafe(self.Entity, \"GoldComponent\", \"CurrentGold\")\n        if goldComponent == nil then\n            return\n        end\n        if goldComponent.ResetGold == nil then\n            return\n        end\n\n        pcall(function()\n            goldComponent:ResetGold()\n        end)\n    end\n\n    -- Lobby return resets shop state so next run starts with fresh shop rotation/open state.\n    @ExecSpace(\"ServerOnly\")\n    method void TryResetShopForOwnerServer()\n        local shopManager = self:ResolveComponentSafe(self.Entity, \"ShopManagerComponent\", \"ActiveShopIndex\")\n        if shopManager == nil then\n            return\n        end\n        if shopManager.ResetShopStateServer == nil then\n            return\n        end\n\n        pcall(function()\n            shopManager:ResetShopStateServer()\n        end)\n    end\n\n    -- Stage-fail alias is referenced by HPSystem fallback flow.\n    @ExecSpace(\"ServerOnly\")\n    method void HandleStageFailedServer()\n        self:HandleRunCompletedServer(false)\n    end\n\n    -- Initial server state aligns movement/attack lock policy with synced lobby flag.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyInitialServerState()\n        self:SetLobbyStateServer(self.IsLobbyActive)\n    end\n\n    -- Single authoritative lobby-state setter to keep sync and lock transitions in one path.\n    @ExecSpace(\"ServerOnly\")\n    method void SetLobbyStateServer(boolean isLobby)\n        self.IsLobbyActive = isLobby\n        self:ApplyGameplayLockByLobbyServer(isLobby)\n    end\n\n    -- Gameplay lock uses core/combat components through GR utility-safe wrappers.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyGameplayLockByLobbyServer(boolean isLobby)\n        self:SetCanMoveSafely(not isLobby)\n        self:SetCanAttackSafely(not isLobby)\n    end\n\n    -- Client UI authority lives only here: start/ranking/my-rank visibility by lobby state.\n    @ExecSpace(\"ClientOnly\")\n    method void ApplyLobbyUIClient(boolean isLobby)\n        local startButton = self:ResolveUIEntity(self.StartButtonPath)\n        if startButton ~= nil and isvalid(startButton) == true then\n            pcall(function()\n                startButton.Enable = isLobby\n                startButton.Visible = isLobby\n            end)\n        end\n\n        local rankingText = self:ResolveUIEntity(self.RankingTextPath)\n        if rankingText ~= nil and isvalid(rankingText) == true then\n            pcall(function()\n                rankingText.Enable = isLobby\n                rankingText.Visible = isLobby\n            end)\n        end\n\n        local myRankText = self:ResolveUIEntity(self.MyRankTextPath)\n        if myRankText ~= nil and isvalid(myRankText) == true then\n            pcall(function()\n                myRankText.Enable = isLobby\n                myRankText.Visible = isLobby\n            end)\n        end\n\n        local rankingUI = self:ResolveComponentSafe(self.Entity, \"RankingUIComponent\", nil)\n        if rankingUI ~= nil and rankingUI.ApplyVisibilityClient ~= nil then\n            pcall(function()\n                rankingUI:ApplyVisibilityClient(isLobby)\n            end)\n        end\n    end\n\n    -- Sync callback is the primary client trigger when server changes lobby authority state.\n    @ExecSpace(\"ClientOnly\")\n    method void OnSyncProperty(string propertyName, any value)\n        if propertyName ~= \"IsLobbyActive\" then\n            return\n        end\n\n        self:BindStartButtonClient()\n        local isLobby = self:ResolveEffectiveLobbyStateClient()\n        self:ApplyLobbyUIClient(isLobby)\n        if isLobby == true then\n            self:RequestOpenLobbyRankingClient()\n        end\n    end\n\n    -- Lobby state is derived from sync property; helper exists for startup race handling.\n    @ExecSpace(\"ClientOnly\")\n    method boolean ResolveEffectiveLobbyStateClient()\n        return self.IsLobbyActive\n    end\n\n    -- Lobby entry auto-opens ranking tab and requests fresh snapshot from server-side ranking logic.\n    @ExecSpace(\"ClientOnly\")\n    method void RequestOpenLobbyRankingClient()\n        if self.AutoOpenRankingOnLobby == false then\n            return\n        end\n\n        local tab = self:NormalizeRankingTab(self.LobbyRankingTab)\n\n        local rankingUI = self:ResolveComponentSafe(self.Entity, \"RankingUIComponent\", nil)\n        if rankingUI ~= nil then\n            if rankingUI.OpenTab ~= nil then\n                pcall(function()\n                    rankingUI:OpenTab(tab)\n                end)\n            elseif rankingUI.SetCurrentTabClient ~= nil then\n                pcall(function()\n                    rankingUI:SetCurrentTabClient(tab)\n                end)\n            end\n        end\n\n        local rankingComponent = self:ResolveComponentSafe(self.Entity, \"RankingComponent\", nil)\n        if rankingComponent == nil then\n            return\n        end\n\n        local displayCount = self:GetRankingDisplayCount(rankingUI, rankingComponent)\n        if rankingComponent.RequestRankingDataServer ~= nil then\n            pcall(function()\n                rankingComponent:RequestRankingDataServer(tab, displayCount)\n            end)\n            return\n        end\n\n        if rankingComponent.RequestRankingSnapshotServer ~= nil then\n            pcall(function()\n                rankingComponent.DisplayCount = displayCount\n            end)\n            pcall(function()\n                rankingComponent:RequestRankingSnapshotServer(tab)\n            end)\n        end\n    end\n\n    method integer NormalizeRankingTab(integer tab)\n        if math.floor(tab) == 2 then\n            return 2\n        end\n        return 1\n    end\n\n    method integer GetRankingDisplayCount(Component rankingUI, Component rankingComponent)\n        local displayCount = 100\n\n        if rankingUI ~= nil then\n            local uiOk, uiCount = pcall(function()\n                return rankingUI.DisplayCount\n            end)\n            if uiOk == true and uiCount ~= nil and uiCount > 0 then\n                displayCount = math.floor(uiCount)\n            end\n        end\n\n        if rankingComponent ~= nil then\n            local rankingOk, rankingCount = pcall(function()\n                return rankingComponent.DisplayCount\n            end)\n            if rankingOk == true and rankingCount ~= nil and rankingCount > 0 then\n                displayCount = math.floor(rankingCount)\n            end\n        end\n\n        if displayCount <= 0 then\n            displayCount = 100\n        end\n        return displayCount\n    end\n\n    -- Binds start button once and connects click callback to the only allowed start route.\n    @ExecSpace(\"ClientOnly\")\n    method void BindStartButtonClient()\n        if self._T.StartButtonHandler ~= nil then\n            return\n        end\n\n        local startButton = self:ResolveUIEntity(self.StartButtonPath)\n        if startButton == nil or isvalid(startButton) == false then\n            return\n        end\n\n        if startButton.ButtonComponent == nil then\n            pcall(function()\n                startButton:AddComponent(\"MOD.Core.ButtonComponent\")\n            end)\n        end\n        if startButton.ButtonComponent == nil then\n            return\n        end\n\n        local callback = function(event)\n            self:OnStartButtonClickedClient(event)\n        end\n\n        local bindOk, bindHandler = pcall(function()\n            return startButton:ConnectEvent(ButtonClickEvent, callback)\n        end)\n        if bindOk == true then\n            self._T.StartButtonHandler = bindHandler\n        end\n    end\n\n    -- Primary path lookup with UIRoot fallback keeps references stable across map transitions.\n    method Entity ResolveUIEntity(string path)\n        local target = nil\n        if path ~= nil and path ~= \"\" then\n            target = _EntityService:GetEntityByPath(path)\n        end\n        if target ~= nil and isvalid(target) == true then\n            return target\n        end\n\n        if self.UIRootPath == nil or self.UIRootPath == \"\" then\n            return nil\n        end\n\n        local root = _EntityService:GetEntityByPath(self.UIRootPath)\n        if root == nil or isvalid(root) == false then\n            return nil\n        end\n\n        local leafName = self:GetLeafName(path)\n        if leafName == nil or leafName == \"\" then\n            return nil\n        end\n\n        local child = nil\n        local ok, result = pcall(function()\n            return root:GetChildByName(leafName, true)\n        end)\n        if ok == true then\n            child = result\n        end\n\n        return child\n    end\n\n    method string GetLeafName(string path)\n        if path == nil or path == \"\" then\n            return \"\"\n        end\n\n        local indexStart, indexEnd = string.find(path, \"[^/]*$\")\n        if indexStart == nil then\n            return path\n        end\n        return string.sub(path, indexStart, indexEnd)\n    end\n\n    method string GetMapNameSafe(Entity mapEntity)\n        if mapEntity == nil or isvalid(mapEntity) == false then\n            return \"\"\n        end\n\n        local ok, name = pcall(function()\n            return mapEntity.Name\n        end)\n        if ok == true and name ~= nil then\n            return tostring(name)\n        end\n        return \"\"\n    end\n\n    -- Normalizes map key format so plain, uri, and path notations map to one comparable value.\n    method string NormalizeMapName(string mapName)\n        if mapName == nil or mapName == \"\" then\n            return \"\"\n        end\n\n        local normalized = tostring(mapName)\n        if string.sub(normalized, 1, 6) == \"map://\" then\n            normalized = string.sub(normalized, 7)\n        end\n        if string.sub(normalized, 1, 6) == \"/maps/\" then\n            normalized = string.sub(normalized, 7)\n        end\n\n        return normalized\n    end\n\n    -- In-game map candidate list includes all common map key formats for robust room-service compatibility.\n    method table GetInGameMapCandidates()\n        local candidates = {}\n        local seen = {}\n\n        local pushCandidate = function(mapName)\n            if mapName == nil or mapName == \"\" then\n                return\n            end\n            if seen[mapName] == true then\n                return\n            end\n\n            seen[mapName] = true\n            table.insert(candidates, mapName)\n        end\n\n        pushCandidate(self.InGameMapName)\n\n        local normalized = self:NormalizeMapName(self.InGameMapName)\n        if normalized ~= \"\" then\n            pushCandidate(normalized)\n            pushCandidate(\"map://\" .. normalized)\n            pushCandidate(\"/maps/\" .. normalized)\n        end\n\n        return candidates\n    end\n\n    method boolean IsInGameMapName(string mapName)\n        if mapName == nil or mapName == \"\" then\n            return false\n        end\n\n        local currentNormalized = self:NormalizeMapName(mapName)\n        local targetNormalized = self:NormalizeMapName(self.InGameMapName)\n        if targetNormalized ~= \"\" and currentNormalized == targetNormalized then\n            return true\n        end\n\n        local candidates = self:GetInGameMapCandidates()\n        for _, candidate in pairs(candidates) do\n            if candidate == mapName then\n                return true\n            end\n\n            local candidateNormalized = self:NormalizeMapName(candidate)\n            if candidateNormalized ~= \"\" and candidateNormalized == currentNormalized then\n                return true\n            end\n        end\n\n        return false\n    end\n\n    -- In-game transition uses verified RoomService static-room API in current MSW version.\n    @ExecSpace(\"ServerOnly\")\n    method boolean MoveOwnerToInGameMapIfNeeded()\n        local userId = self:GetOwnerUserId()\n        return self:MoveUserToInGameMapByUserId(userId)\n    end\n\n    -- Explicit user-id path is used by start RPC so transition works even when owner component lookup is delayed.\n    @ExecSpace(\"ServerOnly\")\n    method boolean MoveUserToInGameMapByUserId(string userId)\n        if self.UseMapSplit == false then\n            return true\n        end\n\n        if userId == nil or userId == \"\" then\n            return false\n        end\n\n        local candidates = self:GetInGameMapCandidates()\n        for _, mapName in pairs(candidates) do\n            local moveOk, moved = pcall(function()\n                return _RoomService:MoveUserToStaticRoom(userId, mapName)\n            end)\n            if moveOk == true and moved == true then\n                return true\n            end\n        end\n\n        log_warning(\"[LobbyFlow] Move to in-game failed. userId=\", userId, \", map=\", self.InGameMapName)\n        return false\n    end\n\n    -- Lobby transition mirrors in-game transition API for consistent map split flow.\n    @ExecSpace(\"ServerOnly\")\n    method boolean MoveOwnerToLobbyMapIfNeeded()\n        local userId = self:GetOwnerUserId()\n        return self:MoveUserToLobbyMapByUserId(userId)\n    end\n\n    @ExecSpace(\"ServerOnly\")\n    method boolean MoveUserToLobbyMapByUserId(string userId)\n        if self.UseMapSplit == false then\n            return true\n        end\n\n        if userId == nil or userId == \"\" then\n            return false\n        end\n\n        local moveOk, moved = pcall(function()\n            return _RoomService:MoveUserToStaticRoom(userId, self.LobbyMapName)\n        end)\n        if moveOk == true and moved == true then\n            return true\n        end\n\n        local lobbyUri = self.LobbyMapName\n        if string.sub(self.LobbyMapName, 1, 6) ~= \"map://\" then\n            lobbyUri = \"map://\" .. self.LobbyMapName\n        end\n\n        local uriOk, uriMoved = pcall(function()\n            return _RoomService:MoveUserToStaticRoom(userId, lobbyUri)\n        end)\n        if uriOk == true and uriMoved == true then\n            return true\n        end\n\n        local lobbyPath = self.LobbyMapName\n        if string.sub(self.LobbyMapName, 1, 6) ~= \"/maps/\" then\n            lobbyPath = \"/maps/\" .. self.LobbyMapName\n        end\n\n        local pathOk, pathMoved = pcall(function()\n            return _RoomService:MoveUserToStaticRoom(userId, lobbyPath)\n        end)\n        if pathOk == true and pathMoved == true then\n            return true\n        end\n\n        return false\n    end\n\n    -- Owner resolver is shared by room move and ownership checks.\n    method string GetOwnerUserId()\n        local userId = \"\"\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent ~= nil then\n            local playerOk, playerUserId = pcall(function()\n                return playerComponent.UserId\n            end)\n            if playerOk == true and playerUserId ~= nil and playerUserId ~= \"\" then\n                userId = playerUserId\n            end\n        end\n\n        if userId ~= \"\" then\n            return userId\n        end\n\n        local localPlayer = _UserService.LocalPlayer\n        if localPlayer ~= nil and isvalid(localPlayer) == true then\n            local localOk, localUserId = pcall(function()\n                return localPlayer.PlayerComponent.UserId\n            end)\n            if localOk == true and localUserId ~= nil then\n                return localUserId\n            end\n        end\n\n        return \"\"\n    end\n\n    -- Movement lock uses GR utility path first to keep cross-component field writes consistent.\n    method boolean SetCanMoveSafely(boolean canMove)\n        if self._T.GRUtil ~= nil and self._T.GRUtil.TrySetCanMove ~= nil then\n            return self._T.GRUtil.TrySetCanMove(self.Entity, canMove)\n        end\n\n        local movementComponent = self:ResolveComponentSafe(self.Entity, \"MovementComponent\", \"CanMove\")\n        if movementComponent == nil then\n            return false\n        end\n\n        local ok, _ = pcall(function()\n            movementComponent.CanMove = canMove\n        end)\n        return ok\n    end\n\n    -- Attack lock mirrors movement lock and degrades safely when combat component is absent.\n    method boolean SetCanAttackSafely(boolean canAttack)\n        local fireComponent = self:ResolveComponentSafe(self.Entity, \"FireSystemComponent\", \"CanAttack\")\n        if fireComponent == nil then\n            return false\n        end\n\n        if self._T.GRUtil ~= nil and self._T.GRUtil.TrySetField ~= nil then\n            return self._T.GRUtil.TrySetField(fireComponent, \"CanAttack\", canAttack)\n        end\n\n        local ok, _ = pcall(function()\n            fireComponent.CanAttack = canAttack\n        end)\n        return ok\n    end\n\n    -- EndPlay clears button handlers and debounce timer to avoid duplicated callbacks on re-enter.\n    method void OnEndPlay()\n        local startButton = self:ResolveUIEntity(self.StartButtonPath)\n        if startButton ~= nil and self._T.StartButtonHandler ~= nil then\n            pcall(function()\n                startButton:DisconnectEvent(ButtonClickEvent, self._T.StartButtonHandler)\n            end)\n        end\n        self._T.StartButtonHandler = nil\n\n        if self._T.StartButtonDebounceTimerId ~= nil and self._T.StartButtonDebounceTimerId > 0 then\n            _TimerService:ClearTimer(self._T.StartButtonDebounceTimerId)\n            self._T.StartButtonDebounceTimerId = 0\n        end\n        self._T.StartButtonDebounce = false\n        self._T.StartButtonRetryRemain = 0\n    end\n\n    -- Utility bootstrap first; fallback local lookup remains when global utility registration fails.\n    method void EnsureGRUtil()\n        if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, utilApi = pcall(function()\n                return utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and utilApi ~= nil then\n                self._T.GRUtil = utilApi\n            end\n            if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    method any ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then\n            return self._T.GRUtil.ResolveComponent(targetEntity, scriptName, markerField)\n        end\n\n        local prefixedName = scriptName\n        local plainName = scriptName\n        if string.sub(scriptName, 1, 7) == \"script.\" then\n            plainName = string.sub(scriptName, 8)\n        else\n            prefixedName = \"script.\" .. scriptName\n        end\n\n        local component = targetEntity:GetComponent(prefixedName)\n        if component == nil then\n            component = targetEntity:GetComponent(plainName)\n        end\n        if component == nil then\n            return nil\n        end\n\n        if markerField ~= nil and markerField ~= \"\" then\n            local ok, _ = pcall(function()\n                return component[markerField]\n            end)\n            if ok == false then\n                return nil\n            end\n        end\n\n        return component\n    end\n\n    method boolean IsOwnerRequest(string requestUserId)\n        if self._T.GRUtil ~= nil and self._T.GRUtil.IsOwner ~= nil then\n            return self._T.GRUtil.IsOwner(self.Entity, requestUserId)\n        end\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent == nil then\n            return true\n        end\n\n        if requestUserId == nil or requestUserId == \"\" then\n            return true\n        end\n\n        return requestUserId == playerComponent.UserId\n    end\nend\n"
    }
  }
}