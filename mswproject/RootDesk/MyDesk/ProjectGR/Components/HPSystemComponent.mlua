@Component
script HPSystemComponent extends Component

    @Sync
    property integer MaxHP = 100
    @Sync
    property integer CurrentHP = 100
    property integer DamageReduction = 0
    @Sync
    property boolean IsInvincible = false
    property number InvincibleDuration = 1.0
    property number CriticalHPRatio = 0.3
    @Sync
    property boolean IsDead = false
    property integer FallbackDamage = 1

    -- Server initializes HP state once to avoid first-frame sync races.
    @ExecSpace("ServerOnly")
    method void OnInitialize()
        self.CurrentHP = math.max(0, math.min(self.CurrentHP, self.MaxHP))
        self.IsInvincible = false
        self.IsDead = (self.CurrentHP <= 0)
        self._T.InvincibleTimerId = 0
    end

    -- Broadcasts initial HP state so UI can render immediately on begin play.
    @ExecSpace("ServerOnly")
    method void OnBeginPlay()
        self:BroadcastHPState()
    end

    -- Damage intake remains server authoritative and resolves incoming source safely.
    @ExecSpace("ServerOnly")
    @EventSender("Self")
    handler HandleTriggerEnterEvent(TriggerEnterEvent event)
        local triggerBodyEntity = event.TriggerBodyEntity
        local incomingDamage = self:ResolveIncomingDamage(triggerBodyEntity)
        if incomingDamage <= 0 then
            return
        end

        self:ApplyDamage(incomingDamage)
    end

    -- Reads damage from known attack components with safe fallbacks.
    @ExecSpace("ServerOnly")
    method integer ResolveIncomingDamage(Entity sourceEntity)
        if sourceEntity == nil or isvalid(sourceEntity) == false then
            return 0
        end

        local projectile = sourceEntity:GetComponent("ProjectileComponent")
        if projectile ~= nil and isvalid(projectile) == true then
            if projectile.Damage ~= nil then
                return math.max(math.floor(projectile.Damage), 0)
            end
            if projectile.AttackPower ~= nil then
                return math.max(math.floor(projectile.AttackPower), 0)
            end
        end

        local monsterAttack = sourceEntity:GetComponent("MonsterAttackComponent")
        if monsterAttack ~= nil and isvalid(monsterAttack) == true then
            if monsterAttack.AttackPower ~= nil then
                return math.max(math.floor(monsterAttack.AttackPower), 0)
            end
        end

        return math.max(self.FallbackDamage, 0)
    end

    -- Applies HP damage with invincible and death checks in one authoritative path.
    @ExecSpace("ServerOnly")
    method void ApplyDamage(integer rawDamage)
        if self.IsDead == true then
            return
        end
        if self.IsInvincible == true then
            return
        end
        if rawDamage <= 0 then
            return
        end

        local actualDamage = rawDamage - self.DamageReduction
        if actualDamage < 0 then
            actualDamage = 0
        end

        self.CurrentHP = math.max(self.CurrentHP - actualDamage, 0)
        if actualDamage > 0 then
            self:StartInvincibleWindow()
        end

        self:EvaluateDeath()
        self:BroadcastHPState()
    end

    -- Uses timer-based invincibility window instead of frame polling.
    @ExecSpace("ServerOnly")
    method void StartInvincibleWindow()
        if self.InvincibleDuration <= 0 then
            self.IsInvincible = false
            return
        end

        if self._T.InvincibleTimerId ~= nil and self._T.InvincibleTimerId > 0 then
            _TimerService:ClearTimer(self._T.InvincibleTimerId)
            self._T.InvincibleTimerId = 0
        end

        self.IsInvincible = true

        local releaseInvincible = function()
            self.IsInvincible = false
            self._T.InvincibleTimerId = 0
            self:BroadcastHPState()
        end

        self._T.InvincibleTimerId = _TimerService:SetTimerOnce(releaseInvincible, self.InvincibleDuration)
    end

    -- Healing is validated on server and clamped to MaxHP.
    @ExecSpace("ServerOnly")
    method void Heal(integer amount)
        if amount <= 0 then
            return
        end
        if self.IsDead == true then
            return
        end

        self.CurrentHP = math.min(self.CurrentHP + amount, self.MaxHP)
        self:BroadcastHPState()
    end

    -- Resets death/invincible state for the next run entry.
    @ExecSpace("ServerOnly")
    method void ReviveToFullHP()
        if self._T.InvincibleTimerId ~= nil and self._T.InvincibleTimerId > 0 then
            _TimerService:ClearTimer(self._T.InvincibleTimerId)
            self._T.InvincibleTimerId = 0
        end

        self.CurrentHP = math.max(self.MaxHP, 1)
        self.IsInvincible = false
        self.IsDead = false
        self._T.IsDeadUIOpened = false
        self:BroadcastHPState()
    end

    -- Death state is finalized once and triggers the game-over flow.
    @ExecSpace("ServerOnly")
    method void EvaluateDeath()
        if self.CurrentHP > 0 then
            return
        end
        if self.IsDead == true then
            return
        end

        self.IsDead = true
        self.IsInvincible = false

        self:TrySetMovementCanMove(false)

        self:NotifyGameOver()
    end

    -- Resolves custom movement component first to avoid native MovementComponent name collisions.
    method Component ResolveProjectMovementComponent()
        local prefixed = self.Entity:GetComponent("script.MovementComponent")
        if self:CanWriteComponentField(prefixed, "CanMove") == true then
            return prefixed
        end

        local plain = self.Entity:GetComponent("MovementComponent")
        if self:CanWriteComponentField(plain, "CanMove") == true then
            return plain
        end

        return nil
    end

    -- Protects death-lock writes from runtime exceptions when wrong component type is returned.
    method boolean TrySetMovementCanMove(boolean canMove)
        local movementComponent = self:ResolveProjectMovementComponent()
        if movementComponent == nil then
            return false
        end

        local ok, _ = pcall(function()
            movementComponent.CanMove = canMove
        end)
        if ok == false then
            log_warning("[HPSystemComponent] Failed to set MovementComponent.CanMove")
            return false
        end

        return true
    end

    -- Uses read+write probe so nil-valued fields are still recognized while missing fields are rejected.
    method boolean CanWriteComponentField(any targetComponent, string fieldName)
        if targetComponent == nil or isvalid(targetComponent) == false then
            return false
        end
        if fieldName == nil or fieldName == "" then
            return false
        end

        local readOk, readValue = pcall(function()
            return targetComponent[fieldName]
        end)
        if readOk == false then
            return false
        end

        local writeOk, _ = pcall(function()
            targetComponent[fieldName] = readValue
        end)
        return writeOk
    end

    -- Game-over routing prefers LobbyFlow, then GameManager, then timer-only fallback.
    @ExecSpace("ServerOnly")
    method void NotifyGameOver()
        local lobbyFlow = self.Entity:GetComponent("LobbyFlowComponent")
        if lobbyFlow ~= nil and isvalid(lobbyFlow) == true then
            if lobbyFlow.HandleStageFailedServer ~= nil then
                lobbyFlow:HandleStageFailedServer()
                return
            end
            if lobbyFlow.HandleRunCompletedServer ~= nil then
                lobbyFlow:HandleRunCompletedServer(false)
                return
            end
        end

        local gameManager = self.Entity:GetComponent("GameManagerComponent")
        if gameManager ~= nil and isvalid(gameManager) == true then
            if gameManager.OnPlayerDead ~= nil then
                gameManager:OnPlayerDead(self.Entity)
            end
            return
        end

        local timerComponent = self.Entity:GetComponent("SpeedrunTimerComponent")
        if timerComponent ~= nil and isvalid(timerComponent) == true then
            timerComponent:CompleteRun()
        end

        log_warning("[HPSystemComponent] Fallback game-over flow used. LobbyFlow/GameManager not found.")
    end

    -- Sends current HP state to client-side feedback handler.
    @ExecSpace("ServerOnly")
    method void BroadcastHPState()
        self:UpdateHPFeedbackClient(self.CurrentHP, self.MaxHP, self.IsInvincible, self.IsDead)
    end

    -- Client feedback stays visual-only while authority remains on server.
    @ExecSpace("Client")
    method void UpdateHPFeedbackClient(integer currentHp, integer maxHp, boolean isInvincible, boolean isDead)
        self:UpdateInvincibleBlink(isInvincible)
        self:UpdateCriticalWarning(currentHp, maxHp)

        if isDead == true then
            self:HandleDeadUI()
        end
    end

    -- Toggles invincible blink loop.
    @ExecSpace("ClientOnly")
    method void UpdateInvincibleBlink(boolean isInvincible)
        if isInvincible == true then
            self:StartInvincibleBlink()
            return
        end

        self:StopInvincibleBlink()
    end

    -- Uses timer-based blink to avoid per-frame overhead.
    @ExecSpace("ClientOnly")
    method void StartInvincibleBlink()
        if self._T.BlinkTimerId ~= nil and self._T.BlinkTimerId > 0 then
            return
        end

        local spriteRenderer = self.Entity.SpriteRendererComponent
        if spriteRenderer == nil or isvalid(spriteRenderer) == false then
            return
        end

        self._T.BlinkVisible = true

        local blinkTick = function()
            if self.IsInvincible == false then
                self:StopInvincibleBlink()
                return
            end

            self._T.BlinkVisible = not self._T.BlinkVisible
            if self._T.BlinkVisible == true then
                spriteRenderer.Color = Color(1, 1, 1, 1)
            else
                spriteRenderer.Color = Color(1, 1, 1, 0.35)
            end
        end

        self._T.BlinkTimerId = _TimerService:SetTimerRepeat(blinkTick, 0.1, 0.0)
    end

    -- Restores default color when invincible blink ends.
    @ExecSpace("ClientOnly")
    method void StopInvincibleBlink()
        if self._T.BlinkTimerId ~= nil and self._T.BlinkTimerId > 0 then
            _TimerService:ClearTimer(self._T.BlinkTimerId)
            self._T.BlinkTimerId = 0
        end

        local spriteRenderer = self.Entity.SpriteRendererComponent
        if spriteRenderer ~= nil and isvalid(spriteRenderer) == true then
            spriteRenderer.Color = Color.white
        end
    end

    -- Computes critical state for downstream UI warning logic.
    @ExecSpace("ClientOnly")
    method void UpdateCriticalWarning(integer currentHp, integer maxHp)
        if maxHp <= 0 then
            self._T.IsCritical = false
            return
        end

        local hpRatio = currentHp / maxHp
        self._T.IsCritical = (hpRatio < self.CriticalHPRatio)
    end

    -- Prevents repeated game-over UI trigger spam.
    @ExecSpace("ClientOnly")
    method void HandleDeadUI()
        if self._T.IsDeadUIOpened == true then
            return
        end

        self._T.IsDeadUIOpened = true
        log("[HPSystemComponent] Game Over UI trigger requested.")
    end

    -- Clears server timer on end play.
    @ExecSpace("ServerOnly")
    method void OnEndPlay()
        if self._T.InvincibleTimerId ~= nil and self._T.InvincibleTimerId > 0 then
            _TimerService:ClearTimer(self._T.InvincibleTimerId)
            self._T.InvincibleTimerId = 0
        end
    end
end

