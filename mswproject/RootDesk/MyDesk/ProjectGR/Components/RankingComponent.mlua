@Component
script RankingComponent extends Component

    property number TimeAttackBestTime = -1
    property integer InfiniteModeBestKills = 0

    property number MinimumValidTime = 5.0
    property number MaximumValidTime = 7200.0
    property integer MaximumValidKills = 1000000
    property string RankingStorageName = "RankingStorage"

    -- 타임어택 결과는 서버 검증 후에만 반영해 비정상 클리어 타임 기록을 차단한다.
    @ExecSpace("ServerOnly")
    method void SubmitTimeAttackResult(number elapsedTime, integer stageId)
        if self:IsValidTimeAttackScore(elapsedTime) == false then
            return
        end

        local isNewRecord = (self.TimeAttackBestTime < 0 or elapsedTime < self.TimeAttackBestTime)
        if isNewRecord == false then
            return
        end

        self.TimeAttackBestTime = elapsedTime
        self:SavePersonalBest("TimeAttack", elapsedTime)
        self:UpsertRankingRecord("TimeAttack", elapsedTime, stageId)
        self:TrySubmitLeaderBoardService("TimeAttack", elapsedTime)
    end

    -- 무한모드 기록도 서버에서 상한 검증 후에만 갱신해 비정상 처치수 유입을 막는다.
    @ExecSpace("ServerOnly")
    method void SubmitInfiniteModeResult(integer kills)
        if kills < 0 then
            return
        end
        if kills > self.MaximumValidKills then
            return
        end

        local isNewRecord = (kills > self.InfiniteModeBestKills)
        if isNewRecord == false then
            return
        end

        self.InfiniteModeBestKills = kills
        self:SavePersonalBest("Infinite", kills)
        self:UpsertRankingRecord("Infinite", kills, 0)
        self:TrySubmitLeaderBoardService("Infinite", kills)
    end

    -- 랭킹 조회는 서버에서 상위 목록/내 순위를 계산한 뒤 클라이언트에 전달한다.
    @ExecSpace("Server")
    method void RequestRankingDataServer(integer mode, integer displayCount)
        local modeTag = self:GetModeTag(mode)
        if modeTag == "" then
            return
        end

        local safeCount = math.max(1, math.min(displayCount, 100))
        local sortedRecords = self:LoadAndSortRecords(modeTag)
        local topEntries = self:BuildTopEntries(mode, sortedRecords, safeCount)
        local myInfo = self:FindMyRank(mode, sortedRecords)
        local myRank = myInfo.Rank
        local myValue = myInfo.Value

        self:UpdateRankingDataClient(mode, topEntries, myRank, myValue)
    end

    -- 타임어택 최소/최대치를 검증해 물리적으로 불가능한 기록을 컷한다.
    method boolean IsValidTimeAttackScore(number score)
        if score < self.MinimumValidTime then
            return false
        end
        if score > self.MaximumValidTime then
            return false
        end
        return true
    end

    -- 모드 태그를 문자열로 표준화해 저장/조회 키 규칙을 일관되게 유지한다.
    method string GetModeTag(integer mode)
        if mode == 1 then
            return "TimeAttack"
        end
        if mode == 2 then
            return "Infinite"
        end
        return ""
    end

    -- 개인 최고 기록은 별도 키로 저장해 결과 화면 신기록 판정 비용을 줄인다.
    @ExecSpace("ServerOnly")
    method void SavePersonalBest(string modeTag, any scoreValue)
        local userId = self:GetOwnerUserId()
        local storage = _DataStorageService:GetGlobalDataStorage(self.RankingStorageName)
        if storage == nil then
            return
        end

        local key = modeTag .. "_Best_" .. userId
        storage:SetAndWait(key, tostring(scoreValue))
    end

    -- 기록 저장은 DataStorage tag를 함께 써서 모드별 전체 조회를 가능하게 한다.
    @ExecSpace("ServerOnly")
    method void UpsertRankingRecord(string modeTag, any scoreValue, integer stageId)
        local userId = self:GetOwnerUserId()
        local userName = self:GetOwnerDisplayName()
        local storage = _DataStorageService:GetGlobalDataStorage(self.RankingStorageName)
        if storage == nil then
            return
        end

        local key = modeTag .. "_Score_" .. userId
        local score = tonumber(scoreValue)
        if score == nil then
            score = 0
        end

        local payload = self:SerializeRecord(score, userName, _UtilLogic.ServerElapsedSeconds, stageId)
        local keyInfo = DataStorageKeyInfo(key, "", modeTag)
        storage:SetByInfoAndWait(keyInfo, payload)
    end

    -- 저장된 레코드를 모두 읽어 모드별 정렬 규칙으로 서버에서 확정 순위를 계산한다.
    @ExecSpace("ServerOnly")
    method table LoadAndSortRecords(string modeTag)
        local records = {}
        local storage = _DataStorageService:GetGlobalDataStorage(self.RankingStorageName)
        if storage == nil then
            return records
        end

        local errorCode, pages = storage:GetPagesAndWait(modeTag)
        if errorCode ~= 0 or pages == nil then
            return records
        end

        while true do
            local items = pages:GetCurrentPageDatas()
            for _, item in pairs(items) do
                local key = item.KeyInfo.Key
                local value = item.Value
                local userId = self:ExtractUserIdFromKey(key)
                local parsed = self:DeserializeRecord(value)

                local row = {
                    UserId = userId,
                    Name = parsed.Name,
                    Score = parsed.Score,
                    Timestamp = parsed.Timestamp,
                    StageId = parsed.StageId
                }
                table.insert(records, row)
            end

            if pages.IsLastPage == true then
                break
            end
            pages:MoveToNextPageAndWait()
        end

        table.sort(records, function(a, b)
            if modeTag == "TimeAttack" then
                if a.Score == b.Score then
                    return a.Timestamp < b.Timestamp
                end
                return a.Score < b.Score
            end

            if a.Score == b.Score then
                return a.Timestamp < b.Timestamp
            end
            return a.Score > b.Score
        end)

        return records
    end

    -- 상위 목록은 클라이언트 렌더 전용 최소 데이터로 재구성해 네트워크 부하를 줄인다.
    method table BuildTopEntries(integer mode, table sortedRecords, integer displayCount)
        local entries = {}
        local maxIndex = math.min(displayCount, #sortedRecords)

        for index = 1, maxIndex do
            local row = sortedRecords[index]
            local entry = {
                Rank = index,
                Name = row.Name,
                Value = self:FormatScore(mode, row.Score),
                StageId = row.StageId,
                Timestamp = row.Timestamp
            }
            table.insert(entries, entry)
        end

        return entries
    end

    -- 내 순위 계산을 서버에서 수행해 클라이언트 조작으로 순위 위조가 되지 않게 한다.
    method table FindMyRank(integer mode, table sortedRecords)
        local myUserId = self:GetOwnerUserId()
        for index, row in ipairs(sortedRecords) do
            if row.UserId == myUserId then
                return {
                    Rank = index,
                    Value = self:FormatScore(mode, row.Score)
                }
            end
        end

        return {
            Rank = -1,
            Value = "-"
        }
    end

    -- 클라이언트 UI 갱신은 전용 함수로 분리해 RankingUIComponent와 결합을 느슨하게 유지한다.
    @ExecSpace("Client")
    method void UpdateRankingDataClient(integer mode, table entries, integer myRank, string myValue)
        local rankingUI = self.Entity:GetComponent("RankingUIComponent")
        if rankingUI == nil or isvalid(rankingUI) == false then
            return
        end

        rankingUI:ApplyRankingData(mode, entries, myRank, myValue)
    end

    -- LeaderBoardService API가 확인되지 않은 환경을 고려해 안전한 옵셔널 호출로 처리한다.
    @ExecSpace("ServerOnly")
    method void TrySubmitLeaderBoardService(string modeTag, any scoreValue)
        if _LeaderBoardService == nil then
            return
        end

        if _LeaderBoardService.SubmitScore ~= nil then
            _LeaderBoardService:SubmitScore(modeTag, scoreValue)
            return
        end
        if _LeaderBoardService.SetScore ~= nil then
            _LeaderBoardService:SetScore(modeTag, scoreValue)
        end
    end

    -- 점수 포맷 함수로 타임어택/무한모드 표시 규칙을 일관되게 유지한다.
    method string FormatScore(integer mode, number score)
        if mode == 1 then
            local timerComponent = self.Entity:GetComponent("SpeedrunTimerComponent")
            if timerComponent ~= nil and isvalid(timerComponent) == true then
                return timerComponent:FormatElapsedTime(score)
            end
        end

        return tostring(math.floor(score))
    end

    -- 레코드 직렬화를 단일 함수로 처리해 저장 포맷 변경 시 영향 범위를 줄인다.
    method string SerializeRecord(number score, string userName, number timestamp, integer stageId)
        return tostring(score) .. "|" .. userName .. "|" .. tostring(timestamp) .. "|" .. tostring(stageId)
    end

    -- 레코드 역직렬화는 안전 파싱으로 처리해 손상된 데이터도 서비스 장애 없이 건너뛴다.
    method table DeserializeRecord(string serialized)
        if serialized == nil or serialized == "" then
            return {
                Score = 0,
                Name = "Unknown",
                Timestamp = 0,
                StageId = 0
            }
        end

        local parts = _UtilLogic:Split(serialized, "|")
        return {
            Score = tonumber(parts[1]) or 0,
            Name = parts[2] or "Unknown",
            Timestamp = tonumber(parts[3]) or 0,
            StageId = tonumber(parts[4]) or 0
        }
    end

    -- 키에서 userId를 추출해 저장 포맷과 사용자 식별 로직을 분리한다.
    method string ExtractUserIdFromKey(string key)
        if key == nil then
            return ""
        end

        local parts = _UtilLogic:Split(key, "_")
        if #parts == 0 then
            return key
        end

        return parts[#parts]
    end

    -- 소유자 userId 조회를 공통화해 PlayerComponent 의존 코드를 한곳에서 관리한다.
    method string GetOwnerUserId()
        if self.Entity ~= nil and self.Entity.PlayerComponent ~= nil then
            return self.Entity.PlayerComponent.UserId
        end
        return "UnknownUser"
    end

    -- 표시 닉네임 조회 실패 시 기본값을 반환해 랭킹 UI 깨짐을 방지한다.
    method string GetOwnerDisplayName()
        if self.Entity ~= nil and self.Entity.NameTagComponent ~= nil then
            return self.Entity.NameTagComponent.Name
        end
        return "Unknown"
    end
end
