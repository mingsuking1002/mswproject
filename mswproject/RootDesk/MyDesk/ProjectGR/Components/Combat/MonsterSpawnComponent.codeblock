{
  "Id": "",
  "GameId": "",
  "EntryKey": "codeblock://4e967c56-ac4e-4b40-aabe-e625456987da",
  "ContentType": "x-mod/codeblock",
  "Content": "",
  "Usage": 0,
  "UsePublish": 1,
  "UseService": 0,
  "CoreVersion": "26.1.0.0",
  "StudioVersion": "",
  "DynamicLoading": 0,
  "ContentProto": {
    "Use": "Json",
    "Json": {
      "CoreVersion": {
        "Major": 0,
        "Minor": 2
      },
      "ScriptVersion": {
        "Major": 1,
        "Minor": 1
      },
      "Description": "",
      "Id": "4e967c56-ac4e-4b40-aabe-e625456987da",
      "Language": 1,
      "Name": "MonsterSpawnComponent",
      "Type": 1,
      "Source": 1,
      "Target": "@Component\nscript MonsterSpawnComponent extends Component\n\n    property string SpawnConfigTableName = \"SpawnConfig\"\n    property string MonsterDataTableName = \"MonsterData\"\n    property string SpawnWaveTableName = \"\"\n\n    @Sync\n    property boolean IsSpawnActive = false\n    @Sync\n    property boolean IsBossPhase = false\n    property Entity MonsterParentEntity = nil\n\n    property string MonsterContainerName = \"MonsterContainer\"\n    property number StateMonitorInterval = 0.2\n\n    -- Server initializes all runtime caches once so spawn flow remains deterministic after hot-reload.\n    @ExecSpace(\"ServerOnly\")\n    method void OnInitialize()\n        self:EnsureGRUtil()\n\n        self._T.SpawnTimerId = 0\n        self._T.StateMonitorTimerId = 0\n        self._T.SpawnedMonsters = {}\n        self._T.SpawnMetaByEntity = {}\n        self._T.Config = nil\n        self._T.MonsterRows = {}\n        self._T.ModelTypeByMonType = nil\n        self._T.RowFallbackModelById = nil\n        self._T.BossSpawnedEntity = nil\n        self._T.WarnedMissingContainer = false\n        self._T.DataReady = false\n\n        self.IsSpawnActive = false\n        self.IsBossPhase = false\n    end\n\n    -- BeginPlay loads DataTable snapshots first, then starts safe-zone aware monitor loop.\n    @ExecSpace(\"ServerOnly\")\n    method void OnBeginPlay()\n        self:LoadSpawnDataFromTable()\n        self:ResolveMonsterParentEntity()\n        self:StartStateMonitorTimer()\n        self:RefreshSpawnStateServer()\n    end\n\n    -- Map enter re-resolves parent entity because map transition can invalidate previous references.\n    @ExecSpace(\"ServerOnly\")\n    method void OnMapEnter(Entity enteredMap)\n        self:ResolveMonsterParentEntity()\n        self:RefreshSpawnStateServer()\n    end\n\n    -- EndPlay clears active timers so delayed callbacks never run on recycled entities.\n    @ExecSpace(\"ServerOnly\")\n    method void OnEndPlay()\n        self:StopSpawning()\n\n        if self._T.StateMonitorTimerId ~= nil and self._T.StateMonitorTimerId > 0 then\n            _TimerService:ClearTimer(self._T.StateMonitorTimerId)\n            self._T.StateMonitorTimerId = 0\n        end\n    end\n\n    -- Destroy repeats timer cleanup as final safety net for unusual lifecycle paths.\n    @ExecSpace(\"ServerOnly\")\n    method void OnDestroy()\n        if self._T.SpawnTimerId ~= nil and self._T.SpawnTimerId > 0 then\n            _TimerService:ClearTimer(self._T.SpawnTimerId)\n            self._T.SpawnTimerId = 0\n        end\n        if self._T.StateMonitorTimerId ~= nil and self._T.StateMonitorTimerId > 0 then\n            _TimerService:ClearTimer(self._T.StateMonitorTimerId)\n            self._T.StateMonitorTimerId = 0\n        end\n    end\n\n    -- One entrypoint loads both config and monster table so availability gate is centralized.\n    @ExecSpace(\"ServerOnly\")\n    method boolean LoadSpawnDataFromTable()\n        local configLoaded = self:LoadSpawnConfigFromTable()\n        local monsterLoaded = self:LoadMonsterDataFromTable()\n\n        self._T.DataReady = (configLoaded == true and monsterLoaded == true)\n        if self._T.DataReady == false then\n            self:StopSpawning()\n        end\n\n        return self._T.DataReady\n    end\n\n    -- Config table is mandatory because all balance values are data-driven by SPEC.\n    @ExecSpace(\"ServerOnly\")\n    method boolean LoadSpawnConfigFromTable()\n        self._T.Config = nil\n\n        if self.SpawnConfigTableName == nil or self.SpawnConfigTableName == \"\" then\n            self:LogError(\"[MonsterSpawnComponent] SpawnConfigTableName is empty.\")\n            return false\n        end\n\n        local tableData = nil\n        local loadOk, loadResult = pcall(function()\n            return _DataService:GetTable(self.SpawnConfigTableName)\n        end)\n        if loadOk == true then\n            tableData = loadResult\n        end\n        if tableData == nil then\n            self:LogError(\"[MonsterSpawnComponent] Failed to load SpawnConfig table: \" .. tostring(self.SpawnConfigTableName))\n            return false\n        end\n\n        local row = nil\n        local rowOk, rowResult = pcall(function()\n            return tableData:GetRow(1)\n        end)\n        if rowOk == true then\n            row = rowResult\n        end\n        if row == nil then\n            self:LogError(\"[MonsterSpawnComponent] SpawnConfig row(1) is missing.\")\n            return false\n        end\n\n        local innerRadius = self:GetRowNumber(row, \"InnerRadius\", -1)\n        local outerRadius = self:GetRowNumber(row, \"OuterRadius\", -1)\n        local spawnInterval = self:GetRowNumber(row, \"SpawnInterval\", -1)\n        local spawnPerTick = self:GetRowInteger(row, \"SpawnPerTick\", -1)\n        local maxFieldMonsters = self:GetRowInteger(row, \"MaxFieldMonsters\", -1)\n        local maxRetryCount = self:GetRowInteger(row, \"MaxRetryCount\", -1)\n\n        if innerRadius < 0 or outerRadius < 0 or spawnInterval <= 0 or spawnPerTick <= 0 or maxFieldMonsters <= 0 or maxRetryCount <= 0 then\n            self:LogError(\"[MonsterSpawnComponent] Invalid SpawnConfig values. Check SpawnConfig.csv.\")\n            return false\n        end\n        if outerRadius < innerRadius then\n            self:LogError(\"[MonsterSpawnComponent] OuterRadius must be >= InnerRadius.\")\n            return false\n        end\n\n        local config = {}\n        config.InnerRadius = innerRadius\n        config.OuterRadius = outerRadius\n        config.SpawnInterval = spawnInterval\n        config.SpawnPerTick = spawnPerTick\n        config.MaxFieldMonsters = maxFieldMonsters\n        config.MaxRetryCount = maxRetryCount\n\n        self._T.Config = config\n        return true\n    end\n\n    -- MonsterData table is single source of truth for wave and drop metadata in current iteration.\n    @ExecSpace(\"ServerOnly\")\n    method boolean LoadMonsterDataFromTable()\n        self._T.MonsterRows = {}\n        self._T.ModelTypeByMonType = nil\n        self._T.RowFallbackModelById = nil\n\n        local tableName = self:ResolveMonsterDataTableName()\n        if tableName == \"\" then\n            self:LogError(\"[MonsterSpawnComponent] MonsterDataTableName is empty.\")\n            return false\n        end\n\n        local tableData = nil\n        local loadOk, loadResult = pcall(function()\n            return _DataService:GetTable(tableName)\n        end)\n        if loadOk == true then\n            tableData = loadResult\n        end\n        if tableData == nil then\n            self:LogError(\"[MonsterSpawnComponent] Failed to load MonsterData table: \" .. tostring(tableName))\n            return false\n        end\n\n        local rows = nil\n        local rowsOk, rowsResult = pcall(function()\n            return tableData:GetAllRow()\n        end)\n        if rowsOk == true then\n            rows = rowsResult\n        end\n        if rows == nil or #rows <= 0 then\n            self:LogError(\"[MonsterSpawnComponent] MonsterData has no rows.\")\n            return false\n        end\n\n        self._T.MonsterRows = rows\n        self:BuildRowModelFallbackCache(rows)\n        return true\n    end\n\n    -- Fallback cache keeps CSV authoring flexible when repetitive model_type cells are intentionally left empty.\n    method void BuildRowModelFallbackCache(table rows)\n        self._T.RowFallbackModelById = {}\n        self._T.ModelTypeByMonType = {}\n\n        if rows == nil or #rows <= 0 then\n            return\n        end\n\n        local lastModelByType = {}\n        for index = 1, #rows do\n            local row = rows[index]\n            if row == nil then\n                continue\n            end\n\n            local rowId = self:GetRowString(row, \"id\", \"\")\n            local monType = string.lower(self:GetRowString(row, \"mon_type\", \"\"))\n            local modelType = self:GetRowString(row, \"model_type\", \"\")\n\n            if monType ~= \"\" and modelType ~= \"\" and self._T.ModelTypeByMonType[monType] == nil then\n                self._T.ModelTypeByMonType[monType] = modelType\n            end\n\n            if monType ~= \"\" and modelType ~= \"\" then\n                lastModelByType[monType] = modelType\n                continue\n            end\n\n            if rowId ~= \"\" and monType ~= \"\" and lastModelByType[monType] ~= nil then\n                self._T.RowFallbackModelById[rowId] = lastModelByType[monType]\n            end\n        end\n    end\n\n    -- Backward-compatible resolver allows old SPEC alias without blocking current MonsterData naming.\n    method string ResolveMonsterDataTableName()\n        if self.MonsterDataTableName ~= nil and self.MonsterDataTableName ~= \"\" then\n            return self.MonsterDataTableName\n        end\n        if self.SpawnWaveTableName ~= nil and self.SpawnWaveTableName ~= \"\" then\n            return self.SpawnWaveTableName\n        end\n        return \"\"\n    end\n\n    method string GetFallbackModelType(UserDataRow row)\n        if row == nil then\n            return \"\"\n        end\n\n        local rowId = self:GetRowString(row, \"id\", \"\")\n        if rowId ~= \"\" and self._T.RowFallbackModelById ~= nil then\n            local rowFallback = self._T.RowFallbackModelById[rowId]\n            if rowFallback ~= nil and rowFallback ~= \"\" then\n                return rowFallback\n            end\n        end\n\n        local monType = string.lower(self:GetRowString(row, \"mon_type\", \"\"))\n        if monType == \"\" then\n            return \"\"\n        end\n\n        if self._T.ModelTypeByMonType ~= nil then\n            local defaultModel = self._T.ModelTypeByMonType[monType]\n            if defaultModel ~= nil and defaultModel ~= \"\" then\n                return defaultModel\n            end\n        end\n\n        return \"\"\n    end\n\n    -- Parent resolver enforces SPEC decision: no MonsterContainer means spawn stays disabled.\n    @ExecSpace(\"ServerOnly\")\n    method void ResolveMonsterParentEntity()\n        self.MonsterParentEntity = nil\n\n        local mapEntity = self.Entity.CurrentMap\n        if mapEntity == nil or isvalid(mapEntity) == false then\n            return\n        end\n\n        local container = nil\n        local findOk, findResult = pcall(function()\n            return mapEntity:GetChildByName(self.MonsterContainerName, true)\n        end)\n        if findOk == true then\n            container = findResult\n        end\n\n        if container ~= nil and isvalid(container) == true then\n            self.MonsterParentEntity = container\n            self._T.WarnedMissingContainer = false\n            return\n        end\n\n        if self._T.WarnedMissingContainer ~= true then\n            log_warning(\"[MonsterSpawnComponent] MonsterContainer is missing. Spawning remains disabled until container is placed.\")\n            self._T.WarnedMissingContainer = true\n        end\n    end\n\n    -- Monitor timer reacts to lobby/shop safe-zone state without per-frame OnUpdate overhead.\n    @ExecSpace(\"ServerOnly\")\n    method void StartStateMonitorTimer()\n        if self._T.StateMonitorTimerId ~= nil and self._T.StateMonitorTimerId > 0 then\n            return\n        end\n\n        local interval = self.StateMonitorInterval\n        if interval <= 0 then\n            interval = 0.2\n        end\n\n        local callback = function()\n            self:RefreshSpawnStateServer()\n        end\n        self._T.StateMonitorTimerId = _TimerService:SetTimerRepeat(callback, interval, 0)\n    end\n\n    -- Single state gate keeps start/stop transitions deterministic and easy to extend later.\n    @ExecSpace(\"ServerOnly\")\n    method void RefreshSpawnStateServer()\n        if self:CanSpawnNowServer() == true then\n            self:StartSpawning()\n            return\n        end\n\n        self:StopSpawning()\n    end\n\n    -- Spawn readiness checks are centralized so future unknown rules can be appended safely.\n    @ExecSpace(\"ServerOnly\")\n    method boolean CanSpawnNowServer()\n        if self._T.DataReady ~= true then\n            return false\n        end\n        if self.IsBossPhase == true then\n            return false\n        end\n        if self.MonsterParentEntity == nil or isvalid(self.MonsterParentEntity) == false then\n            return false\n        end\n        if self:IsSafeZoneActiveServer() == true then\n            return false\n        end\n\n        return true\n    end\n\n    -- Safe-zone resolver depends only on stable Sync flags to avoid tight coupling to feature internals.\n    @ExecSpace(\"ServerOnly\")\n    method boolean IsSafeZoneActiveServer()\n        local lobbyFlow = self:ResolveComponentSafe(self.Entity, \"LobbyFlowComponent\", \"IsLobbyActive\")\n        if lobbyFlow ~= nil then\n            local lobbyOk, isLobby = pcall(function()\n                return lobbyFlow.IsLobbyActive\n            end)\n            if lobbyOk == true and isLobby == true then\n                return true\n            end\n        end\n\n        local shopManager = self:ResolveComponentSafe(self.Entity, \"ShopManagerComponent\", \"IsShopOpen\")\n        if shopManager ~= nil then\n            local shopOk, isShopOpen = pcall(function()\n                return shopManager.IsShopOpen\n            end)\n            if shopOk == true and isShopOpen == true then\n                return true\n            end\n        end\n\n        return false\n    end\n\n    -- Start path is isolated so timer recreation and sync flag update always happen together.\n    @ExecSpace(\"ServerOnly\")\n    method void StartSpawning()\n        if self._T.SpawnTimerId ~= nil and self._T.SpawnTimerId > 0 then\n            return\n        end\n        if self._T.Config == nil then\n            return\n        end\n\n        local interval = self._T.Config.SpawnInterval\n        if interval <= 0 then\n            return\n        end\n\n        local callback = function()\n            self:SpawnTick()\n        end\n        local timerId = _TimerService:SetTimerRepeat(callback, interval, 0)\n        if timerId == nil or timerId <= 0 then\n            return\n        end\n\n        self._T.SpawnTimerId = timerId\n        self.IsSpawnActive = true\n    end\n\n    -- Stop path clears only one timer id so duplicated ClearTimer calls are avoided.\n    @ExecSpace(\"ServerOnly\")\n    method void StopSpawning()\n        if self._T.SpawnTimerId ~= nil and self._T.SpawnTimerId > 0 then\n            _TimerService:ClearTimer(self._T.SpawnTimerId)\n            self._T.SpawnTimerId = 0\n        end\n        self.IsSpawnActive = false\n    end\n\n    -- Spawn tick executes only lightweight loops and defers unknown features to dedicated extension hooks.\n    @ExecSpace(\"ServerOnly\")\n    method void SpawnTick()\n        if self:CanSpawnNowServer() == false then\n            return\n        end\n\n        self:PruneSpawnedMonsters()\n\n        local config = self._T.Config\n        if config == nil then\n            return\n        end\n        if self:GetSpawnedMonsterCount() >= config.MaxFieldMonsters then\n            return\n        end\n\n        local context = self:ResolveCurrentSpawnContext()\n        local candidates = self:ResolveSpawnCandidates(context.Stage, context.ElapsedSec)\n\n        local bossRows = candidates.BossRows\n        if bossRows ~= nil and #bossRows > 0 then\n            local bossRow = self:SelectLatestRowBySpawnTime(bossRows)\n            local bossEntity = self:SpawnMonsterByRow(bossRow, Vector3(0, 0, 0), true)\n            if bossEntity ~= nil and isvalid(bossEntity) == true then\n                self.IsBossPhase = true\n                self:StopSpawning()\n            end\n            return\n        end\n\n        local normalRows = candidates.NormalRows\n        if normalRows == nil or #normalRows <= 0 then\n            return\n        end\n\n        for i = 1, config.SpawnPerTick do\n            self:PruneSpawnedMonsters()\n            if self:GetSpawnedMonsterCount() >= config.MaxFieldMonsters then\n                break\n            end\n\n            local selectedRow = self:PickRandomRow(normalRows)\n            if selectedRow == nil then\n                break\n            end\n\n            for retry = 1, config.MaxRetryCount do\n                local spawnPosition = self:CalcDonutPosition()\n                if self:IsValidSpawnPosition(spawnPosition) == false then\n                    continue\n                end\n\n                local spawned = self:SpawnMonsterByRow(selectedRow, spawnPosition, false)\n                if spawned ~= nil and isvalid(spawned) == true then\n                    break\n                end\n            end\n        end\n    end\n\n    -- Stage/time context is read from timer component so wave progression stays server-authoritative.\n    @ExecSpace(\"ServerOnly\")\n    method table ResolveCurrentSpawnContext()\n        local context = {}\n        context.Stage = 1\n        context.ElapsedSec = 0\n\n        local timerComponent = self:ResolveComponentSafe(self.Entity, \"SpeedrunTimerComponent\", \"ElapsedTime\")\n        if timerComponent == nil then\n            return context\n        end\n\n        local stageOk, stageValue = pcall(function()\n            return timerComponent.CurrentStageId\n        end)\n        if stageOk == true and stageValue ~= nil then\n            context.Stage = math.max(1, math.floor(stageValue))\n        end\n\n        local elapsedOk, elapsedValue = pcall(function()\n            return timerComponent.ElapsedTime\n        end)\n        if elapsedOk == true and elapsedValue ~= nil then\n            context.ElapsedSec = math.max(0, elapsedValue)\n        end\n\n        return context\n    end\n\n    -- Resolver keeps selection logic in one function so unknown future conditions can be patched quickly.\n    @ExecSpace(\"ServerOnly\")\n    method table ResolveSpawnCandidates(integer stage, number elapsedSec)\n        local result = {}\n        result.NormalRows = {}\n        result.BossRows = {}\n\n        local rows = self._T.MonsterRows\n        if rows == nil then\n            return result\n        end\n\n        for _, row in pairs(rows) do\n            if row == nil then\n                continue\n            end\n\n            local rowStage = self:GetRowInteger(row, \"spawn_stage\", 1)\n            if rowStage ~= stage then\n                continue\n            end\n\n            local spawnMinute = self:GetSpawnMinuteFromRow(row)\n            if spawnMinute < 0 then\n                continue\n            end\n            if elapsedSec < (spawnMinute * 60) then\n                continue\n            end\n\n            if self:IsBossRow(row) == true then\n                table.insert(result.BossRows, row)\n            else\n                table.insert(result.NormalRows, row)\n            end\n        end\n\n        return result\n    end\n\n    method number GetSpawnMinuteFromRow(UserDataRow row)\n        local spawnMinute = self:GetRowNumber(row, \"spawn_time (min)\", -1)\n        if spawnMinute < 0 then\n            spawnMinute = self:GetRowNumber(row, \"spawn_time_min\", -1)\n        end\n        if spawnMinute < 0 then\n            spawnMinute = self:GetRowNumber(row, \"spawn_time\", -1)\n        end\n\n        return spawnMinute\n    end\n\n    method boolean IsBossRow(UserDataRow row)\n        local monType = string.lower(self:GetRowString(row, \"mon_type\", \"\"))\n        return monType == \"boss\"\n    end\n\n    method UserDataRow SelectLatestRowBySpawnTime(table rows)\n        if rows == nil or #rows <= 0 then\n            return nil\n        end\n\n        local selectedRow = rows[1]\n        local latestMinute = self:GetSpawnMinuteFromRow(selectedRow)\n\n        for _, row in pairs(rows) do\n            local rowMinute = self:GetSpawnMinuteFromRow(row)\n            if rowMinute > latestMinute then\n                latestMinute = rowMinute\n                selectedRow = row\n            end\n        end\n\n        return selectedRow\n    end\n\n    method UserDataRow PickRandomRow(table rows)\n        if rows == nil or #rows <= 0 then\n            return nil\n        end\n\n        local randomIndex = math.random(1, #rows)\n        return rows[randomIndex]\n    end\n\n    -- Donut position keeps spawn out of immediate player view while staying near combat area.\n    @ExecSpace(\"ServerOnly\")\n    method Vector3 CalcDonutPosition()\n        local config = self._T.Config\n        if config == nil then\n            return nil\n        end\n\n        local transform = self.Entity.TransformComponent\n        if transform == nil or isvalid(transform) == false then\n            return nil\n        end\n\n        local playerPosition = transform.WorldPosition\n        if playerPosition == nil then\n            return nil\n        end\n\n        local innerRadius = config.InnerRadius\n        local outerRadius = config.OuterRadius\n        if outerRadius < innerRadius then\n            local temp = innerRadius\n            innerRadius = outerRadius\n            outerRadius = temp\n        end\n\n        local randomAngle = math.random() * 2 * math.pi\n        local randomRadius = innerRadius + (math.random() * (outerRadius - innerRadius))\n\n        local x = playerPosition.x + (randomRadius * math.cos(randomAngle))\n        local y = playerPosition.y + (randomRadius * math.sin(randomAngle))\n        return Vector3(x, y, playerPosition.z)\n    end\n\n    -- Validity check intentionally stays basic per SPEC v1.1 (no NavMesh dependency yet).\n    @ExecSpace(\"ServerOnly\")\n    method boolean IsValidSpawnPosition(Vector3 targetPosition)\n        if targetPosition == nil then\n            return false\n        end\n\n        local config = self._T.Config\n        if config == nil then\n            return false\n        end\n\n        local transform = self.Entity.TransformComponent\n        if transform == nil or isvalid(transform) == false then\n            return false\n        end\n\n        local playerPosition = transform.WorldPosition\n        if playerPosition == nil then\n            return false\n        end\n\n        local dx = targetPosition.x - playerPosition.x\n        local dy = targetPosition.y - playerPosition.y\n        local distanceSqr = (dx * dx) + (dy * dy)\n        local innerSqr = config.InnerRadius * config.InnerRadius\n        local outerSqr = config.OuterRadius * config.OuterRadius\n\n        if distanceSqr < innerSqr then\n            return false\n        end\n        if distanceSqr > outerSqr then\n            return false\n        end\n\n        return true\n    end\n\n    -- Spawn path attaches metadata immediately so future drop/reward systems can read one source.\n    @ExecSpace(\"ServerOnly\")\n    method Entity SpawnMonsterByRow(UserDataRow row, Vector3 spawnPosition, boolean isBoss)\n        if row == nil then\n            return nil\n        end\n        if spawnPosition == nil then\n            return nil\n        end\n        if self.MonsterParentEntity == nil or isvalid(self.MonsterParentEntity) == false then\n            return nil\n        end\n\n        local modelId = self:GetRowString(row, \"model_type\", \"\")\n        if modelId == \"\" then\n            modelId = self:GetFallbackModelType(row)\n        end\n        if modelId == \"\" then\n            local rowId = self:GetRowString(row, \"id\", \"(unknown)\")\n            log_warning(\"[MonsterSpawnComponent] Skip spawn because model_type is empty. rowId=\", rowId)\n            return nil\n        end\n\n        local spawnName = self:GetRowString(row, \"id\", \"Monster\")\n        local spawnedEntity = nil\n        local spawnOk, spawnResult = pcall(function()\n            return _SpawnService:SpawnByModelId(modelId, spawnName, spawnPosition, self.MonsterParentEntity)\n        end)\n        if spawnOk == true then\n            spawnedEntity = spawnResult\n        end\n        if spawnedEntity == nil or isvalid(spawnedEntity) == false then\n            return nil\n        end\n\n        if self._T.SpawnedMonsters == nil then\n            self._T.SpawnedMonsters = {}\n        end\n        table.insert(self._T.SpawnedMonsters, spawnedEntity)\n\n        if self._T.SpawnMetaByEntity == nil then\n            self._T.SpawnMetaByEntity = {}\n        end\n        self._T.SpawnMetaByEntity[spawnedEntity] = self:BuildSpawnMetaFromRow(row)\n\n        self:ApplyMonsterVisualIfAvailable(spawnedEntity, row)\n        self:ApplyMonsterStatsIfAvailable(spawnedEntity, row)\n\n        if isBoss == true then\n            self._T.BossSpawnedEntity = spawnedEntity\n        end\n\n        return spawnedEntity\n    end\n\n    -- Metadata builder intentionally stores drop columns only; actual drop execution is future work.\n    method table BuildSpawnMetaFromRow(UserDataRow row)\n        local meta = {}\n        meta.Id = self:GetRowString(row, \"id\", \"\")\n        meta.Name = self:GetRowString(row, \"name\", \"\")\n        meta.MonType = self:GetRowString(row, \"mon_type\", \"\")\n        meta.ModelType = self:GetRowString(row, \"model_type\", \"\")\n        meta.MonHP = self:GetRowInteger(row, \"mon_hp\", 0)\n        meta.MonAtk = self:GetRowInteger(row, \"mon_atk\", 0)\n        meta.MonSpd = self:GetRowNumber(row, \"mon_spd\", 0)\n        meta.SpawnStage = self:GetRowInteger(row, \"spawn_stage\", 1)\n        meta.SpawnTimeMin = self:GetSpawnMinuteFromRow(row)\n        meta.Gold = self:GetRowInteger(row, \"gold\", 0)\n\n        meta.DropItem1Id = self:GetRowString(row, \"drop_item_1_id\", \"\")\n        meta.DropItem1Rate = self:GetRowNumber(row, \"drop_item_1_rate\", 0)\n        meta.DropItem1Amount = self:GetRowInteger(row, \"drop_item_1_amount\", 0)\n        meta.DropItem2Id = self:GetRowString(row, \"drop_item_2_id\", \"\")\n        meta.DropItem2Rate = self:GetRowNumber(row, \"drop_item_2_rate\", 0)\n        meta.DropItem2Amount = self:GetRowInteger(row, \"drop_item_2_amount\", 0)\n\n        meta.SpriteRuid = self:GetRowString(row, \"sprite_ruid\", \"\")\n        meta.SoundRuid = self:GetRowString(row, \"sound_ruid\", \"\")\n        meta.DeathEffectRuid = self:GetRowString(row, \"death_effect_ruid\", \"\")\n        meta.IsBoss = self:IsBossRow(row)\n\n        return meta\n    end\n\n    -- TODO: Replace this adapter with visual profile resolver when sprite/anim policy is finalized.\n    method void ApplyMonsterVisualIfAvailable(Entity targetEntity, UserDataRow row)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return\n        end\n        if row == nil then\n            return\n        end\n\n        local spriteRuid = self:GetRowString(row, \"sprite_ruid\", \"\")\n        if spriteRuid == \"\" then\n            return\n        end\n\n        local spriteRenderer = self:ResolveComponentSafe(targetEntity, \"SpriteRendererComponent\", \"SpriteRUID\")\n        if spriteRenderer == nil then\n            return\n        end\n\n        local applyOk, _ = pcall(function()\n            spriteRenderer.SpriteRUID = spriteRuid\n        end)\n        if applyOk == false then\n            local rowId = self:GetRowString(row, \"id\", \"(unknown)\")\n            log_warning(\"[MonsterSpawnComponent] Failed to apply sprite_ruid. rowId=\", rowId, \", sprite_ruid=\", spriteRuid)\n        end\n    end\n\n    -- TODO: Replace this adapter with dedicated monster stat component integration when spec arrives.\n    method void ApplyMonsterStatsIfAvailable(Entity targetEntity, UserDataRow row)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return\n        end\n        if row == nil then\n            return\n        end\n\n        local monHp = self:GetRowInteger(row, \"mon_hp\", -1)\n        local monAtk = self:GetRowInteger(row, \"mon_atk\", -1)\n        local monSpd = self:GetRowNumber(row, \"mon_spd\", -1)\n\n        if monHp >= 0 then\n            local hpSystem = self:ResolveComponentSafe(targetEntity, \"HPSystemComponent\", \"CurrentHP\")\n            if hpSystem ~= nil then\n                pcall(function()\n                    hpSystem.MaxHP = monHp\n                end)\n                pcall(function()\n                    hpSystem.CurrentHP = monHp\n                end)\n            end\n        end\n\n        if monAtk >= 0 then\n            local monsterAttack = self:ResolveComponentSafe(targetEntity, \"MonsterAttackComponent\", \"AttackPower\")\n            if monsterAttack ~= nil then\n                pcall(function()\n                    monsterAttack.AttackPower = monAtk\n                end)\n            end\n        end\n\n        if monSpd >= 0 then\n            local movement = self:ResolveComponentSafe(targetEntity, \"MovementComponent\", \"MoveSpeed\")\n            if movement ~= nil then\n                pcall(function()\n                    movement.MoveSpeed = monSpd\n                end)\n            end\n        end\n    end\n\n    -- Public read API exposes spawn metadata without coupling callers to internal cache structure.\n    method table GetSpawnMetaByEntity(Entity targetEntity)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n        if self._T.SpawnMetaByEntity == nil then\n            return nil\n        end\n\n        local sourceMeta = self._T.SpawnMetaByEntity[targetEntity]\n        if sourceMeta == nil then\n            return nil\n        end\n\n        return self:CloneTable(sourceMeta)\n    end\n\n    -- Pruning keeps field cap checks accurate even when external systems destroy spawned entities.\n    @ExecSpace(\"ServerOnly\")\n    method void PruneSpawnedMonsters()\n        if self._T.SpawnedMonsters == nil then\n            self._T.SpawnedMonsters = {}\n        end\n\n        local oldMeta = self._T.SpawnMetaByEntity\n        local newList = {}\n        local newMeta = {}\n\n        for _, entity in pairs(self._T.SpawnedMonsters) do\n            if entity ~= nil and isvalid(entity) == true then\n                table.insert(newList, entity)\n                if oldMeta ~= nil and oldMeta[entity] ~= nil then\n                    newMeta[entity] = oldMeta[entity]\n                end\n            end\n        end\n\n        self._T.SpawnedMonsters = newList\n        self._T.SpawnMetaByEntity = newMeta\n    end\n\n    method integer GetSpawnedMonsterCount()\n        if self._T.SpawnedMonsters == nil then\n            return 0\n        end\n        return #self._T.SpawnedMonsters\n    end\n\n    method string GetRowString(UserDataRow row, string columnName, string fallbackValue)\n        if row == nil then\n            return fallbackValue\n        end\n        if columnName == nil or columnName == \"\" then\n            return fallbackValue\n        end\n\n        local text = nil\n        local readOk, readResult = pcall(function()\n            return row:GetItem(columnName)\n        end)\n        if readOk == true then\n            text = readResult\n        end\n        if text == nil or text == \"\" then\n            return fallbackValue\n        end\n\n        return tostring(text)\n    end\n\n    method integer GetRowInteger(UserDataRow row, string columnName, integer fallbackValue)\n        local text = self:GetRowString(row, columnName, \"\")\n        if text == \"\" then\n            return math.floor(fallbackValue)\n        end\n\n        local parsed = tonumber(text)\n        if parsed == nil then\n            return math.floor(fallbackValue)\n        end\n\n        return math.floor(parsed)\n    end\n\n    method number GetRowNumber(UserDataRow row, string columnName, number fallbackValue)\n        local text = self:GetRowString(row, columnName, \"\")\n        if text == \"\" then\n            return fallbackValue\n        end\n\n        local parsed = tonumber(text)\n        if parsed == nil then\n            return fallbackValue\n        end\n\n        return parsed\n    end\n\n    method boolean GetRowBoolean(UserDataRow row, string columnName, boolean fallbackValue)\n        local text = string.lower(self:GetRowString(row, columnName, \"\"))\n        if text == \"\" then\n            return fallbackValue\n        end\n        if text == \"true\" or text == \"1\" or text == \"yes\" then\n            return true\n        end\n        if text == \"false\" or text == \"0\" or text == \"no\" then\n            return false\n        end\n        return fallbackValue\n    end\n\n    method table CloneTable(table source)\n        local clone = {}\n        if source == nil then\n            return clone\n        end\n\n        for key, value in pairs(source) do\n            clone[key] = value\n        end\n        return clone\n    end\n\n    method void LogError(string message)\n        local loggedOk, _ = pcall(function()\n            log_error(message)\n        end)\n        if loggedOk == false then\n            log_warning(message)\n        end\n    end\n\n    -- Utility bootstrap first; fallback lookup is retained for resilience in partially configured maps.\n    method void EnsureGRUtil()\n        if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, utilApi = pcall(function()\n                return utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and utilApi ~= nil then\n                self._T.GRUtil = utilApi\n            end\n            if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    method any ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then\n            return self._T.GRUtil.ResolveComponent(targetEntity, scriptName, markerField)\n        end\n\n        local prefixedName = scriptName\n        local plainName = scriptName\n        if string.sub(scriptName, 1, 7) == \"script.\" then\n            plainName = string.sub(scriptName, 8)\n        else\n            prefixedName = \"script.\" .. scriptName\n        end\n\n        local component = targetEntity:GetComponent(prefixedName)\n        if component == nil then\n            component = targetEntity:GetComponent(plainName)\n        end\n        if component == nil then\n            return nil\n        end\n\n        if markerField ~= nil and markerField ~= \"\" then\n            local ok, _ = pcall(function()\n                return component[markerField]\n            end)\n            if ok == false then\n                return nil\n            end\n        end\n\n        return component\n    end\nend\n"
    }
  }
}