{
  "Id": "",
  "GameId": "",
  "EntryKey": "codeblock://ee02f103-8f02-4216-817f-e099248a4a1b",
  "ContentType": "x-mod/codeblock",
  "Content": "",
  "Usage": 0,
  "UsePublish": 1,
  "UseService": 0,
  "CoreVersion": "26.1.0.0",
  "StudioVersion": "",
  "DynamicLoading": 0,
  "ContentProto": {
    "Use": "Json",
    "Json": {
      "CoreVersion": {
        "Major": 0,
        "Minor": 2
      },
      "ScriptVersion": {
        "Major": 1,
        "Minor": 1
      },
      "Description": "",
      "Id": "ee02f103-8f02-4216-817f-e099248a4a1b",
      "Language": 1,
      "Name": "ReloadComponent",
      "Type": 1,
      "Source": 1,
      "Target": "@Component\nscript ReloadComponent extends Component\n\n    @Sync\n    property integer CurrentAmmo = 30\n    @Sync\n    property boolean IsReloading = false\n    @Sync\n    property integer CurrentWeaponSlot = 1\n\n    property integer MaxAmmo = 30\n    property number ReloadTime = 1.5\n    property number FireRate = 0.5\n    property integer WeaponSlotCount = 4\n\n    -- Server initializes per-slot ammo/cooldown buffers for weapon-independent reload state.\n    @ExecSpace(\"ServerOnly\")\n    method void OnInitialize()\n        self.CurrentAmmo = math.max(0, math.min(self.CurrentAmmo, self.MaxAmmo))\n        self.IsReloading = false\n        self.CurrentWeaponSlot = math.max(1, self.CurrentWeaponSlot)\n\n        self._T.AmmoBySlot = {}\n        self._T.ReloadTimerBySlot = {}\n        self._T.ReloadEndTimeBySlot = {}\n        self._T.NextFireReadyTimeBySlot = {}\n\n        local slotCount = math.max(self.WeaponSlotCount, 1)\n        for slot = 1, slotCount do\n            self._T.AmmoBySlot[slot] = self.MaxAmmo\n            self._T.ReloadTimerBySlot[slot] = 0\n            self._T.ReloadEndTimeBySlot[slot] = 0\n            self._T.NextFireReadyTimeBySlot[slot] = 0\n        end\n\n        self._T.AmmoBySlot[self.CurrentWeaponSlot] = self.CurrentAmmo\n        self:EnsureGRUtil()\n    end\n\n    -- Client also boots util so ownership checks remain consistent in request handlers.\n    @ExecSpace(\"ClientOnly\")\n    method void OnBeginPlay()\n        self:EnsureGRUtil()\n    end\n\n    -- Reload input is captured client-side and validated server-side.\n    @EventSender(\"Service\", \"InputService\")\n    handler HandleKeyDownEvent(KeyDownEvent event)\n        if event.key ~= KeyboardKey.R then\n            return\n        end\n\n        self:RequestReloadServer()\n    end\n\n    -- Server-only approval blocks remote spoofed reload requests.\n    @ExecSpace(\"Server\")\n    method void RequestReloadServer()\n        if self.Entity == nil or isvalid(self.Entity) == false then\n            return\n        end\n\n        if self:IsOwnerRequest(senderUserId) == false then\n            return\n        end\n\n        self:StartReloadForSlot(self.CurrentWeaponSlot)\n    end\n\n    -- Reload starts only when ammo is not full and slot is currently idle.\n    @ExecSpace(\"ServerOnly\")\n    method void StartReloadForSlot(integer slot)\n        if self:IsValidSlot(slot) == false then\n            return\n        end\n        if self:IsReloadingInSlot(slot) == false then\n            local ammo = self._T.AmmoBySlot[slot]\n            if ammo == nil then\n                ammo = self.MaxAmmo\n                self._T.AmmoBySlot[slot] = ammo\n            end\n            if ammo >= self.MaxAmmo then\n                return\n            end\n        else\n            return\n        end\n\n        if slot == self.CurrentWeaponSlot then\n            self.IsReloading = true\n        end\n\n        local delay = math.max(self.ReloadTime, 0)\n        self._T.ReloadEndTimeBySlot[slot] = _UtilLogic.ServerElapsedSeconds + delay\n\n        local completeReload = function()\n            self:CompleteReload(slot)\n        end\n\n        self._T.ReloadTimerBySlot[slot] = _TimerService:SetTimerOnce(completeReload, delay)\n    end\n\n    -- Completion fills ammo only at end time to prevent swap-cancel exploit gains.\n    @ExecSpace(\"ServerOnly\")\n    method void CompleteReload(integer slot)\n        if self:IsValidSlot(slot) == false then\n            return\n        end\n\n        self._T.ReloadTimerBySlot[slot] = 0\n        self._T.ReloadEndTimeBySlot[slot] = 0\n        self._T.AmmoBySlot[slot] = self.MaxAmmo\n\n        if slot == self.CurrentWeaponSlot then\n            self.CurrentAmmo = self.MaxAmmo\n            self.IsReloading = false\n        end\n    end\n\n    -- Cancel path is reused by tag/swap systems to preserve design rule of immediate interruption.\n    @ExecSpace(\"ServerOnly\")\n    method void CancelReloadForSlot(integer slot)\n        if self:IsValidSlot(slot) == false then\n            return\n        end\n\n        local timerId = self._T.ReloadTimerBySlot[slot]\n        if timerId ~= nil and timerId > 0 then\n            _TimerService:ClearTimer(timerId)\n        end\n\n        self._T.ReloadTimerBySlot[slot] = 0\n        self._T.ReloadEndTimeBySlot[slot] = 0\n\n        if slot == self.CurrentWeaponSlot then\n            self.IsReloading = false\n        end\n    end\n\n    -- Public cancel endpoint keeps external systems decoupled from internal slot details.\n    @ExecSpace(\"ServerOnly\")\n    method void CancelCurrentReload()\n        self:CancelReloadForSlot(self.CurrentWeaponSlot)\n    end\n\n    -- Slot switch persists previous slot ammo and restores target slot state.\n    @ExecSpace(\"ServerOnly\")\n    method void SetCurrentWeaponSlot(integer slot)\n        if self:IsValidSlot(slot) == false then\n            return\n        end\n        if slot == self.CurrentWeaponSlot then\n            return\n        end\n\n        local prevSlot = self.CurrentWeaponSlot\n        self._T.AmmoBySlot[prevSlot] = self.CurrentAmmo\n\n        self:CancelReloadForSlot(prevSlot)\n\n        self.CurrentWeaponSlot = slot\n        self.CurrentAmmo = self._T.AmmoBySlot[slot]\n        if self.CurrentAmmo == nil then\n            self.CurrentAmmo = self.MaxAmmo\n            self._T.AmmoBySlot[slot] = self.MaxAmmo\n        end\n\n        self.IsReloading = self:IsReloadingInSlot(slot)\n    end\n\n    -- Fire consumption updates both ammo and per-slot fire cooldown timestamp.\n    @ExecSpace(\"ServerOnly\")\n    method boolean ConsumeAmmoOnFire()\n        if self.IsReloading == true then\n            return false\n        end\n        if self:IsFireReady() == false then\n            return false\n        end\n        if self.CurrentAmmo <= 0 then\n            return false\n        end\n\n        self.CurrentAmmo = self.CurrentAmmo - 1\n        self._T.AmmoBySlot[self.CurrentWeaponSlot] = self.CurrentAmmo\n        self._T.NextFireReadyTimeBySlot[self.CurrentWeaponSlot] = _UtilLogic.ServerElapsedSeconds + math.max(self.FireRate, 0)\n        return true\n    end\n\n    -- Fire-ready uses server elapsed time to keep cooldown immune to client-side time hacks.\n    @ExecSpace(\"ServerOnly\")\n    method boolean IsFireReady()\n        local readyTime = self._T.NextFireReadyTimeBySlot[self.CurrentWeaponSlot]\n        if readyTime == nil then\n            return true\n        end\n\n        return _UtilLogic.ServerElapsedSeconds >= readyTime\n    end\n\n    method boolean IsValidSlot(integer slot)\n        if slot < 1 then\n            return false\n        end\n\n        return slot <= math.max(self.WeaponSlotCount, 1)\n    end\n\n    method boolean IsReloadingInSlot(integer slot)\n        local timerId = self._T.ReloadTimerBySlot[slot]\n        return (timerId ~= nil and timerId > 0)\n    end\n\n    -- External readers use this accessor instead of touching internal table state directly.\n    @ExecSpace(\"ServerOnly\")\n    method integer GetSlotAmmo(integer slot)\n        if self:IsValidSlot(slot) == false then\n            return 0\n        end\n\n        local ammo = self._T.AmmoBySlot[slot]\n        if ammo == nil then\n            ammo = self.MaxAmmo\n        end\n\n        return ammo\n    end\n\n    -- External writers use this setter to keep clamp logic centralized.\n    @ExecSpace(\"ServerOnly\")\n    method void SetSlotAmmo(integer slot, integer ammo)\n        if self:IsValidSlot(slot) == false then\n            return\n        end\n\n        local clampedAmmo = math.max(0, math.min(ammo, self.MaxAmmo))\n        self._T.AmmoBySlot[slot] = clampedAmmo\n\n        if slot == self.CurrentWeaponSlot then\n            self.CurrentAmmo = clampedAmmo\n        end\n    end\n\n    -- End play clears outstanding timers to prevent stale completion callbacks.\n    @ExecSpace(\"ServerOnly\")\n    method void OnEndPlay()\n        local slotCount = math.max(self.WeaponSlotCount, 1)\n        for slot = 1, slotCount do\n            local timerId = self._T.ReloadTimerBySlot[slot]\n            if timerId ~= nil and timerId > 0 then\n                _TimerService:ClearTimer(timerId)\n            end\n            self._T.ReloadTimerBySlot[slot] = 0\n            self._T.ReloadEndTimeBySlot[slot] = 0\n        end\n    end\n\n    -- Utility bootstrap first; fallback owner validation is used if global utility is not available.\n    method void EnsureGRUtil()\n        if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, utilApi = pcall(function()\n                return utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and utilApi ~= nil then\n                self._T.GRUtil = utilApi\n            end\n            if self._T.GRUtil ~= nil and self._T.GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    method boolean IsOwnerRequest(string requestUserId)\n        if self._T.GRUtil ~= nil and self._T.GRUtil.IsOwner ~= nil then\n            return self._T.GRUtil.IsOwner(self.Entity, requestUserId)\n        end\n\n        local playerComponent = self.Entity.PlayerComponent\n        if playerComponent == nil then\n            return true\n        end\n\n        if requestUserId == nil or requestUserId == \"\" then\n            return true\n        end\n\n        return requestUserId == playerComponent.UserId\n    end\nend\n"
    }
  }
}