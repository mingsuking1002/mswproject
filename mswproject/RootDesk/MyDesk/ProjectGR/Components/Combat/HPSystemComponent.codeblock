{
  "Id": "",
  "GameId": "",
  "EntryKey": "codeblock://9afbe2a8-a2f7-46cc-a7c8-00d7210d63b6",
  "ContentType": "x-mod/codeblock",
  "Content": "",
  "Usage": 0,
  "UsePublish": 1,
  "UseService": 0,
  "CoreVersion": "26.1.0.0",
  "StudioVersion": "",
  "DynamicLoading": 0,
  "ContentProto": {
    "Use": "Json",
    "Json": {
      "CoreVersion": {
        "Major": 0,
        "Minor": 2
      },
      "ScriptVersion": {
        "Major": 1,
        "Minor": 1
      },
      "Description": "",
      "Id": "9afbe2a8-a2f7-46cc-a7c8-00d7210d63b6",
      "Language": 1,
      "Name": "HPSystemComponent",
      "Type": 1,
      "Source": 1,
      "Target": "@Component\nscript HPSystemComponent extends Component\n\n    @Sync\n    property integer MaxHP = 100\n    @Sync\n    property integer CurrentHP = 100\n    @Sync\n    property boolean IsInvincible = false\n    @Sync\n    property boolean IsDead = false\n\n    property integer DamageReduction = 0\n    property number InvincibleDuration = 1.0\n    property number CriticalHPRatio = 0.3\n    property integer FallbackDamage = 1\n\n    -- Server initializes HP state once to prevent first-frame sync mismatch.\n    @ExecSpace(\"ServerOnly\")\n    method void OnInitialize()\n        self.CurrentHP = math.max(0, math.min(self.CurrentHP, self.MaxHP))\n        self.IsInvincible = false\n        self.IsDead = (self.CurrentHP <= 0)\n        self._T.InvincibleTimerId = 0\n        self._T.IsDeadUIOpened = false\n        self:EnsureGRUtil()\n    end\n\n    -- Initial HP sync is pushed once so HUD has deterministic startup state.\n    @ExecSpace(\"ServerOnly\")\n    method void OnBeginPlay()\n        self:EnsureGRUtil()\n        self:BroadcastHPState()\n    end\n\n    -- Damage intake is server-authoritative and validated per collision source.\n    @ExecSpace(\"ServerOnly\")\n    @EventSender(\"Self\")\n    handler HandleTriggerEnterEvent(TriggerEnterEvent event)\n        local triggerBodyEntity = event.TriggerBodyEntity\n        local incomingDamage = self:ResolveIncomingDamage(triggerBodyEntity)\n        if incomingDamage <= 0 then\n            return\n        end\n\n        self:ApplyDamage(incomingDamage)\n    end\n\n    -- Reads attack power through known combat components with safe fallback damage.\n    @ExecSpace(\"ServerOnly\")\n    method integer ResolveIncomingDamage(Entity sourceEntity)\n        if sourceEntity == nil or isvalid(sourceEntity) == false then\n            return 0\n        end\n\n        local projectile = self:ResolveComponentSafe(sourceEntity, \"ProjectileComponent\", \"Damage\")\n        if projectile ~= nil then\n            local valueOk, value = pcall(function()\n                return projectile.Damage\n            end)\n            if valueOk == true and value ~= nil then\n                return math.max(math.floor(value), 0)\n            end\n        end\n\n        local monsterAttack = self:ResolveComponentSafe(sourceEntity, \"MonsterAttackComponent\", \"AttackPower\")\n        if monsterAttack ~= nil then\n            local valueOk, value = pcall(function()\n                return monsterAttack.AttackPower\n            end)\n            if valueOk == true and value ~= nil then\n                return math.max(math.floor(value), 0)\n            end\n        end\n\n        return math.max(self.FallbackDamage, 0)\n    end\n\n    -- Damage application centralizes invincibility, reduction, and death checks in one server path.\n    @ExecSpace(\"ServerOnly\")\n    method void ApplyDamage(integer rawDamage)\n        if self.IsDead == true then\n            return\n        end\n        if self.IsInvincible == true then\n            return\n        end\n        if rawDamage <= 0 then\n            return\n        end\n\n        local actualDamage = rawDamage - self.DamageReduction\n        if actualDamage < 0 then\n            actualDamage = 0\n        end\n\n        self.CurrentHP = math.max(self.CurrentHP - actualDamage, 0)\n        if actualDamage > 0 then\n            self:StartInvincibleWindow()\n        end\n\n        self:EvaluateDeath()\n        self:BroadcastHPState()\n    end\n\n    -- Invincibility uses timer scheduling to avoid per-frame state polling.\n    @ExecSpace(\"ServerOnly\")\n    method void StartInvincibleWindow()\n        if self.InvincibleDuration <= 0 then\n            self.IsInvincible = false\n            return\n        end\n\n        if self._T.InvincibleTimerId ~= nil and self._T.InvincibleTimerId > 0 then\n            _TimerService:ClearTimer(self._T.InvincibleTimerId)\n            self._T.InvincibleTimerId = 0\n        end\n\n        self.IsInvincible = true\n\n        local releaseInvincible = function()\n            self.IsInvincible = false\n            self._T.InvincibleTimerId = 0\n            self:BroadcastHPState()\n        end\n\n        self._T.InvincibleTimerId = _TimerService:SetTimerOnce(releaseInvincible, self.InvincibleDuration)\n    end\n\n    -- Healing is clamped on server to enforce max HP boundary.\n    @ExecSpace(\"ServerOnly\")\n    method void Heal(integer amount)\n        if amount <= 0 then\n            return\n        end\n        if self.IsDead == true then\n            return\n        end\n\n        self.CurrentHP = math.min(self.CurrentHP + amount, self.MaxHP)\n        self:BroadcastHPState()\n    end\n\n    -- Revive path resets all lethal-state flags for retry flow.\n    @ExecSpace(\"ServerOnly\")\n    method void ReviveToFullHP()\n        if self._T.InvincibleTimerId ~= nil and self._T.InvincibleTimerId > 0 then\n            _TimerService:ClearTimer(self._T.InvincibleTimerId)\n            self._T.InvincibleTimerId = 0\n        end\n\n        self.CurrentHP = math.max(self.MaxHP, 1)\n        self.IsInvincible = false\n        self.IsDead = false\n        self._T.IsDeadUIOpened = false\n        self:BroadcastHPState()\n    end\n\n    -- Death finalization runs once and forwards game-over to orchestrators.\n    @ExecSpace(\"ServerOnly\")\n    method void EvaluateDeath()\n        if self.CurrentHP > 0 then\n            return\n        end\n        if self.IsDead == true then\n            return\n        end\n\n        self.IsDead = true\n        self.IsInvincible = false\n\n        self:SetCanMoveSafely(false)\n        self:NotifyGameOver()\n    end\n\n    -- Movement lock prefers _GRUtil to keep cross-component access policy centralized.\n    method boolean SetCanMoveSafely(boolean canMove)\n        if _GRUtil ~= nil and _GRUtil.TrySetCanMove ~= nil then\n            return _GRUtil.TrySetCanMove(self.Entity, canMove)\n        end\n\n        local movementComponent = self:ResolveComponentSafe(self.Entity, \"MovementComponent\", \"CanMove\")\n        if movementComponent == nil then\n            return false\n        end\n\n        local ok, _ = pcall(function()\n            movementComponent.CanMove = canMove\n        end)\n        return ok\n    end\n\n    -- Game-over routing attempts LobbyFlow first, then GameManager, then timer fallback.\n    @ExecSpace(\"ServerOnly\")\n    method void NotifyGameOver()\n        local lobbyFlow = self:ResolveComponentSafe(self.Entity, \"LobbyFlowComponent\", \"IsLobbyActive\")\n        if lobbyFlow ~= nil then\n            if lobbyFlow.HandleStageFailedServer ~= nil then\n                lobbyFlow:HandleStageFailedServer()\n                return\n            end\n            if lobbyFlow.HandleRunCompletedServer ~= nil then\n                lobbyFlow:HandleRunCompletedServer(false)\n                return\n            end\n        end\n\n        local gameManager = self:ResolveComponentSafe(self.Entity, \"GameManagerComponent\", \"Entity\")\n        if gameManager ~= nil and gameManager.OnPlayerDead ~= nil then\n            gameManager:OnPlayerDead(self.Entity)\n            return\n        end\n\n        local timerComponent = self:ResolveComponentSafe(self.Entity, \"SpeedrunTimerComponent\", \"ElapsedTime\")\n        if timerComponent ~= nil and timerComponent.CompleteRun ~= nil then\n            timerComponent:CompleteRun()\n        end\n\n        log_warning(\"[HPSystemComponent] Fallback game-over flow used.\")\n    end\n\n    -- Server sends current HP state to client-only feedback routine.\n    @ExecSpace(\"ServerOnly\")\n    method void BroadcastHPState()\n        self:UpdateHPFeedbackClient(self.CurrentHP, self.MaxHP, self.IsInvincible, self.IsDead)\n    end\n\n    -- Client routine keeps visual-only response while authority remains server-side.\n    @ExecSpace(\"Client\")\n    method void UpdateHPFeedbackClient(integer currentHp, integer maxHp, boolean isInvincible, boolean isDead)\n        self:UpdateInvincibleBlink(isInvincible)\n        self:UpdateCriticalWarning(currentHp, maxHp)\n\n        if isDead == true then\n            self:HandleDeadUI()\n        end\n    end\n\n    -- Blink toggling is separated for deterministic enter/exit behavior.\n    @ExecSpace(\"ClientOnly\")\n    method void UpdateInvincibleBlink(boolean isInvincible)\n        if isInvincible == true then\n            self:StartInvincibleBlink()\n            return\n        end\n\n        self:StopInvincibleBlink()\n    end\n\n    -- Blink uses timer tick to avoid heavy per-frame material changes.\n    @ExecSpace(\"ClientOnly\")\n    method void StartInvincibleBlink()\n        if self._T.BlinkTimerId ~= nil and self._T.BlinkTimerId > 0 then\n            return\n        end\n\n        local spriteRenderer = self.Entity.SpriteRendererComponent\n        if spriteRenderer == nil or isvalid(spriteRenderer) == false then\n            return\n        end\n\n        self._T.BlinkVisible = true\n\n        local blinkTick = function()\n            if self.IsInvincible == false then\n                self:StopInvincibleBlink()\n                return\n            end\n\n            self._T.BlinkVisible = not self._T.BlinkVisible\n            if self._T.BlinkVisible == true then\n                spriteRenderer.Color = Color(1, 1, 1, 1)\n            else\n                spriteRenderer.Color = Color(1, 1, 1, 0.35)\n            end\n        end\n\n        self._T.BlinkTimerId = _TimerService:SetTimerRepeat(blinkTick, 0.1, 0)\n    end\n\n    -- Restores sprite color and clears timer handle after invincible state ends.\n    @ExecSpace(\"ClientOnly\")\n    method void StopInvincibleBlink()\n        if self._T.BlinkTimerId ~= nil and self._T.BlinkTimerId > 0 then\n            _TimerService:ClearTimer(self._T.BlinkTimerId)\n            self._T.BlinkTimerId = 0\n        end\n\n        local spriteRenderer = self.Entity.SpriteRendererComponent\n        if spriteRenderer ~= nil and isvalid(spriteRenderer) == true then\n            spriteRenderer.Color = Color.white\n        end\n    end\n\n    -- Critical state is computed from ratio so threshold tuning only needs property changes.\n    @ExecSpace(\"ClientOnly\")\n    method void UpdateCriticalWarning(integer currentHp, integer maxHp)\n        if maxHp <= 0 then\n            self._T.IsCritical = false\n            return\n        end\n\n        local hpRatio = currentHp / maxHp\n        self._T.IsCritical = (hpRatio < self.CriticalHPRatio)\n    end\n\n    -- Dead UI trigger is debounced to avoid repeated popup requests.\n    @ExecSpace(\"ClientOnly\")\n    method void HandleDeadUI()\n        if self._T.IsDeadUIOpened == true then\n            return\n        end\n\n        self._T.IsDeadUIOpened = true\n        log(\"[HPSystemComponent] Game Over UI trigger requested.\")\n    end\n\n    -- End play clears outstanding timers to prevent stale callbacks after entity destruction.\n    @ExecSpace(\"ServerOnly\")\n    method void OnEndPlay()\n        if self._T.InvincibleTimerId ~= nil and self._T.InvincibleTimerId > 0 then\n            _TimerService:ClearTimer(self._T.InvincibleTimerId)\n            self._T.InvincibleTimerId = 0\n        end\n    end\n\n    -- Utility bootstrap first; fallback flag enables local direct path when global util is unavailable.\n    method void EnsureGRUtil()\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return\n        end\n\n        local utilComponent = nil\n        if self.Entity ~= nil and isvalid(self.Entity) == true then\n            utilComponent = self.Entity:GetComponent(\"script.GRUtilModule\")\n            if utilComponent == nil then\n                utilComponent = self.Entity:GetComponent(\"GRUtilModule\")\n            end\n            if utilComponent == nil then\n                local addOk1, addResult1 = pcall(function()\n                    return self.Entity:AddComponent(\"script.GRUtilModule\")\n                end)\n                if addOk1 == true then\n                    utilComponent = addResult1\n                end\n            end\n            if utilComponent == nil then\n                local addOk2, addResult2 = pcall(function()\n                    return self.Entity:AddComponent(\"GRUtilModule\")\n                end)\n                if addOk2 == true then\n                    utilComponent = addResult2\n                end\n            end\n        end\n\n        if utilComponent ~= nil and isvalid(utilComponent) == true then\n            local bootstrapOk, _ = pcall(function()\n                utilComponent:BootstrapUtil()\n            end)\n            if bootstrapOk == true and _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n                return\n            end\n        end\n\n        self._T.UseGRUtilFallback = true\n    end\n\n    method Component ResolveComponentSafe(Entity targetEntity, string scriptName, string markerField)\n        if targetEntity == nil or isvalid(targetEntity) == false then\n            return nil\n        end\n\n        if _GRUtil ~= nil and _GRUtil.ResolveComponent ~= nil then\n            return _GRUtil.ResolveComponent(targetEntity, scriptName, markerField)\n        end\n\n        local prefixedName = scriptName\n        local plainName = scriptName\n        if string.sub(scriptName, 1, 7) == \"script.\" then\n            plainName = string.sub(scriptName, 8)\n        else\n            prefixedName = \"script.\" .. scriptName\n        end\n\n        local component = targetEntity:GetComponent(prefixedName)\n        if component == nil then\n            component = targetEntity:GetComponent(plainName)\n        end\n        if component == nil then\n            return nil\n        end\n\n        if markerField ~= nil and markerField ~= \"\" then\n            local ok, _ = pcall(function()\n                return component[markerField]\n            end)\n            if ok == false then\n                return nil\n            end\n        end\n\n        return component\n    end\nend\n"
    }
  }
}