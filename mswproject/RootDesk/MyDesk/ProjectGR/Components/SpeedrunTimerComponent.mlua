@Component
script SpeedrunTimerComponent extends Component

    @Sync
    property number ElapsedTime = 0.0
    @Sync
    property boolean IsRunning = false
    @Sync
    property boolean IsCountdownRunning = false
    @Sync
    property integer CountdownRemaining = 0
    property integer CurrentStageId = 1
    @Sync
    property number BestTime = -1

    property string DataStorageName = "SpeedrunTimerStorage"
    property Entity TimerTextEntity = nil
    property string TimerTextPath = "/ui/DefaultGroup/GRTimerText"
    property string TimerTextFallbackPath = "/maps/map01/GRTimerText"
    property boolean EnableStartCountdown = true
    property integer StartCountdownSeconds = 3
    property boolean LockCombatDuringCountdown = true
    property string CountdownPauseReason = "RUN_COUNTDOWN"
    property string CountdownReadyPrefix = "READY "
    property string CountdownGoText = "GO!"

    -- Initializes timer and pause state once so server and clients start from deterministic values.
    @ExecSpace("ServerOnly")
    method void OnInitialize()
        self.ElapsedTime = 0.0
        self.IsRunning = false
        self.IsCountdownRunning = false
        self.CountdownRemaining = 0
        self._T.ExternalPauseMap = {}
        self._T.CountdownTimerId = 0
        self:LoadBestTimeFromStorage()
    end

    -- Starts the client HUD text updater from server authority so late UI load can still recover.
    @ExecSpace("ServerOnly")
    method void OnBeginPlay()
        self:StartClientTimerTextLoop()
    end

    -- Accumulates elapsed time only on server to keep ranking validation cheat-resistant.
    @ExecSpace("ServerOnly")
    method void OnUpdate(number delta)
        if self.IsRunning == false then
            return
        end
        if self:IsExternallyPaused() == true then
            return
        end

        self.ElapsedTime = self.ElapsedTime + delta
    end

    -- Immediate run start is kept for fallback and tests where countdown is intentionally disabled.
    @ExecSpace("ServerOnly")
    method void StartRun()
        self:CancelCountdown()
        self.ElapsedTime = 0.0
        self.IsRunning = true
    end

    -- Runs a server-authoritative countdown and starts timer on completion.
    @ExecSpace("ServerOnly")
    method void StartRunWithCountdown()
        self:CancelCountdown()
        self.ElapsedTime = 0.0
        self.IsRunning = false

        local countdownSeconds = math.max(self.StartCountdownSeconds, 0)
        if self.EnableStartCountdown == false or countdownSeconds <= 0 then
            self:StartRun()
            return
        end

        self.IsCountdownRunning = true
        self.CountdownRemaining = countdownSeconds
        self:SetExternalPauseState(self.CountdownPauseReason, true)
        self:ApplyCountdownCombatLockServer(true)
        self:PlayCountdownFeedbackClient(self.CountdownRemaining)

        local countdownTick = function()
            if self.IsCountdownRunning == false then
                self:CancelCountdown()
                return
            end

            self.CountdownRemaining = self.CountdownRemaining - 1
            if self.CountdownRemaining > 0 then
                self:PlayCountdownFeedbackClient(self.CountdownRemaining)
                return
            end

            self:CancelCountdown()
            self:StartRun()
            self:PlayCountdownGoFeedbackClient()
        end

        self._T.CountdownTimerId = _TimerService:SetTimerRepeat(countdownTick, 1.0, 1.0)
    end

    -- Centralized countdown cleanup prevents lock-release misses on cancel/restart/death.
    @ExecSpace("ServerOnly")
    method void CancelCountdown()
        if self._T.CountdownTimerId ~= nil and self._T.CountdownTimerId > 0 then
            _TimerService:ClearTimer(self._T.CountdownTimerId)
            self._T.CountdownTimerId = 0
        end

        self.IsCountdownRunning = false
        self.CountdownRemaining = 0
        self:SetExternalPauseState(self.CountdownPauseReason, false)
        self:ApplyCountdownCombatLockServer(false)
    end

    -- Locks only combat movement/attack during countdown while respecting lobby lock precedence.
    @ExecSpace("ServerOnly")
    method void ApplyCountdownCombatLockServer(boolean isLocked)
        if self.LockCombatDuringCountdown == false then
            return
        end

        local allowCombat = (isLocked == false)
        local lobbyFlowComponent = self.Entity:GetComponent("LobbyFlowComponent")
        if lobbyFlowComponent ~= nil and isvalid(lobbyFlowComponent) == true then
            if lobbyFlowComponent.IsLobbyActive == true then
                allowCombat = false
            end
        end

        self:TrySetMovementCanMove(allowCombat)

        local fireComponent = self.Entity:GetComponent("FireSystemComponent")
        if fireComponent ~= nil and isvalid(fireComponent) == true then
            fireComponent.CanAttack = allowCombat
        end
    end

    -- Resolves custom movement component first to avoid native MovementComponent name collisions.
    method Component ResolveProjectMovementComponent()
        local prefixed = self.Entity:GetComponent("script.MovementComponent")
        if self:CanWriteComponentField(prefixed, "CanMove") == true then
            return prefixed
        end

        local plain = self.Entity:GetComponent("MovementComponent")
        if self:CanWriteComponentField(plain, "CanMove") == true then
            return plain
        end

        return nil
    end

    -- Protects countdown movement lock writes from runtime exceptions.
    method boolean TrySetMovementCanMove(boolean canMove)
        local movementComponent = self:ResolveProjectMovementComponent()
        if movementComponent == nil then
            return false
        end

        local ok, _ = pcall(function()
            movementComponent.CanMove = canMove
        end)
        if ok == false then
            log_warning("[SpeedrunTimerComponent] Failed to set MovementComponent.CanMove")
            return false
        end

        return true
    end

    -- Uses read+write probe so nil-valued fields are still recognized while missing fields are rejected.
    method boolean CanWriteComponentField(any targetComponent, string fieldName)
        if targetComponent == nil or isvalid(targetComponent) == false then
            return false
        end
        if fieldName == nil or fieldName == "" then
            return false
        end

        local readOk, readValue = pcall(function()
            return targetComponent[fieldName]
        end)
        if readOk == false then
            return false
        end

        local writeOk, _ = pcall(function()
            targetComponent[fieldName] = readValue
        end)
        return writeOk
    end

    -- External pause reasons are merged so multiple UI/gameplay systems can pause timer safely.
    @ExecSpace("ServerOnly")
    method void SetExternalPauseState(string reason, boolean paused)
        if reason == nil or reason == "" then
            return
        end
        if self._T.ExternalPauseMap == nil then
            self._T.ExternalPauseMap = {}
        end

        self._T.ExternalPauseMap[reason] = paused
    end

    -- Resolves any active pause reason to a single bool and includes weapon swap menu state.
    @ExecSpace("ServerOnly")
    method boolean IsExternallyPaused()
        local weaponSwapComponent = self.Entity:GetComponent("WeaponSwapComponent")
        if weaponSwapComponent ~= nil and isvalid(weaponSwapComponent) == true then
            if weaponSwapComponent.IsSwapMenuOpen == true then
                return true
            end
        end

        if self._T.ExternalPauseMap == nil then
            return false
        end

        for _, paused in pairs(self._T.ExternalPauseMap) do
            if paused == true then
                return true
            end
        end

        return false
    end

    -- Completes current run once, updates best time, and submits ranking.
    @ExecSpace("ServerOnly")
    method void CompleteRun()
        if self.IsCountdownRunning == true then
            self:CancelCountdown()
        end

        if self.IsRunning == false then
            return
        end

        self.IsRunning = false
        self:UpdateBestTimeAndSave()
        self:NotifyRankingSystem()
    end

    -- Full reset returns component to idle pre-run state.
    @ExecSpace("ServerOnly")
    method void ResetRun()
        self:CancelCountdown()
        self.ElapsedTime = 0.0
        self.IsRunning = false
    end

    -- Updates stage best time only when current run improved.
    @ExecSpace("ServerOnly")
    method void UpdateBestTimeAndSave()
        if self.BestTime < 0 or self.ElapsedTime < self.BestTime then
            self.BestTime = self.ElapsedTime
            self:SaveBestTimeToStorage()
            self:PlayNewRecordFeedbackClient()
        end
    end

    -- Stage key format is fixed to keep storage compatibility across versions.
    @ExecSpace("ServerOnly")
    method string GetBestTimeStorageKey()
        return "Stage_" .. tostring(self.CurrentStageId) .. "_BestTime"
    end

    -- Stores best time into GlobalDataStorage.
    @ExecSpace("ServerOnly")
    method void SaveBestTimeToStorage()
        local dataStorage = _DataStorageService:GetGlobalDataStorage(self.DataStorageName)
        if dataStorage == nil then
            return
        end

        local key = self:GetBestTimeStorageKey()
        dataStorage:SetAndWait(key, tostring(self.BestTime))
    end

    -- Loads best time from GlobalDataStorage and falls back to -1 on any parse/load failure.
    @ExecSpace("ServerOnly")
    method void LoadBestTimeFromStorage()
        local dataStorage = _DataStorageService:GetGlobalDataStorage(self.DataStorageName)
        if dataStorage == nil then
            self.BestTime = -1
            return
        end

        local key = self:GetBestTimeStorageKey()
        local errorCode, value = dataStorage:GetAndWait(key)
        if errorCode ~= 0 or value == nil or value == "" then
            self.BestTime = -1
            return
        end

        local parsed = tonumber(value)
        if parsed == nil then
            self.BestTime = -1
            return
        end

        self.BestTime = parsed
    end

    -- Sends final elapsed time to RankingComponent; server keeps submission authority.
    @ExecSpace("ServerOnly")
    method void NotifyRankingSystem()
        local rankingComponent = self.Entity:GetComponent("RankingComponent")
        if rankingComponent == nil or isvalid(rankingComponent) == false then
            return
        end

        rankingComponent:SubmitTimeAttackResult(self.ElapsedTime, self.CurrentStageId)
    end

    -- New-record feedback hook for future VFX/SFX expansion.
    @ExecSpace("Client")
    method void PlayNewRecordFeedbackClient()
        log("[SpeedrunTimerComponent] New Record!")
    end

    -- Countdown per-second feedback is client-side only.
    @ExecSpace("Client")
    method void PlayCountdownFeedbackClient(integer remaining)
        log("[SpeedrunTimerComponent] Countdown: ", remaining)
        self:RefreshTimerTextClient()
    end

    -- Countdown finish feedback hook.
    @ExecSpace("Client")
    method void PlayCountdownGoFeedbackClient()
        log("[SpeedrunTimerComponent] ", self.CountdownGoText)
        self:RefreshTimerTextClient()
    end

    -- Client text loop reflects either countdown text or elapsed timer text.
    @ExecSpace("Client")
    method void StartClientTimerTextLoop()
        if self._T.ClientTextTimerId ~= nil and self._T.ClientTextTimerId > 0 then
            return
        end

        local updateText = function()
            local textEntity = self:ResolveTimerTextEntityClient()
            local textComponent = nil
            if textEntity ~= nil and isvalid(textEntity) == true then
                textComponent = textEntity.TextComponent
            end
            if textComponent == nil then
                return
            end

            if self.IsCountdownRunning == true or self.IsRunning == true then
                self:TrySetTimerTextVisibleClient(true)
            end

            if self.IsCountdownRunning == true then
                textComponent.Text = self:BuildCountdownText(self.CountdownRemaining)
                return
            end

            textComponent.Text = self:FormatElapsedTime(self.ElapsedTime)
        end

        updateText()
        self._T.ClientTextTimerId = _TimerService:SetTimerRepeat(updateText, 0.05, 0.0)
    end

    -- Sync 수신 시 즉시 텍스트를 갱신해 루프 지연/미시작 상황에서도 카운트다운 문구를 보장한다.
    @ExecSpace("ClientOnly")
    method void OnSyncProperty(string propertyName, any value)
        if propertyName == "IsCountdownRunning" or propertyName == "CountdownRemaining" then
            self:RefreshTimerTextClient()
            return
        end
        if propertyName == "ElapsedTime" and self.IsCountdownRunning == false then
            self:RefreshTimerTextClient()
            return
        end
    end

    @ExecSpace("Client")
    method void RefreshTimerTextClient()
        local textEntity = self:ResolveTimerTextEntityClient()
        if textEntity == nil or isvalid(textEntity) == false then
            return
        end
        local textComponent = textEntity.TextComponent
        if textComponent == nil then
            return
        end

        if self.IsCountdownRunning == true or self.IsRunning == true then
            self:TrySetTimerTextVisibleClient(true)
        end

        if self.IsCountdownRunning == true then
            textComponent.Text = self:BuildCountdownText(self.CountdownRemaining)
            return
        end

        textComponent.Text = self:FormatElapsedTime(self.ElapsedTime)
    end

    -- Resolves timer text from UI path so HUD binding does not depend on map entities.
    @ExecSpace("ClientOnly")
    method Entity ResolveTimerTextEntityClient()
        local current = self.TimerTextEntity
        if current ~= nil and isvalid(current) == true then
            if current.Path == self.TimerTextPath or current.Path == self.TimerTextFallbackPath then
                return current
            end
        end

        if self.TimerTextPath ~= nil and self.TimerTextPath ~= "" then
            local resolved = _EntityService:GetEntityByPath(self.TimerTextPath)
            if resolved ~= nil and isvalid(resolved) == true then
                self.TimerTextEntity = resolved
                return resolved
            end
        end

        if self.TimerTextFallbackPath ~= nil and self.TimerTextFallbackPath ~= "" then
            local fallback = _EntityService:GetEntityByPath(self.TimerTextFallbackPath)
            if fallback ~= nil and isvalid(fallback) == true then
                self.TimerTextEntity = fallback
                return fallback
            end
        end

        if self._T.TimerTextMissingWarned ~= true then
            self._T.TimerTextMissingWarned = true
            log_warning("[SpeedrunTimerComponent] Timer text entity not found. path=", tostring(self.TimerTextPath), ", fallback=", tostring(self.TimerTextFallbackPath))
        end
        return current
    end

    -- 타이머 카운트다운/진행 중에는 UI 토글 상태와 관계없이 타이머 텍스트를 강제 표시한다.
    @ExecSpace("ClientOnly")
    method void TrySetTimerTextVisibleClient(boolean visible)
        local textEntity = self:ResolveTimerTextEntityClient()
        if textEntity == nil or isvalid(textEntity) == false then
            return
        end

        pcall(function()
            textEntity.Enable = visible
        end)
        pcall(function()
            textEntity.Visible = visible
        end)

        local textComponent = textEntity.TextComponent
        if textComponent ~= nil and isvalid(textComponent) == true then
            pcall(function()
                textComponent.Enable = visible
            end)
        end
    end

    -- Countdown text is centralized so UI copy changes do not affect timer logic.
    method string BuildCountdownText(integer remaining)
        if remaining <= 0 then
            return self.CountdownGoText
        end

        return self.CountdownReadyPrefix .. tostring(remaining)
    end

    -- Shared time formatter for timer HUD and ranking display.
    method string FormatElapsedTime(number elapsed)
        local totalMs = math.floor(elapsed * 1000)
        if totalMs < 0 then
            totalMs = 0
        end

        local minutes = math.floor(totalMs / 60000)
        local seconds = math.floor((totalMs % 60000) / 1000)
        local centiseconds = math.floor((totalMs % 1000) / 10)

        local minuteText = tostring(minutes)
        if minutes < 10 then
            minuteText = "0" .. minuteText
        end

        local secondText = tostring(seconds)
        if seconds < 10 then
            secondText = "0" .. secondText
        end

        local centiText = tostring(centiseconds)
        if centiseconds < 10 then
            centiText = "0" .. centiText
        end

        return minuteText .. ":" .. secondText .. "." .. centiText
    end

    -- Stops client loop to avoid stale callbacks after entity unload.
    @ExecSpace("ClientOnly")
    method void StopClientTimerTextLoop()
        if self._T.ClientTextTimerId ~= nil and self._T.ClientTextTimerId > 0 then
            _TimerService:ClearTimer(self._T.ClientTextTimerId)
            self._T.ClientTextTimerId = 0
        end
    end

    -- Client cleanup for HUD timer loop.
    @ExecSpace("ClientOnly")
    method void OnEndPlay()
        self:StopClientTimerTextLoop()
    end

    -- Server cleanup for countdown timer loop.
    @ExecSpace("ServerOnly")
    method void OnDestroy()
        if self._T.CountdownTimerId ~= nil and self._T.CountdownTimerId > 0 then
            _TimerService:ClearTimer(self._T.CountdownTimerId)
            self._T.CountdownTimerId = 0
        end
    end
end




