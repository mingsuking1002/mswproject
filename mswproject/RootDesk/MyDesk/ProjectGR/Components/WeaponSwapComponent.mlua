@Component
script WeaponSwapComponent extends Component

    @Sync
    property integer CurrentWeaponSlot = 1
    property integer WeaponSlotCount = 4
    @Sync
    property boolean IsSwapMenuOpen = false
    property table Weapon1_Data = {}
    property table Weapon2_Data = {}
    property table Weapon3_Data = {}
    property table Weapon4_Data = {}
    @Sync
    property integer HighlightedSlot = 1
    @Sync
    property boolean IsGameLogicPaused = false
    property boolean AllowSwapMenu = true

    -- 서버 시작 시 슬롯 데이터를 정규화해 교체 직후 nil 참조를 예방한다.
    @ExecSpace("ServerOnly")
    method void OnInitialize()
        self.CurrentWeaponSlot = math.max(1, self.CurrentWeaponSlot)
        self.HighlightedSlot = self.CurrentWeaponSlot
        self.IsSwapMenuOpen = false
        self.IsGameLogicPaused = false

        for slot = 1, math.max(self.WeaponSlotCount, 1) do
            self:EnsureSlotData(slot)
        end
    end

    -- F/ESC/WASD 입력을 클라이언트에서 받아 서버 권위 상태 전환 요청으로 전달한다.
    @EventSender("Service", "InputService")
    handler HandleKeyDownEvent(KeyDownEvent event)
        local key = event.key

        if key == KeyboardKey.F then
            if self.IsSwapMenuOpen == true then
                self:RequestCancelSwapMenuServer()
            else
                self:RequestOpenSwapMenuServer()
            end
            return
        end

        if key == KeyboardKey.Escape then
            if self.IsSwapMenuOpen == true then
                self:RequestCancelSwapMenuServer()
            end
            return
        end

        if self.IsSwapMenuOpen == false then
            return
        end

        local slot = self:MapKeyToSlot(key)
        if slot > 0 then
            self:RequestHighlightSlotServer(slot)
        end
    end

    -- 메뉴가 열려 있을 때 좌클릭 확정 입력만 서버 교체 요청으로 처리한다.
    @EventSender("Service", "InputService")
    handler HandleScreenTouchEvent(ScreenTouchEvent event)
        if self.IsSwapMenuOpen == false then
            return
        end
        if event.TouchId ~= 1 then
            return
        end

        self:RequestConfirmSwapServer(self.HighlightedSlot)
    end

    -- 메뉴 오픈은 서버 조건 검증 후에만 허용해 사망/중복 오픈 상태를 차단한다.
    @ExecSpace("Server")
    method void RequestOpenSwapMenuServer()
        if self:IsRequestFromOwner() == false then
            return
        end
        if self:CanOpenSwapMenu() == false then
            return
        end

        self.IsSwapMenuOpen = true
        self.IsGameLogicPaused = true
        self.HighlightedSlot = self.CurrentWeaponSlot
        self:SetCombatInputLocked(true)
        self:UpdateSwapUIClient(true, self.HighlightedSlot)
    end

    -- 취소는 슬롯 미적용으로 닫아 실수 입력 시 상태 손실을 막는다.
    @ExecSpace("Server")
    method void RequestCancelSwapMenuServer()
        if self:IsRequestFromOwner() == false then
            return
        end
        if self.IsSwapMenuOpen == false then
            return
        end

        self:CloseSwapMenu(false, self.CurrentWeaponSlot)
    end

    -- 하이라이트 업데이트도 서버에서 확정해 UI와 실제 적용 슬롯의 불일치를 방지한다.
    @ExecSpace("Server")
    method void RequestHighlightSlotServer(integer slot)
        if self:IsRequestFromOwner() == false then
            return
        end
        if self.IsSwapMenuOpen == false then
            return
        end
        if self:IsValidSlot(slot) == false then
            return
        end

        self.HighlightedSlot = slot
        self:UpdateSwapUIClient(true, slot)
    end

    -- 확정 입력은 서버가 슬롯 유효성을 검증한 뒤 데이터 스왑을 실행한다.
    @ExecSpace("Server")
    method void RequestConfirmSwapServer(integer slot)
        if self:IsRequestFromOwner() == false then
            return
        end
        if self.IsSwapMenuOpen == false then
            return
        end
        if self:IsValidSlot(slot) == false then
            return
        end

        self:CloseSwapMenu(true, slot)
    end

    -- 메뉴 종료 경로를 단일화해 잠금 해제/타이머 재개 누락을 방지한다.
    @ExecSpace("ServerOnly")
    method void CloseSwapMenu(boolean applySlot, integer slot)
        if applySlot == true then
            self:ApplyWeaponSlot(slot)
        end

        self.IsSwapMenuOpen = false
        self.IsGameLogicPaused = false
        self.HighlightedSlot = self.CurrentWeaponSlot
        self:SetCombatInputLocked(false)
        self:UpdateSwapUIClient(false, self.HighlightedSlot)
    end

    -- 슬롯 교체 시 현재 상태를 저장하고 새 슬롯 데이터를 로드해 무기 상태 독립성을 유지한다.
    @ExecSpace("ServerOnly")
    method void ApplyWeaponSlot(integer slot)
        if self:IsValidSlot(slot) == false then
            return
        end

        local prevSlot = self.CurrentWeaponSlot
        self:SaveCurrentSlotState(prevSlot)

        local reloadComponent = self.Entity:GetComponent("ReloadComponent")
        if reloadComponent ~= nil and isvalid(reloadComponent) == true then
            reloadComponent:CancelCurrentReload()
            reloadComponent:SetCurrentWeaponSlot(slot)
        end

        local slotData = self:EnsureSlotData(slot)
        self:LoadSlotDataToCombatComponents(slotData, slot)

        self.CurrentWeaponSlot = slot
        self.HighlightedSlot = slot
        self:SaveCurrentSlotState(slot)
    end

    -- 슬롯 데이터는 공통 기본값을 강제해 무기 테이블 미완성 상태에서도 동작을 보장한다.
    method table EnsureSlotData(integer slot)
        local data = self:GetSlotData(slot)
        if data == nil then
            data = {}
        end

        if data.WeaponId == nil then data.WeaponId = "" end
        if data.MaxAmmo == nil then data.MaxAmmo = 30 end
        if data.CurrentAmmo == nil then data.CurrentAmmo = data.MaxAmmo end
        if data.ReloadTime == nil then data.ReloadTime = 1.5 end
        if data.FireRate == nil then data.FireRate = 0.5 end
        if data.FireCooldown == nil then data.FireCooldown = 0.5 end
        if data.BaseWeaponAttack == nil then data.BaseWeaponAttack = 10 end
        if data.ProjectileModelId == nil then data.ProjectileModelId = "" end
        if data.ProjectileSpeed == nil then data.ProjectileSpeed = 20.0 end
        if data.ProjectileRange == nil then data.ProjectileRange = 15.0 end
        if data.ProjectileLifetime == nil then data.ProjectileLifetime = 2.0 end
        if data.ProjectileSpread == nil then data.ProjectileSpread = 0 end

        self:SetSlotData(slot, data)
        return data
    end

    -- 현재 전투 컴포넌트 상태를 슬롯 데이터에 저장해 태그/재접근 시 복원 가능하게 만든다.
    @ExecSpace("ServerOnly")
    method void SaveCurrentSlotState(integer slot)
        if self:IsValidSlot(slot) == false then
            return
        end

        local data = self:EnsureSlotData(slot)

        local reloadComponent = self.Entity:GetComponent("ReloadComponent")
        if reloadComponent ~= nil and isvalid(reloadComponent) == true then
            data.MaxAmmo = reloadComponent.MaxAmmo
            data.ReloadTime = reloadComponent.ReloadTime
            data.FireRate = reloadComponent.FireRate
            data.CurrentAmmo = reloadComponent:GetSlotAmmo(slot)
        end

        local fireComponent = self.Entity:GetComponent("FireSystemComponent")
        if fireComponent ~= nil and isvalid(fireComponent) == true then
            data.FireCooldown = fireComponent.FireCooldown
            data.BaseWeaponAttack = fireComponent.BaseWeaponAttack
            data.ProjectileModelId = fireComponent.ProjectileModelId
            data.ProjectileSpeed = fireComponent.ProjectileSpeed
            data.ProjectileRange = fireComponent.ProjectileRange
            data.ProjectileLifetime = fireComponent.ProjectileLifetime
            data.ProjectileSpread = fireComponent.ProjectileSpread
        end

        self:SetSlotData(slot, data)
    end

    -- 슬롯 데이터 로드는 Reload/Fire 양쪽에 동시에 반영해 스탯-탄약 불일치를 막는다.
    @ExecSpace("ServerOnly")
    method void LoadSlotDataToCombatComponents(table data, integer slot)
        local reloadComponent = self.Entity:GetComponent("ReloadComponent")
        if reloadComponent ~= nil and isvalid(reloadComponent) == true then
            reloadComponent.MaxAmmo = data.MaxAmmo
            reloadComponent.ReloadTime = data.ReloadTime
            reloadComponent.FireRate = data.FireRate
            reloadComponent:SetSlotAmmo(slot, data.CurrentAmmo)
        end

        local fireComponent = self.Entity:GetComponent("FireSystemComponent")
        if fireComponent ~= nil and isvalid(fireComponent) == true then
            fireComponent.FireCooldown = data.FireCooldown
            fireComponent.BaseWeaponAttack = data.BaseWeaponAttack
            fireComponent.ProjectileModelId = data.ProjectileModelId
            fireComponent.ProjectileSpeed = data.ProjectileSpeed
            fireComponent.ProjectileRange = data.ProjectileRange
            fireComponent.ProjectileLifetime = data.ProjectileLifetime
            fireComponent.ProjectileSpread = data.ProjectileSpread
        end
    end

    -- 메뉴 열림 중에는 이동/공격을 동시에 잠가 시간정지 대체 플래그를 구현한다.
    @ExecSpace("ServerOnly")
    method void SetCombatInputLocked(boolean isLocked)
        self:TrySetMovementCanMove(isLocked == false)

        local fireComponent = self.Entity:GetComponent("FireSystemComponent")
        if fireComponent ~= nil and isvalid(fireComponent) == true then
            fireComponent.CanAttack = (isLocked == false)
        end
    end

    -- Resolves custom movement component first to avoid native MovementComponent name collisions.
    method Component ResolveProjectMovementComponent()
        local prefixed = self.Entity:GetComponent("script.MovementComponent")
        if self:CanWriteComponentField(prefixed, "CanMove") == true then
            return prefixed
        end

        local plain = self.Entity:GetComponent("MovementComponent")
        if self:CanWriteComponentField(plain, "CanMove") == true then
            return plain
        end

        return nil
    end

    -- Protects movement lock writes from runtime exceptions when wrong component type is returned.
    method boolean TrySetMovementCanMove(boolean canMove)
        local movementComponent = self:ResolveProjectMovementComponent()
        if movementComponent == nil then
            return false
        end

        local ok, _ = pcall(function()
            movementComponent.CanMove = canMove
        end)
        if ok == false then
            log_warning("[WeaponSwapComponent] Failed to set MovementComponent.CanMove")
            return false
        end

        return true
    end

    -- Uses read+write probe so nil-valued fields are still recognized while missing fields are rejected.
    method boolean CanWriteComponentField(any targetComponent, string fieldName)
        if targetComponent == nil or isvalid(targetComponent) == false then
            return false
        end
        if fieldName == nil or fieldName == "" then
            return false
        end

        local readOk, readValue = pcall(function()
            return targetComponent[fieldName]
        end)
        if readOk == false then
            return false
        end

        local writeOk, _ = pcall(function()
            targetComponent[fieldName] = readValue
        end)
        return writeOk
    end

    -- UI 갱신은 클라이언트 전용 호출로 분리해 서버 UI 참조 결합을 줄인다.
    @ExecSpace("Client")
    method void UpdateSwapUIClient(boolean isOpen, integer highlightedSlot)
        local wheelComponent = self.Entity:GetComponent("WeaponWheelUIComponent")
        if wheelComponent == nil or isvalid(wheelComponent) == false then
            return
        end

        wheelComponent:SetWheelVisible(isOpen, highlightedSlot)
    end

    -- 소유자 검증 로직을 공통화해 서버 요청 API마다 반복된 보안 실수를 방지한다.
    @ExecSpace("ServerOnly")
    method boolean IsRequestFromOwner()
        if self.Entity == nil or isvalid(self.Entity) == false then
            return false
        end

        local playerComponent = self.Entity.PlayerComponent
        if playerComponent == nil then
            return true
        end
        if senderUserId == nil then
            return true
        end

        return senderUserId == playerComponent.UserId
    end

    -- 오픈 가능 조건을 중앙화해 사망 상태에서 메뉴가 열리는 예외를 차단한다.
    @ExecSpace("ServerOnly")
    method boolean CanOpenSwapMenu()
        if self.AllowSwapMenu == false then
            return false
        end

        if self.IsSwapMenuOpen == true then
            return false
        end

        local hpComponent = self.Entity:GetComponent("HPSystemComponent")
        if hpComponent ~= nil and isvalid(hpComponent) == true then
            if hpComponent.IsDead == true then
                return false
            end
        end

        return true
    end

    -- WASD를 4방향 슬롯으로 매핑해 최소 기능 방사형 선택 UX를 구현한다.
    method integer MapKeyToSlot(KeyboardKey key)
        if key == KeyboardKey.W then return 1 end
        if key == KeyboardKey.D then return 2 end
        if key == KeyboardKey.S then return 3 end
        if key == KeyboardKey.A then return 4 end
        return 0
    end

    -- 슬롯 인덱스 검사를 공통화해 데이터 테이블 오염을 예방한다.
    method boolean IsValidSlot(integer slot)
        if slot < 1 then
            return false
        end

        return slot <= math.max(self.WeaponSlotCount, 1)
    end

    -- 슬롯 데이터 접근을 중앙화해 각 프로퍼티 분기 로직 중복을 줄인다.
    method table GetSlotData(integer slot)
        if slot == 1 then return self.Weapon1_Data end
        if slot == 2 then return self.Weapon2_Data end
        if slot == 3 then return self.Weapon3_Data end
        if slot == 4 then return self.Weapon4_Data end
        return nil
    end

    -- 슬롯 데이터 저장도 단일 함수로 관리해 속성 누락을 방지한다.
    method void SetSlotData(integer slot, table data)
        if slot == 1 then self.Weapon1_Data = data return end
        if slot == 2 then self.Weapon2_Data = data return end
        if slot == 3 then self.Weapon3_Data = data return end
        if slot == 4 then self.Weapon4_Data = data return end
    end

    -- 종료 시 잠금 상태를 풀어 맵 이동/재시작 후 입력 고정이 남지 않게 정리한다.
    @ExecSpace("ServerOnly")
    method void OnEndPlay()
        if self.IsSwapMenuOpen == true then
            self:CloseSwapMenu(false, self.CurrentWeaponSlot)
        end
    end
end


