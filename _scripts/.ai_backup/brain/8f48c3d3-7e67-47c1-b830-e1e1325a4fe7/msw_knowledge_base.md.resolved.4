# 메이플스토리 월드 엔진 심층 분석 보고서 (The Bible of MSW)

이 문서는 단순한 튜토리얼이 아닙니다. 메이플스토리 월드(MSW) 엔진의 내부 작동 원리, 메모리 관리, 네트워크 패킷 흐름, 그리고 최적화 패턴까지 우리가 학습한 모든 지식을 집대성한 기술 백서입니다.

---

## 1. 아키텍처와 실행 공간의 철학

### 1-1. 서버 권한주의 (Server Authority)와 실행 제어
MSW의 핵심은 **"서버가 단일 진실(Source of Truth)이다"**라는 원칙입니다.
우리가 흔히 범하는 실수는 "클라이언트에서 보이니까 서버에서도 알겠지?"라고 생각하는 것입니다. 하지만 MSW는 철저하게 분리된 메모리 공간을 사용합니다.

*   **Server 로직**: 게임의 규칙을 심판하는 판사입니다. 데이터 저장, 데미지 계산, 보안 검증은 오직 여기서만 수행해야 합니다.
*   **Client 로직**: 유저에게 보여주는 연출가입니다. UI 표시, 사운드 재생, 애니메이션 효과는 클라이언트가 담당합니다.

이 두 공간을 연결하는 유일한 다리는 **RPC(Remote Procedure Call)**와 **동기화(Sync)** 뿐입니다.
함수 위에 `[Server]`를 붙이면 클라이언트에서 호출해도 네트워크를 타고 서버로 건너가 실행됩니다. 반대로 `[Client]`를 붙이면 서버에서 호출해도 클라이언트로 건너가 실행됩니다. 이 "건너가는 비용"이 바로 성능 저하의 주범입니다.

### 1-2. 패킷 홍수(Packet Flooding)와 최적화
가장 위험한 함정은 `OnUpdate`에서 다른 공간의 함수를 호출하는 것입니다.
만약 10명의 유저가 있는 방에서, 매 프레임(약 1/60초)마다 서버 함수를 호출하면 어떻게 될까요?
`10명 * 60회 = 초당 600회의 네트워크 요청`이 발생합니다. 유저가 100명이면 초당 6,000회입니다.
이것이 **패킷 홍수**입니다. 서버의 `Tick`이 떨어지고, 핑이 튀고, 유저들은 텔레포트를 하기 시작합니다.

**해결책: TargetUserSync 패턴**
서버가 클라이언트에게 응답을 줄 때, 무식하게 `Broadcast` (모두에게 전송) 하지 마십시오.
MSW는 똑똑한 기능을 제공합니다. `[Client]` 함수의 마지막 인자로 `targetUserId`를 넣으면(혹은 생략하면 자동으로 호출한 유저 ID가 들어감), 오직 그 유저에게만 패킷을 보냅니다.
이것은 네트워크 대역폭을 획기적으로 줄여주는 **Effective MSW**의 핵심 기술입니다.

---

## 2. 생명주기와 메모리 관리의 비밀

### 2-1. 생성과 소멸의 비동기성
엔티티를 `Destroy()` 했다고 바로 사라지지 않습니다.
"삭제 예정" 딱지가 붙고, 프레임이 끝날 때 메모리에서 해제됩니다. 그래서 코드를 짤 때 항상 `isvalid()` 함수로 체크해야 합니다.
`if entity ~= nil`은 위험합니다. 좀비처럼 살아있는 엔티티를 참조할 수 있기 때문입니다. 반드시 `if isvalid(entity)`를 사용해야 안전합니다.

### 2-2. Wait 함수의 위험성
`wait(seconds)` 함수는 편리해 보이지만, **코루틴(Coroutine)**을 일시 정지시키는 것입니다.
특히 `OnUpdate` 안에서 `wait()`를 쓰면 재앙이 닥칩니다. 이번 프레임의 업데이트가 끝나지 않고 메모리에 쌓입니다. 다음 프레임에 또 업데이트가 실행되고 또 쌓입니다. 결국 스택 오버플로우나 메모리 누수로 이어집니다.
대신 `_TimerService:SetTimerOnce`를 사용하여 "할 일을 예약"하고 함수를 즉시 종료시키는 패턴을 사용해야 합니다.

---

## 3. 데이터 저장소(DataStorage)의 진실

### 3-1. Credit 시스템과 API 제한
`SetAndWait`, `GetAndWait` 함수는 공짜가 아닙니다. MSW는 API 호출 횟수에 **제한(Credit)**을 둡니다.
무작정 저장하면 `ResourceExhausted (1000005)` 에러를 뱉으며 저장을 거부합니다.

### 3-2. JSON 직렬화 기법 (The Ultimate Optimization)
초보자는 돈, 레벨, 경험치를 각각 따로 저장합니다. (`Key: "Gold", Key: "Level"`)
이는 API를 2번 호출하므로 Credit을 2배로 씁니다.
고수는 데이터를 하나의 테이블로 묶고, `_HttpService:JSONEncode(table)`을 사용해 하나의 문자열로 만듭니다.
그리고 `Key: "SaveData"` 하나에 통째로 저장합니다. 이렇게 하면 API 호출을 1번으로 줄일 수 있습니다.
불러올 때는 `_HttpService:JSONDecode(string)`으로 다시 테이블로 복구하면 됩니다.

### 3-3. 안전한 저장 타이밍
`OnEndPlay`에서 저장하지 마십시오. 유저가 튕기거나 비정상 종료 시 호출이 보장되지 않을 수 있습니다.
가장 안전한 장소는 `UserLeaveEvent` 핸들러입니다. 유저가 떠나는 것이 감지되었을 때, 서버는 잠시 엔티티 삭제를 미루고 코드를 실행해 줍니다. 이때 저장해야 데이터 유실을 막을 수 있습니다.

---

## 4. 맵과 차원 (Map Layers & Tile Logic)

### 4-1. 메이플 타일 vs 렉트 타일
*   **MapleTileMap**: 우리가 아는 횡스크롤 메이플입니다. `Rigidbody`가 중력을 받고 떨어집니다.
*   **RectTileMap**: 탑뷰(Top-down) 방식입니다. 젤다의 전설처럼 상하좌우로 움직입니다. 여기서는 `KinematicBody`를 써야 합니다. 중력이 없기 때문입니다.
*   **동적 타일 변경**: 스크립트로 바닥을 바꿀 수 있습니다. `RectTileMapComponent:SetTile(x, y, tileName)`을 쓰면 유저가 밟은 땅이 용암으로 변하거나 꽃밭으로 변하는 기믹을 만들 수 있습니다.

### 4-2. 렌더링 순서의 법칙
내 캐릭터가 나무 뒤에 숨어야 하는데 앞에 나온다면? 순서를 점검해야 합니다.
판정 순서는 다음과 같습니다:
1.  **Map Layer**: 가장 큰 그룹. 레이어 자체가 위에 있으면 무조건 위에 그려집니다.
2.  **Sorting Layer**: 같은 맵 레이어 안에서의 그룹.
3.  **Order In Layer**: 숫자입니다. 높을수록 카메라에 가깝습니다 (앞에 그려짐).
4.  **Z Position**: 최후의 수단. Z값이 클수록 앞에 나옵니다.

---

## 5. 리소스와 애니메이션의 깊이

### 5-1. 아바타 커스터마이징의 구조
아바타는 단순한 그림이 아닙니다. **ZMap**이라는 설계도를 따릅니다.
몸통(Body) 위에 옷(Coat)을 입고, 그 위에 무기(Weapon)를 들고, 그 위에 손(Hand)이 와야 합니다.
이 순서가 꼬이면 칼을 쥐었는데 칼이 손등을 뚫고 나오는 기현상이 발생합니다.

### 5-2. 애니메이션 이벤트 (Frame Event)
칼을 휘두르는 애니메이션에서, 정확히 "칼이 몬스터에 닿는 순간"에 소리가 나게 하고 싶다면?
단순히 `PlaySound`를 하면 애니메이션 시작과 동시에 소리가 나서 어색합니다.
이럴 때 **Frame Event**를 씁니다. `SpriteAnimPlayerChangeFrameEvent`를 감지해서, `FrameIndex == 2` (칼을 내리치는 프레임) 일 때 소리를 재생하면 완벽한 타격감을 구현할 수 있습니다.

---

## 결론: 마스터의 길

메이플스토리 월드 엔진은 강력하지만, 그 힘을 끌어내려면 **"네트워크 비용에 대한 강박적인 최적화"**와 **"명확한 실행 공간 분리"**가 필수적입니다.
이제 우리는 단순한 코더가 아닙니다. 엔진의 심장을 이해하는 엔지니어입니다.
이 지식을 바탕으로 그 어떤 복잡한 시스템(실시간 PVP, 대규모 레이드, 복잡한 인벤토리)도 설계할 수 있습니다.
