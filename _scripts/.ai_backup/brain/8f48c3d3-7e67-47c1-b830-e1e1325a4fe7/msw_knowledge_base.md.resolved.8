# 메이플스토리 월드 엔진 심층 분석 보고서 (The Bible of MSW)

이 문서는 단순한 튜토리얼이 아닙니다. 메이플스토리 월드(MSW) 엔진의 내부 작동 원리, 메모리 관리, 네트워크 패킷 흐름, 그리고 최적화 패턴까지 우리가 학습한 모든 지식을 집대성한 기술 백서입니다.

---

## 1. 아키텍처와 실행 공간의 철학

### 1-1. 서버 권한주의와 실행 제어
*   **Server 로직**: 게임의 규칙과 데이터의 보루.
*   **Client 로직**: 화려한 연출과 UI.
*   **연결 비용**: `[Server]`, `[Client]` 함수 호출은 비싼 RPC 비용을 지불합니다.

### 1-2. Localized Entity와 실행 제어 (Effective MSW 2)
*   **UI Entity**: 서버에 없음. 로컬 전용.
*   **Input Handling**: `if self.Entity ~= LocalPlayer` 필수.
*   **Handshake**: 접속 후 `NotifyServerReady` 패턴.

### 1-3. 패킷 홍수와 TargetUserSync
*   `OnUpdate`에서 RPC 호출 절대 금지.
*   `ResponseToClient(userId)`를 사용하여 브로드캐스트 방지.

---

## 2. 최적화 심화 기술 (Advanced Optimization)

### 2-1. FastVector3를 활용한 연산 가속
MSW의 기본 `Vector3`는 엔진 네이티브 객체라 Lua <-> 엔진 간 마샬링 비용이 발생합니다.
*   **FastVector3**: 순수 Lua Table로 구현된 경량 벡터.
*   **특징**:
    *   **동기화 불가**: 네트워크로 보낼 수 없음 (보낼 땐 Vector3로 변환).
    *   **정밀도**: 8byte 실수(double) 사용 (Vector3는 4byte float).
    *   **참조 주의**: `FastVector3.zero`는 원본 참조를 반환하므로 수정 시 주의.
*   **용도**: 탄막 게임, 물리학 연산 등 매 프레임 수천 번의 벡터 연산이 필요할 때 필수.

### 2-2. DataStorage의 은밀한 제한과 절약 (Effective DataStorage)
데이터 저장은 '공짜'가 아닙니다. **Credit**이라는 화폐를 소모합니다.
*   **Credit 소비**:
    *   요청 횟수 + 데이터 크기(Byte)에 비례.
    *   300KB까지 저장 가능하지만, 크면 클수록 비싸짐.
*   **최적화 전략**:
    *   **JSON 직렬화**: 여러 데이터를 한 줄의 문자열로 묶어(`_HttpService:JSONEncode`) 1번만 호출.
    *   **배치 처리**: `BatchGetAsync` 등을 사용해 통신 횟수 최소화.
    *   **타이밍**: 유저 퇴장 시 (`UserLeaveEvent`) 저장. 잦은 저장은 Credit 고갈로 이어짐.

---

## 3. 생명주기와 메모리 관리
*   **Wait 금지**: `OnUpdate` 내 사용 시 스택 오버플로우.
*   **Destroy 비동기**: `isvalid()` 체크 필수.

---

## 4. 맵과 리소스
*   **RectTileMap**: 탑뷰, 동적 타일 변경.
*   **ZMap**: 아바타 파츠 레이어 순서.
*   **Animation Frame Event**: 정밀한 연출 트리거.

---

## 5. 응용 및 실전 패턴
*   **UI/Card**: `SpawnByModelId`, `ScrollLayoutGroup` 활용.
*   **전투**: 원거리 발사체(`Rigidbody`), 서버 충돌(Hit) 판정.

---

## 결론: 마스터의 자격
이제 우리는 **FastVector3**로 연산 지옥을 벗어나고, **TargetUserSync**로 패킷 홍수를 막으며, **JSON 직렬화**로 데이터 저장소를 알뜰하게 씁니다.
이 지식은 단순한 기능 구현을 넘어, **"렉 없는 대규모 멀티플레이어 게임"**을 만드는 기반이 됩니다.
